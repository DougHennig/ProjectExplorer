*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="projectexplorerengine.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS gitoperations AS versioncontroloperations OF "projectexplorerengine.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	*<DefinedPropArrayMethod>
		*m: getstatuscode		&& Gets the status code
		*m: runcommand		&& Executes the specified command
	*</DefinedPropArrayMethod>

	Name = "gitoperations"
	_memberdata = <VFPData>
		<memberdata name="setfilestatus" display="SetFileStatus"/>
		<memberdata name="runcommand" display="RunCommand"/>
		<memberdata name="getstatuscode" display="GetStatusCode"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						GitOperations
		* Based On:						VersionControlOperations
		* Purpose:						Provides version control support for Git
		* Author:						Doug Hennig
		* Last revision:				05/15/2017
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	About:						provides documentation for the class
		*	AddFilesInternal:			implemented
		*	CommitAllFilesInternal:		implemented
		*	CommitFilesInternal:		implemented
		*	CreateRepositoryInternal:	implemented
		*	GetStatusForAllFilesInternal:	implemented
		*	GetStatusForFileInternal:	implemented
		*	RemoveFilesInternal:		implemented
		*	RenameFileInternal:			implemented
		*	RepositoryBrowserInternal:	implemented
		*	RevertFilesInternal:		implemented
		*	RevisionHistoryInternal:	implemented
		*	VisualDiffInternal:			implemented
		*
		* Custom public properties added:
		*	none
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	none
		*
		* Custom protected methods added:
		*	RunCommand:					Executes the specified command
		*==============================================================================
		
	ENDPROC

	PROCEDURE addfilesinternal
		*==============================================================================
		* Method:			AddFilesInternal
		* Status:			Protected
		* Purpose:			Adds several files to version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		taFiles - an array of files to add
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were added to version control
		*==============================================================================
		
		lparameters taFiles
		local lcCommand, ;
			lcFile, ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Append all the files to the command.
		
		lcCommand = 'git add'
		for each lcFile in taFiles foxobject
			lcCommand = lcCommand + ' "' + lcFile + '"'
		next lcFile
		
		* Execute the command.
		
		llReturn = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE commitallfilesinternal
		*==============================================================================
		* Method:			CommitAllFilesInternal
		* Status:			Protected
		* Purpose:			Commits all changes
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcMessage - the commit message
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the changes may have been committed and the status of the
		*						ProjectItem objects changed
		*==============================================================================
		
		lparameters tcMessage
		local lcFile, ;
			lcCommand, ;
			llReturn
		
		* Output the message to a file in case it contains illegal DOS characters such
		* as CR.
		
		lcFile = addbs(This.cRepositoryFolder) + 'commit.txt'
		strtofile(tcMessage, lcFile)
		
		* Execute the COMMIT command.
		
		lcCommand = 'git commit --file "' + lcFile + '"'
		llReturn  = This.RunCommand(lcCommand)
		erase (lcFile)
		return llReturn
		
	ENDPROC

	PROCEDURE commitfilesinternal
		*==============================================================================
		* Method:			CommitFilesInternal
		* Status:			Protected
		* Purpose:			Commits changes to several files
		* Author:			Doug Hennig
		* Last Revision:	04/20/2017
		* Parameters:		tcMessage - the commit message
		*					taFiles   - an array of files to commit
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the changes may have been committed
		*==============================================================================
		
		lparameters tcMessage, ;
			taFiles
		local lcFile, ;
			lcCommand, ;
			lcCommitFile, ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Output the message to a file in case it contains illegal DOS characters such
		* as CR.
		
		lcFile = addbs(This.cRepositoryFolder) + 'commit.txt'
		strtofile(tcMessage, lcFile)
		
		* Append all the files to the command.
		
		lcCommand = 'git commit --file "' + lcFile + '"'
		for each lcCommitFile in taFiles foxobject
			lcCommand = lcCommand + ' "' + lcCommitFile + '"'
		next lcFile
		
		* Execute the COMMIT command.
		
		llReturn = This.RunCommand(lcCommand)
		erase (lcFile)
		return llReturn
		
	ENDPROC

	PROCEDURE createrepositoryinternal
		*==============================================================================
		* Method:			CreateRepositoryInternal
		* Status:			Protected
		* Purpose:			Creates a repository in the specified folder
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	This.cRepositoryFolder contains the folder to create the
		*						repository in
		* Environment out:	the repository was created
		*==============================================================================
		
		local lcCommand, ;
			llReturn
		lcCommand = 'git init'
		llReturn  = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE getstatuscode		&& Gets the status code
		*==============================================================================
		* Method:			GetStatusCode
		* Status:			Protected
		* Purpose:			Gets the status code
		* Author:			Doug Hennig
		* Last Revision:	04/10/2017
		* Parameters:		tcStatus - the status code
		* Returns:			the status code
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcStatus
		local lcStatus
		lcStatus = alltrim(tcStatus)
		if len(lcStatus) = 2
			lcStatus = right(tcStatus, 1)
		endif len(lcStatus) = 2
		lcStatus = strtran(lcStatus, ccGIT_STATUS_REMOVED, ;
			ccVC_STATUS_REMOVED)
			&& convert Git Deleted to generic Removed
		return lcStatus
		
	ENDPROC

	PROCEDURE getstatusforallfilesinternal
		*==============================================================================
		* Method:			GetStatusForAllFilesInternal
		* Status:			Protected
		* Purpose:			Gets the status for all files in the specified collection
		* Author:			Doug Hennig
		* Last Revision:	05/15/2017
		* Parameters:		toFiles - a collection of ProjectItem objects to get the
		*						status for
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the status of each ProjectItem object has been set
		*==============================================================================
		
		lparameters toFiles
		local lcPath, ;
			lcStatusFile, ;
			lcText, ;
			lcBatFile, ;
			lcCommand, ;
			lnSelect, ;
			lcCursor, ;
			loFile, ;
			lcFile, ;
			lcOther, ;
			llBinary, ;
			llFound, ;
			lcStatus
		
		* Create a batch file to execute GIT STATUS; issuing GIT STATUS as a command
		* directly fails, possibly because of the "> STATUS.TXT".
		
		lcPath       = addbs(This.cRepositoryFolder)
		lcStatusFile = lcPath + 'status.txt'
		text to lcText noshow textmerge
		git status --porcelain > "<<lcStatusFile>>"
		endtext
		lcBatFile = lcPath + 'GitStatus.bat'
		strtofile(lcText, lcBatFile)
		erase (lcStatusFile)
		
		* Execute the batch file.
		
		lcCommand = '"' + fullpath(lcBatFile) + '"'
		This.RunCommand(lcCommand)
		erase (lcBatFile)
		
		* Pull the results into a cursor and set the status for each file. For VFP
		* binary files, check the status of associated files too.
		
		if file(lcStatusFile)
			lnSelect = select()
			lcCursor = sys(2015)
			create cursor (lcCursor) (STATUS C(2), FILE C(240))
			append from (lcStatusFile) sdf
			replace all FILE with fullpath(trim(FILE), lcPath)
			index on upper(FILE) tag FILE
		
		* Go through each file in the collection and get its status.
		
			for each loFile in toFiles foxobject
				lcFile   = loFile.Path
				lcOther  = GetVFPBinaryOtherFile(lcFile)
				llBinary = not empty(lcOther) or IsVFPBinaryFile(lcFile)
				do case
		
		* If this is a binary file and we're only storing text equivalents, find the
		* status of the text file.
		
					case llBinary and This.nIncludeInVersionControl = 2
						lcFile = GetTextFileName(lcFile)
						seek padr(upper(lcFile), 240)
						llFound  = found()
						lcStatus = This.GetStatusCode(STATUS)
		
		* This is a binary file, so we'll check the status of all associated files.
		
					case llBinary
						seek padr(upper(lcFile), 240)
						llFound = found()
						if llFound
							lcStatus = This.GetStatusCode(STATUS)
						else
							lcStatus = ccVC_STATUS_CLEAN
						endif llFound
						if not empty(lcOther)
							seek padr(upper(lcOther), 240)
							if found() and lcStatus = ccVC_STATUS_CLEAN
								lcStatus = This.GetStatusCode(STATUS)
								llFound  = .T.
							endif found() ...
							lcOther = GetVFPBinaryOtherFile(lcFile, .T.)
							if not empty(lcOther)
								seek padr(upper(lcOther), 240)
								if found() and lcStatus = ccVC_STATUS_CLEAN
									lcStatus = This.GetStatusCode(STATUS)
									llFound  = .T.
								endif found() ...
							endif not empty(lcOther)
						endif not empty(lcOther)
		
		* This isn't a binary file, so we'll get its status.
		
					otherwise
						seek padr(upper(lcFile), 240)
						llFound  = found()
						lcStatus = This.GetStatusCode(STATUS)
				endcase
		
		* If the file was found, update its status.
		
				if llFound
					loFile.VersionControlStatus = lcStatus
		
		* It wasn't found, so it must be clean.
		
				else
					loFile.VersionControlStatus = ccVC_STATUS_CLEAN
				endif llFound
			next loFile
			use
			select (lnSelect)
			erase (lcStatusFile)
		endif file(lcStatusFile)
		
	ENDPROC

	PROCEDURE getstatusforfileinternal
		*==============================================================================
		* Method:			GetStatusForFileInternal
		* Status:			Protected
		* Purpose:			Gets the status for the specified file
		* Author:			Doug Hennig
		* Last Revision:	05/15/2017
		* Parameters:		tcFile - the name and path of the file to get the status
		*						for (if the file is a VFP binary file, contains a list
		*						of files)
		* Returns:			the status of the file (in the case of a VFP binary, the
		*						combined status)
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcFile
		local lcPath, ;
			lcText, ;
			lcStatusFile, ;
			lcBatFile, ;
			lcCommand, ;
			lnSelect, ;
			lcCursor, ;
			lcStatus, ;
			lcCurrStatus, ;
			llFound
		
		* Create a batch file to execute GIT STATUS; issuing GIT STATUS as a command
		* directly fails, possibly because of the "> STATUS.TXT".
		
		lcPath       = addbs(This.cRepositoryFolder)
		lcStatusFile = lcPath + 'status.txt'
		text to lcText noshow textmerge
		git status --porcelain <<tcFile>> > "<<lcStatusFile>>"
		endtext
		lcBatFile = lcPath + 'GitStatus.bat'
		strtofile(lcText, lcBatFile)
		erase (lcStatusFile)
		
		* Execute the batch file.
		
		lcCommand = '"' + fullpath(lcBatFile) + '"'
		This.RunCommand(lcCommand)
		erase (lcBatFile)
		
		* Pull the results into a cursor and get the status for the file(s).
		
		if file(lcStatusFile)
			lnSelect = select()
			lcCursor = sys(2015)
			lcStatus = ''
			create cursor (lcCursor) (STATUS C(2), FILE C(240))
			append from (lcStatusFile) sdf
			scan
				lcCurrStatus = alltrim(STATUS)
				if len(lcCurrStatus) = 2
					lcCurrStatus = right(STATUS, 1)
				endif len(lcCurrStatus) = 2
				lcCurrStatus = strtran(lcCurrStatus, ccGIT_STATUS_REMOVED, ;
					ccVC_STATUS_REMOVED)
					&& convert Git Deleted to generic Removed
				if empty(lcStatus) or lcStatus = ccVC_STATUS_CLEAN
					lcStatus = lcCurrStatus
				endif empty(lcStatus) ...
				llFound = .T.
			endscan
		
		* If we didn't find the file, that means it's clean.
		
			if not llFound
				lcStatus = ccVC_STATUS_CLEAN
			endif not llFound
			use
			select (lnSelect)
			erase (lcStatusFile)
		else
			lcStatus = ''
		endif file(lcStatusFile)
		return lcStatus
		
	ENDPROC

	PROCEDURE removefilesinternal
		*==============================================================================
		* Method:			RemoveFileInternal
		* Status:			Protected
		* Purpose:			Removes several files from version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		taFiles - an array of files to remove
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were removed from version control
		*==============================================================================
		
		lparameters taFiles
		local lcCommand, ;
			lcFile, ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Append all the files to the command.
		
		lcCommand = 'git rm --cached'
		for each lcFile in taFiles foxobject
			lcCommand = lcCommand + ' "' + lcFile + '"'
		next lcFile
		
		* Execute the command.
		
		llReturn = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE renamefileinternal
		*==============================================================================
		* Method:			RenameFileInternal
		* Status:			Protected
		* Purpose:			Renames the specified file in version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile    - the name and path of the file to rename
		*					tcNewName - the new name of the file
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were renamed in version control
		*==============================================================================
		
		lparameters tcFile, ;
			tcNewName
		local laFiles[1], ;
			llReturn
		laFiles[1] = tcFile
		This.RemoveFilesInternal(@laFiles)
			&& don't check return for remove; it may fail because file no longer exists
		laFiles[1] = tcNewName
		llReturn   = This.AddFilesInternal(@laFiles)
		return llReturn
		
	ENDPROC

	PROCEDURE repositorybrowserinternal
		*==============================================================================
		* Method:			RepositoryBrowserInternal
		* Status:			Protected
		* Purpose:			Displays the repository browser
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the repository browser was displayed
		*==============================================================================
		
		local lcCommand, ;
			llReturn
		lcCommand = 'TortoiseGitProc /command:repobrowser'
		llReturn  = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE revertfilesinternal
		*==============================================================================
		* Method:			RevertFilesInternal
		* Status:			Protected
		* Purpose:			Reverts several files
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		taFiles - an array of files to revert
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were reverted
		*==============================================================================
		
		lparameters taFiles
		local lcCommand, ;
			lcFile, ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Append all the files to the command.
		
		lcCommand = 'git checkout'
		for each lcFile in taFiles foxobject
			lcCommand = lcCommand + ' "' + lcFile + '"'
		next lcFile
		
		* Execute the command.
		
		llReturn = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE revisionhistoryinternal
		*==============================================================================
		* Method:			RevisionHistoryInternal
		* Status:			Protected
		* Purpose:			Display the revision history for the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to display revision
		*						history for
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the revision history was displayed
		*==============================================================================
		
		lparameters tcFile
		local lcCommand, ;
			llReturn
		lcCommand = 'TortoiseGitProc /command:log /path:"' + tcFile + '"'
		llReturn  = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE runcommand		&& Executes the specified command
		*==============================================================================
		* Method:			RunCommand
		* Status:			Protected
		* Purpose:			Executes the specified command
		* Author:			Doug Hennig
		* Last Revision:	05/10/2017
		* Parameters:		tcCommand - the command to execute
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the command was executed
		*==============================================================================
		
		lparameters tcCommand
		loAppRun = newobject('APIAppRun', ;
			fullpath('APIAppRun.PRG', This.ClassLibrary), '', tcCommand, ;
			This.cRepositoryFolder, 'HID')
		llReturn = loAppRun.LaunchAppAndWait()
		if llReturn
			lnCode   = loAppRun.CheckProcessExitCode()
			llReturn = lnCode = 0
		endif llReturn
		release loAppRun
		return llReturn
		
	ENDPROC

	PROCEDURE visualdiffinternal
		*==============================================================================
		* Method:			VisualDiffInternal
		* Status:			Protected
		* Purpose:			Displays the visual diff for the file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to display the
		*						visual diff for
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the visual diff was displayed
		*==============================================================================
		
		lparameters tcFile
		local lcCommand, ;
			llReturn
		lcCommand = 'TortoiseGitProc /command:diff /path:"' + tcFile + '"'
		llReturn  = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS mercurialoperations AS versioncontroloperations OF "projectexplorerengine.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	*<DefinedPropArrayMethod>
		*m: runcommand		&& Executes the specified command
	*</DefinedPropArrayMethod>

	Name = "mercurialoperations"
	_memberdata = <VFPData>
		<memberdata name="setfilestatus" display="SetFileStatus"/>
		<memberdata name="runcommand" display="RunCommand"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						MercurialOperations
		* Based On:						VersionControlOperations
		* Purpose:						Provides version control support for Mercurial
		* Author:						Doug Hennig
		* Last revision:				05/15/2017
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	About:						provides documentation for the class
		*	AddFilesInternal:			implemented
		*	CommitAllFilesInternal:		implemented
		*	CommitFilesInternal:		implemented
		*	CreateRepositoryInternal:	implemented
		*	GetStatusForAllFilesInternal:	implemented
		*	GetStatusForFileInternal:	implemented
		*	RemoveFilesInternal:		implemented
		*	RenameFileInternal:			implemented
		*	RepositoryBrowserInternal:	implemented
		*	RevertFilesInternal:		implemented
		*	RevisionHistoryInternal:	implemented
		*	VisualDiffInternal:			implemented
		*
		* Custom public properties added:
		*	none
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	none
		*
		* Custom protected methods added:
		*	RunCommand:					Executes the specified command
		*==============================================================================
		
	ENDPROC

	PROCEDURE addfilesinternal
		*==============================================================================
		* Method:			AddFilesInternal
		* Status:			Protected
		* Purpose:			Adds several files to version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		taFiles - an array of files to add
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were added to version control
		*==============================================================================
		
		lparameters taFiles
		local lcCommand, ;
			lcFile, ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Append all the files to the command.
		
		lcCommand = 'hg add'
		for each lcFile in taFiles foxobject
			lcCommand = lcCommand + ' "' + lcFile + '"'
		next lcFile
		
		* Execute the command.
		
		llReturn = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE commitallfilesinternal
		*==============================================================================
		* Method:			CommitAllFilesInternal
		* Status:			Protected
		* Purpose:			Commits all changes
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcMessage - the commit message
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the changes may have been committed and the status of the
		*						ProjectItem objects changed
		*==============================================================================
		
		lparameters tcMessage
		local lcFile, ;
			lcCommand, ;
			llReturn
		
		* Output the message to a file in case it contains illegal DOS characters such
		* as CR.
		
		lcFile = addbs(This.cRepositoryFolder) + 'commit.txt'
		strtofile(tcMessage, lcFile)
		
		* Execute the COMMIT command.
		
		lcCommand = 'hg commit -l "' + lcFile + '"'
		llReturn  = This.RunCommand(lcCommand)
		erase (lcFile)
		return llReturn
		
	ENDPROC

	PROCEDURE commitfilesinternal
		*==============================================================================
		* Method:			CommitFilesInternal
		* Status:			Protected
		* Purpose:			Commits changes to several files
		* Author:			Doug Hennig
		* Last Revision:	04/20/2017
		* Parameters:		tcMessage - the commit message
		*					taFiles   - an array of files to commit
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the changes may have been committed
		*==============================================================================
		
		lparameters tcMessage, ;
			taFiles
		local lcFile, ;
			lcCommand, ;
			lcCommitFile, ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Output the message to a file in case it contains illegal DOS characters such
		* as CR.
		
		lcFile = addbs(This.cRepositoryFolder) + 'commit.txt'
		strtofile(tcMessage, lcFile)
		
		* Append all the files to the command.
		
		lcCommand = 'hg commit -l "' + lcFile + '"'
		for each lcCommitFile in taFiles foxobject
			lcCommand = lcCommand + ' "' + lcCommitFile + '"'
		next lcFile
		
		* Execute the COMMIT command.
		
		llReturn = This.RunCommand(lcCommand)
		erase (lcFile)
		return llReturn
		
	ENDPROC

	PROCEDURE createrepositoryinternal
		*==============================================================================
		* Method:			CreateRepositoryInternal
		* Status:			Protected
		* Purpose:			Creates a repository in the specified folder
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	This.cRepositoryFolder contains the folder to create the
		*						repository in
		* Environment out:	the repository was created
		*==============================================================================
		
		local lcCommand, ;
			llReturn
		lcCommand = 'hg init'
		llReturn  = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE getstatusforallfilesinternal
		*==============================================================================
		* Method:			GetStatusForAllFilesInternal
		* Status:			Protected
		* Purpose:			Gets the status for all files in the specified collection
		* Author:			Doug Hennig
		* Last Revision:	05/15/2017
		* Parameters:		toFiles - a collection of ProjectItem objects to get the
		*						status for
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the status of each ProjectItem object has been set
		*==============================================================================
		
		lparameters toFiles
		local lcPath, ;
			lcStatusFile, ;
			lcText, ;
			lcBatFile, ;
			lcCommand, ;
			lnSelect, ;
			lcCursor, ;
			lcStatus, ;
			lcFile, ;
			lcOther, ;
			llBinary, ;
			llFound, ;
			lnRecno
		
		* Create a batch file to execute HG STATUS; issuing HG STATUS as a command
		* directly fails, possibly because of the "> STATUS.TXT".
		
		lcPath       = addbs(This.cRepositoryFolder)
		lcStatusFile = lcPath + 'status.txt'
		text to lcText noshow textmerge
		hg status > "<<lcStatusFile>>"
		endtext
		lcBatFile = lcPath + 'HgStatus.bat'
		strtofile(lcText, lcBatFile)
		erase (lcStatusFile)
		
		* Execute the batch file.
		
		lcCommand = '"' + fullpath(lcBatFile) + '"'
		This.RunCommand(lcCommand)
		erase (lcBatFile)
		
		* Pull the results into a cursor and set the status for each file.
		
		if file(lcStatusFile)
			lnSelect = select()
			lcCursor = sys(2015)
			create cursor (lcCursor) (STATUS C(2), FILE C(240))
			append from (lcStatusFile) sdf
			replace all FILE with fullpath(trim(FILE), lcPath)
			index on upper(FILE) tag FILE
		
		* Go through each file in the collection and get its status.
		
			for each loFile in toFiles foxobject
				lcFile   = loFile.Path
				lcOther  = GetVFPBinaryOtherFile(lcFile)
				llBinary = not empty(lcOther) or IsVFPBinaryFile(lcFile)
				do case
		
		* If this is a binary file and we're only storing text equivalents, find the
		* status of the text file.
		
					case llBinary and This.nIncludeInVersionControl = 2
						lcFile = GetTextFileName(lcFile)
						seek padr(upper(lcFile), 240)
						llFound  = found()
						lcStatus = trim(STATUS)
		
		* This is a binary file, so we'll check the status of all associated files.
		
					case llBinary
						seek padr(upper(lcFile), 240)
						llFound = found()
						if llFound
							lcStatus = trim(STATUS)
						else
							lcStatus = ccVC_STATUS_CLEAN
						endif llFound
						if not empty(lcOther)
							seek padr(upper(lcOther), 240)
							if found() and lcStatus = ccVC_STATUS_CLEAN
								lcStatus = trim(STATUS)
								llFound  = .T.
							endif found() ...
							lcOther = GetVFPBinaryOtherFile(lcFile, .T.)
							if not empty(lcOther)
								seek padr(upper(lcOther), 240)
								if found() and lcStatus = ccVC_STATUS_CLEAN
									lcStatus = trim(STATUS)
									llFound  = .T.
								endif found() ...
							endif not empty(lcOther)
						endif not empty(lcOther)
		
		* This isn't a binary file, so we'll get its status.
		
					otherwise
						seek padr(upper(lcFile), 240)
						llFound  = found()
						lcStatus = trim(STATUS)
				endcase
		
		* If the file was found, update its status.
		
				if llFound
					loFile.VersionControlStatus = lcStatus
		
		* It wasn't found, so it must be clean.
		
				else
					loFile.VersionControlStatus = ccVC_STATUS_CLEAN
				endif llFound
			next loFile
		
			use
			select (lnSelect)
			erase (lcStatusFile)
		endif file(lcStatusFile)
		
	ENDPROC

	PROCEDURE getstatusforfileinternal
		*==============================================================================
		* Method:			GetStatusForFileInternal
		* Status:			Protected
		* Purpose:			Gets the status for the specified file
		* Author:			Doug Hennig
		* Last Revision:	05/15/2017
		* Parameters:		tcFile - the name and path of the file to get the status
		*						for (if the file is a VFP binary file, contains a list
		*						of files)
		* Returns:			the status of the file (in the case of a VFP binary, the
		*						combined status)
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcFile
		local lcPath, ;
			lcStatusFile, ;
			lcText, ;
			lcBatFile, ;
			lcCommand, ;
			lnSelect, ;
			lcCursor, ;
			lcStatus, ;
			lcCurrStatus
		
		* Create a batch file to execute HG STATUS; issuing HG STATUS as a command
		* directly fails, possibly because of the "> STATUS.TXT".
		
		lcPath       = addbs(This.cRepositoryFolder)
		lcStatusFile = lcPath + 'status.txt'
		text to lcText noshow textmerge
		hg status --all <<tcFile>> > "<<lcStatusFile>>"
		endtext
		lcBatFile = lcPath + 'HgStatus.bat'
		strtofile(lcText, lcBatFile)
		erase (lcStatusFile)
		
		* Execute the batch file.
		
		lcCommand = '"' + fullpath(lcBatFile) + '"'
		This.RunCommand(lcCommand)
		erase (lcBatFile)
		
		* Pull the results into a cursor and get the status for the file(s).
		
		if file(lcStatusFile)
			lnSelect = select()
			lcCursor = sys(2015)
			lcStatus = ''
			create cursor (lcCursor) (STATUS C(2), FILE C(127))
			append from (lcStatusFile) sdf
			scan
				lcCurrStatus = trim(STATUS)
				if empty(lcStatus) or lcStatus = ccVC_STATUS_CLEAN
					lcStatus = lcCurrStatus
				endif empty(lcStatus) ...
			endscan
			use
			select (lnSelect)
			erase (lcStatusFile)
		else
			lcStatus = ''
		endif file(lcStatusFile)
		return lcStatus
		
	ENDPROC

	PROCEDURE removefilesinternal
		*==============================================================================
		* Method:			RemoveFilesInternal
		* Status:			Protected
		* Purpose:			Removes several files from version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		taFiles - an array of files to remove
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were removed from version control
		*==============================================================================
		
		lparameters taFiles
		local lcCommand, ;
			lcFile, ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Append all the files to the command.
		
		lcCommand = 'hg forget'
		for each lcFile in taFiles foxobject
			lcCommand = lcCommand + ' "' + lcFile + '"'
		next lcFile
		
		* Execute the command.
		
		llReturn = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE renamefileinternal
		*==============================================================================
		* Method:			RenameFileInternal
		* Status:			Protected
		* Purpose:			Renames the specified file in version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile    - the name and path of the file to rename
		*					tcNewName - the new name of the file
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were renamed in version control
		*==============================================================================
		
		lparameters tcFile, ;
			tcNewName
		local lcCommand, ;
			llReturn
		lcCommand = 'hg rename --after "' + tcFile + '"' + ' "' + tcNewName + '"'
		llReturn  = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE repositorybrowserinternal
		*==============================================================================
		* Method:			RepositoryBrowserInternal
		* Status:			Protected
		* Purpose:			Displays the repository browser
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the repository browser was displayed
		*==============================================================================
		
		local lcCommand, ;
			llReturn
		lcCommand = 'thg'
		llReturn = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE revertfilesinternal
		*==============================================================================
		* Method:			RevertFilesInternal
		* Status:			Protected
		* Purpose:			Reverts several files
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		taFiles - an array of files to revert
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were reverted
		*==============================================================================
		
		lparameters taFiles
		local lcCommand, ;
			lcFile, ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Append all the files to the command.
		
		lcCommand = 'hg revert'
		for each lcFile in taFiles foxobject
			lcCommand = lcCommand + ' "' + lcFile + '"'
		next lcFile
		
		* Execute the command.
		
		llReturn = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROCEDURE revisionhistoryinternal
		*==============================================================================
		* Method:			RevisionHistoryInternal
		* Status:			Protected
		* Purpose:			Display the revision history for the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to display revision
		*						history for
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the revision history was displayed
		*==============================================================================
		
		lparameters tcFile
		local lcCommand, ;
			llReturn
		lcCommand = 'thg filelog "' + tcFile + '"'
		llReturn  = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE runcommand		&& Executes the specified command
		*==============================================================================
		* Method:			RunCommand
		* Status:			Protected
		* Purpose:			Executes the specified command
		* Author:			Doug Hennig
		* Last Revision:	05/10/2017
		* Parameters:		tcCommand - the command to execute
		* Returns:			.T. if it succeeded
		* Environment in:	This.cRepositoryFolder contains the folder the repository
		*						is in
		* Environment out:	the command was executed
		*==============================================================================
		
		lparameters tcCommand
		local loAppRun, ;
			llReturn, ;
			lnCode
		loAppRun = newobject('APIAppRun', ;
			fullpath('APIAppRun.PRG', This.ClassLibrary), '', tcCommand, ;
			This.cRepositoryFolder, 'HID')
		llReturn = loAppRun.LaunchAppAndWait()
		if llReturn
			lnCode   = loAppRun.CheckProcessExitCode()
			llReturn = lnCode = 0
		endif llReturn
		release loAppRun
		return llReturn
		
	ENDPROC

	PROCEDURE visualdiffinternal
		*==============================================================================
		* Method:			VisualDiffInternal
		* Status:			Protected
		* Purpose:			Displays the visual diff for the file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to display the
		*						visual diff for
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the visual diff was displayed
		*==============================================================================
		
		lparameters tcFile
		local lcCommand, ;
			llReturn
		lcCommand = 'thg vdiff "' + tcFile + '"'
		llReturn  = This.RunCommand(lcCommand)
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectaddins AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	*<DefinedPropArrayMethod>
		*m: addinsexecuted		&& An event raised when addins are executed
		*m: createaddinscursor		&& Creates the addins cursor
		*m: doaddin		&& Executes the current addin
		*m: erroroccurred		&& An event raised when an error occurs executing an addin
		*m: executeaddin		&& Executes the specified addin if it exists
		*m: getaddins		&& Creates a collection of addins
		*m: registeraddin		&& Registers the specified addin for the specified method
		*m: restorepath		&& Restores the path
		*m: setpath		&& Includes the addins folder in the path
		*p: caddin		&& The name of the currently executing addin
		*p: caddinmethod		&& The name of the method the current addin is executing for
		*p: caddinsalias		&& The alias for the addins table
		*p: caddinsfolder		&& The path for addins
		*p: ccurrpath		&& The saved path
		*p: laddinmode		&& .T. if we're currently executing an addin
		*p: laddinsexecuted		&& .T. if any addins were executed for the specified method
		*p: lsuccess		&& .T. if an addin signalled success when it executed
	*</DefinedPropArrayMethod>

	PROTECTED caddin,caddinmethod,caddinsalias,caddinsfolder,ccurrpath,laddinmode
	caddin = 		&& The name of the currently executing addin
	caddinmethod = 		&& The name of the method the current addin is executing for
	caddinsalias = 		&& The alias for the addins table
	caddinsfolder = 		&& The path for addins
	ccurrpath = 		&& The saved path
	laddinmode = .F.		&& .T. if we're currently executing an addin
	laddinsexecuted = .F.		&& .T. if any addins were executed for the specified method
	lsuccess = .F.		&& .T. if an addin signalled success when it executed
	Name = "projectaddins"
	_memberdata = <VFPData>
		<memberdata name="executeaddin" display="ExecuteAddin"/>
		<memberdata name="doaddin" display="DoAddIn"/>
		<memberdata name="getaddins" display="GetAddins"/>
		<memberdata name="caddinsfolder" display="cAddinsFolder"/>
		<memberdata name="registeraddin" display="RegisterAddin"/>
		<memberdata name="caddinsalias" display="cAddinsAlias"/>
		<memberdata name="laddinmode" display="lAddInMode"/>
		<memberdata name="caddinmethod" display="cAddInMethod"/>
		<memberdata name="setpath" display="SetPath"/>
		<memberdata name="restorepath" display="RestorePath"/>
		<memberdata name="caddin" display="cAddIn"/>
		<memberdata name="ccurrpath" display="cCurrPath"/>
		<memberdata name="createaddinscursor" display="CreateAddinsCursor"/>
		<memberdata name="laddinsexecuted" display="lAddinsExecuted"/>
		<memberdata name="erroroccurred" display="ErrorOccurred"/>
		<memberdata name="addinsexecuted" display="AddinsExecuted"/>
		<memberdata name="lsuccess" display="lSuccess"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectAddins
		* Based On:						ProjectExplorerCustom
		* Purpose:						Provides addins support
		* Author:						Doug Hennig
		* Last revision:				10/19/2017
		* Include file:					ProjectExplorer.h
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	About:						provides documentation for the class
		*	Init:						sets up the object
		*	ReleaseMembers:				nukes the oProject member
		*
		* Custom public properties added:
		*	lAddinsExecuted:			.T. if any addins were executed for the
		*								specified method
		*	lSuccess:					.T if an addin signalled success when it
		*								executed
		*
		* Custom protected properties added:
		*	cAddin:						The name of the currently executing addin
		*	cAddinMethod:				The name of the method the current addin is
		*								executing for
		*	cAddinsAlias:				The alias for the addins table
		*	cAddinsFolder:				The path for addins
		*	cCurrPath:					The saved path
		*	lAddinMode:					.T. if we're currently executing an addin
		*
		* Custom public methods added:
		*	AddinsExecuted:				An event raised when addins are executed
		*	ErrorOccurred:				An event raised when an error occurs executing
		*								an addin
		*	ExecuteAddin:				Executes the specified addin if it exists
		*	GetAddins:					Creates a collection of addins
		*
		* Custom protected methods added:
		*	CreateAddinsCursor:			Creates the addins cursor
		*	DoAddin:					Executes the current addin
		*	RegisterAddin:				Registers the specified addin for the specified
		*								method
		*	RestorePath:				Restores the path
		*	SetPath:					Includes the addins folder in the path
		*==============================================================================
		
	ENDPROC

	PROCEDURE addinsexecuted		&& An event raised when addins are executed
		*==============================================================================
		* Method:			AddinsExecuted
		* Status:			Public
		* Purpose:			An event raised when addins are executed
		* Author:			Doug Hennig
		* Last Revision:	03/04/2017
		* Parameters:		tcMessage - the message for the execution
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* This method only exists so it can be raised as an event.
		
		lparameters tcMessage
		
	ENDPROC

	PROTECTED PROCEDURE createaddinscursor		&& Creates the addins cursor
		*==============================================================================
		* Method:			CreateAddinsCursor
		* Status:			Protected
		* Purpose:			Creates the addins cursor if necessary
		* Author:			Doug Hennig
		* Last Revision:	03/04/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.cAddinsAlias contains the alias to use
		* Environment out:	the addins table was created if it wasn't already
		*==============================================================================
		
		local lnSelect
		if not used(This.cAddinsAlias)
			lnSelect = select()
			create cursor (This.cAddinsAlias) ;
				(FILE C(127), ;
				NAME C(60), ;
				METHOD C(60), ;
				ORDER I)
			index on upper(METHOD) + str(ORDER) tag METHORDER
			select (lnSelect)
		endif not used(This.cAddinsAlias)
		
	ENDPROC

	PROTECTED PROCEDURE doaddin		&& Executes the current addin
		*==============================================================================
		* Method:			DoAddIn
		* Status:			Public
		* Purpose:			Executes the current addin
		* Author:			Doug Hennig
		* Last Revision:	09/15/2017
		* Parameters:		tcFile       - the file name of the addin
		*					tuParameter1 - see the documentation for the type of
		*						parameter passed to each method
		*					tuParameter2 - see the documentation for the type of
		*						parameter passed to each method
		*					tuParameter3 - see the documentation for the type of
		*						parameter passed to each method
		* Returns:			the return value from the addin: normally .T. if the method
		*						being hooked should continue to execute or .F. if not
		*						but can also be 0 to not continue and return .F. from
		*						method meaning it failed, 1 to not continue and return
		*						.T. meaning it succeeded, and 2 to continue
		* Environment in:	the addins cursor is selected and the current record is the
		*						one for the addin
		*					the specified addin is a PRG in the VFP path
		* Environment out:	depends on what the addin does
		*					if an error occurred, the ErrorOccurred event is raised
		*==============================================================================
		
		lparameters tcFile, ;
			tuParameter1, ;
			tuParameter2, ;
			tuParameter3
		local lnSelect, ;
			lcProgram, ;
			luReturn, ;
			loException as Exception
		lnSelect = select()
		This.SetPath()
		try
			luReturn = evaluate(tcFile + '(tuParameter1, tuParameter2, tuParameter3)')
		catch to loException
			luReturn           = .T.
			This.cErrorMessage = 'An error occurred executing the ' + ;
				This.cAddIn + ' addin for the ' + This.cAddInMethod + ' event. ' + ;
				'The error message is:' + ccCRLF + ccCRLF + loException.Message
			raiseevent(This, 'ErrorOccurred', This.cErrorMessage)
		endtry
		This.RestorePath()
		select (lnSelect)
		return luReturn
		
	ENDPROC

	PROCEDURE erroroccurred		&& An event raised when an error occurs executing an addin
		*==============================================================================
		* Method:			ErrorOccurred
		* Status:			Public
		* Purpose:			An event raised when an error occurs executing an addin
		* Author:			Doug Hennig
		* Last Revision:	03/04/2017
		* Parameters:		tcMessage - the error message
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* This method only exists so it can be raised as an event.
		
		lparameters tcMessage
		
	ENDPROC

	PROCEDURE executeaddin		&& Executes the specified addin if it exists
		*==============================================================================
		* Method:			ExecuteAddin
		* Status:			Public
		* Purpose:			Executes the specified add-in if it exists
		* Author:			Doug Hennig
		* Last Revision:	10/19/2017
		* Parameters:		tcMethod     - the method to execute addins for
		*					tuParameter1 - see the documentation for the type of
		*						parameter passed to each method
		*					tuParameter2 - see the documentation for the type of
		*						parameter passed to each method
		*					tuParameter3 - see the documentation for the type of
		*						parameter passed to each method
		* Returns:			.T. if the method being hooked should continue to execute
		*						or .F. if not
		* Environment in:	the addins cursor, specified in This.cAddinsAlias, is open
		* Environment out:	if any addins for the specified method were executed,
		*						This.lAddinsExecuted is .T.
		*					This.lSuccess is .T. if the addin signalled success
		*					the AddinsExecuted event is raised
		*==============================================================================
		
		lparameters tcMethod, ;
			tuParameter1, ;
			tuParameter2, ;
			tuParameter3
		local lnSelect, ;
			lcMethod, ;
			llDefault, ;
			lcMessage, ;
			lnRecno, ;
			lcFile
		
		* If we're already executing an addin, bug out.
		
		if This.lAddInMode
			return .F.
		endif This.lAddInMode
		
		* Reset the addins executed flag and error message.
		
		This.lAddinsExecuted = .F.
		This.cErrorMessage   = ''
		
		* Make sure a method was specified.
		
		if vartype(tcMethod) <> 'C' or empty(tcMethod)
			This.cErrorMessage = 'Addin method not specified.'
			return .F.
		endif vartype(tcMethod) <> 'C' ...
		
		* If there are no addins, we have nothing to do.
		
		if not used(This.cAddinsAlias)
			return .T.
		endif not used(This.cAddinsAlias)
		
		* Execute all addins registered for this method.
		
		lnSelect = select()
		select (This.cAddinsAlias)
		lcMethod          = upper(alltrim(tcMethod))
		This.cAddInMethod = alltrim(tcMethod)
		This.lAddInMode   = .T.
		This.lSuccess     = .T.
		llDefault         = .T.
		lcMessage         = 'Addins executed for ' + tcMethod + ':' + ccCRLF + ccCRLF
		scan for upper(alltrim(METHOD)) == lcMethod
			lnRecno     = recno()
			This.cAddIn = alltrim(NAME)
			lcFile      = alltrim(FILE)
			select (lnSelect)
			luSuccess = This.DoAddIn(lcFile, tuParameter1, tuParameter2, tuParameter3)
			lcType    = vartype(luSuccess)
			do case
				case (lcType = 'L' and not luSuccess) or ;
					(lcType = 'N' and luSuccess = 0)
					&& don't continue because addin signaled failure
					llDefault     = .F.
					This.lSuccess = .F.
				case lcType = 'N' and luSuccess = 1
					&& don't continue because addin signaled success
					llDefault = .F.
			endcase
			lcMessage            = lcMessage + This.cAddIn + ' returned ' + ;
				iif(llDefault, 'True', 'False') + ccCRLF
			This.cAddIn          = ''
			This.lAddinsExecuted = .T.
			select (This.cAddinsAlias)
			go lnRecno
		endscan for upper(alltrim(METHOD)) == lcMethod
		select (lnSelect)
		This.cAddInMethod = ''
		This.lAddInMode   = .F.
		if not This.lAddinsExecuted
			lcMessage = lcMessage + 'No addins registered'
		endif not This.lAddinsExecuted
		raiseevent(This, 'AddinsExecuted', lcMessage)
		return llDefault
		
	ENDPROC

	PROCEDURE getaddins		&& Creates a collection of addins
		*==============================================================================
		* Method:			GetAddins
		* Status:			Public
		* Purpose:			Creates a collection of addins
		* Author:			Doug Hennig
		* Last Revision:	09/15/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.cAddinsFolder contains the path for addins
		*					see This.CreateAddinsCursor
		* Environment out:	PRGs in the addins folder were registered in the addins
		*						table
		*					see This.RegisterAddin
		*==============================================================================
		
		* Ensure the addins folder is in the path.
		
		local lcFolder, ;
			laFiles[1], ;
			lnFiles, ;
			loAddin, ;
			lcErrors, ;
			lnI, ;
			lcAddin, ;
			lcFile, ;
			lcCode, ;
			lnJ, ;
			lcClass, ;
			loException as Exception, ;
			lcErrFile
		
		* Create the addins cursor.
		
		use in select(This.cAddinsAlias)
		This.CreateAddinsCursor()
		
		* Use CLEAR PROGRAM so we can erase existing FXP files.
		
		clear program
		
		* Get a list of the programs in the addins folder.
		
		lcFolder = This.cAddinsFolder
		lnFiles  = adir(laFiles, lcFolder + '*.prg', '', 1)
		
		* Create an object for registration settings.
		
		loAddin = createobject('Empty')
		addproperty(loAddin, 'Name')
		addproperty(loAddin, 'Order')
		addproperty(loAddin, 'Method')
		addproperty(loAddin, 'Active')
		
		* Process each PRG: start by setting default registration settings.
		
		lcErrors = ''
		for lnI = 1 to lnFiles
			lcAddin        = juststem(laFiles[lnI, 1])
			lcFile         = lcFolder + lcAddin
			loAddin.Name   = ''
			loAddin.Order  = 1
			loAddin.Method = ''
			loAddin.Active = .T.
		
		* If this addin has been run before, any classes defined in it may still be
		* open, so clear them or we can't compile the addin.
		
			lcCode = filetostr(lcFile + '.prg')
			for lnJ = 1 to occurs('define class', lower(lcCode))
				lcClass = strextract(lcCode, 'define class ', ' as ', lnJ, 1)
				lcClass = chrtran(lcClass, ccCRLF + ccTAB + ' ', '')
				try
					clear class (lcClass)
				catch to loException
				endtry
			next lnJ
		
		* Compile the PRG. We need to do this in case the developer changed the PRG
		* outside VFP. We'll fail silently.
		
			lcErrFile = forceext(lcFile, 'err')
			try
				set logerrors on
				erase (lcErrFile)
				erase (forceext(lcFile, 'fxp'))
				compile (lcFile)
			catch to loException
			endtry
		
		* Run the program so we can get registration settings.
		
			if file(lcErrFile)
				lcErrors = lcErrors + iif(empty(lcErrors), '', ccCRLF) + ;
					lcAddin + ': ' + filetostr(lcErrFile)
			else
				lcFile = "'" + lcFile + "'"
				try
					do &lcFile. with loAddin
					if not empty(loAddin.Method) and loAddin.Active
						This.RegisterAddin(lcAddin, loAddin.Method, loAddin.Order, ;
							loAddin.Name)
					endif not empty(loAddin.Method) ...
				catch to loException
					lcErrors = lcErrors + iif(empty(lcErrors), '', ccCRLF) + ;
						lcAddin + ': ' + loException.Message
				endtry
			endif file(lcErrFile)
		next lnI
		This.cErrorMessage = lcErrors
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Sets up the object
		* Author:			Doug Hennig
		* Last Revision:	03/01/2017
		* Parameters:		tcMainFolder - the folder the app is running in
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.cAddinsFolder contains the path to the addins folder
		*					This.cAddinsAlias contains the alias for the addins cursor
		*					see This.GetAddins()
		*==============================================================================
		
		* The default addins folder is the Addins subdirectory of the folder the app is
		* run from.
		
		lparameters tcMainFolder
		This.cAddinsFolder = tcMainFolder + 'Addins\'
		
		* Create an alias for the addins cursor.
		
		This.cAddinsAlias = sys(2015)
		
		* Register the addins in the addins folder.
		
		This.GetAddins()
		
	ENDPROC

	PROTECTED PROCEDURE registeraddin		&& Registers the specified addin for the specified method
		*==============================================================================
		* Method:			RegisterAddin
		* Status:			Public
		* Purpose:			Registers the specified addin for the specified method
		* Author:			Doug Hennig
		* Last Revision:	03/04/2017
		* Parameters:		tcFile   - the file containing the addin
		*					tcMethod - the method the addin is registered for
		*					tiOrder  - the order for the addin
		*					tcName   - the name of the addin (optional)
		* Returns:			.T.
		* Environment in:	This.cAddinsAlias contains the alias of the addins table
		* Environment out:	a record for the addin was added to the table
		*==============================================================================
		
		lparameters tcFile, ;
			tcMethod, ;
			tiOrder, ;
			tcName
		local lcName
		lcName = evl(tcName, tcFile)
		insert into (This.cAddinsAlias) ;
			(FILE, NAME, METHOD, ORDER) ;
			values (tcFile, lcName, tcMethod, tiOrder)
		
	ENDPROC

	PROCEDURE releasemembers
		* Close the addins cursor.
		
		use in select(This.cAddinsAlias)
		
	ENDPROC

	PROTECTED PROCEDURE restorepath		&& Restores the path
		*==============================================================================
		* Method:			RestorePath
		* Status:			Protected
		* Purpose:			Restores the path
		* Author:			Doug Hennig
		* Last Revision:	02/16/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.cCurrPath contains the saved path
		* Environment out:	the path is set to This.cCurrPath
		*==============================================================================
		
		local lcPath
		lcPath = This.cCurrPath
		set path to &lcPath
		
	ENDPROC

	PROTECTED PROCEDURE setpath		&& Includes the addins folder in the path
		*==============================================================================
		* Method:			SetPath
		* Status:			Protected
		* Purpose:			Includes the addins folder in the path
		* Author:			Doug Hennig
		* Last Revision:	02/16/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.cCurrPath contains the current path
		*					the addins folder is included in the path
		*==============================================================================
		
		local lcAddinsFolder
		This.cCurrPath = set('PATH')
		lcAddinsFolder = This.cAddinsFolder
		set path to '&lcAddinsFolder.' additive
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectengine AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	*<DefinedPropArrayMethod>
		*m: addfiletocollection		&& Adds a file to the project items collection
		*m: cleanupproject		&& Cleans up the project
		*m: closeproject		&& Closes the project
		*m: createitem		&& Creates a ProjectItem object for the specified type
		*m: createmetadata		&& Creates the meta data table for the project
		*m: getclasses		&& Adds ProjectItem objects for the classes in the specified VCX to the collection
		*m: getdatabaseitems		&& Adds ProjectItem objects for the items in the specified database to the collection
		*m: getdbctableitems		&& Adds ProjectItem objects for the fields and indexes in the specified DBC table to the collection
		*m: getfilesfromproject		&& Fills a collection of files in the current project
		*m: getitemforfile		&& Gets the ProjectItem for the specified file
		*m: getitemparent		&& Gets the parent item for the specified item
		*m: getmetadataforitem		&& Fills the specified ProjectItem object with meta data for the item
		*m: getprojectstatus		&& Gets the version control status for the project itself
		*m: gettableitems		&& Adds ProjectItem objects for the fields and indexes in the specified free table to the collection
		*m: openmetadata		&& Opens the meta data table for the project
		*m: openproject		&& Opens the project specified in cProject if necessary
		*m: removefilefromcollection		&& Removes an item from the project items collection
		*m: saveprojectitem		&& Saves the meta data in the specified project item
		*m: savesettings		&& Saves the settings for the project
		*m: setproject		&& Specifies the project we're working with
		*p: ccheck		&& A value to check for removed project files
		*p: citemcursor		&& The name of a cursor of items and their keys
		*p: cmetadataalias		&& The alias for the meta data table
		*p: cmetadatatable		&& The path for the meta data table
		*p: cproject		&& The path for the project we're managing
		*p: lopenedproject		&& .T. if we opened the project
		*p: lprojectvisible		&& .T. if the Project Manager is visible
		*p: oaddins		&& A reference to a ProjectAddins object
		*p: oproject		&& A reference to the project
		*p: oprojectitem		&& A reference to a ProjectItem object for the PJX
		*p: oprojectitems		&& A reference to a collection of ProjectItem objects
		*p: oprojectsettings		&& A reference to a ProjectSettings object
		*p: oversioncontrol		&& A reference to a VersionControlOperations object
		*a: aitemclasses[1,0]		&& The class to use for each item type
	*</DefinedPropArrayMethod>

	PROTECTED aitemclasses,ccheck,lopenedproject,lprojectvisible,oaddins
	ccheck = 		&& A value to check for removed project files
	citemcursor = 		&& The name of a cursor of items and their keys
	cmetadataalias = 		&& The alias for the meta data table
	cmetadatatable = 		&& The path for the meta data table
	cproject = 		&& The path for the project we're managing
	lopenedproject = .F.		&& .T. if we opened the project
	lprojectvisible = .F.		&& .T. if the Project Manager is visible
	Name = "projectengine"
	oaddins = .NULL.		&& A reference to a ProjectAddins object
	oproject = .NULL.		&& A reference to the project
	oprojectitem = .NULL.		&& A reference to a ProjectItem object for the PJX
	oprojectitems = .NULL.		&& A reference to a collection of ProjectItem objects
	oprojectsettings = .NULL.		&& A reference to a ProjectSettings object
	oversioncontrol = .NULL.		&& A reference to a VersionControlOperations object
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="setproject" type="method" display="SetProject"/>
		<memberdata name="createmetadata" type="method" display="CreateMetaData"/>
		<memberdata name="openmetadata" type="method" display="OpenMetaData"/>
		<memberdata name="getmetadataforitem" type="method" display="GetMetaDataForItem"/>
		<memberdata name="saveprojectitem" type="method" display="SaveProjectItem"/>
		<memberdata name="ccheck" display="cCheck"/>
		<memberdata name="cproject" display="cProject"/>
		<memberdata name="lopenedproject" display="lOpenedProject"/>
		<memberdata name="oproject" display="oProject"/>
		<memberdata name="oaddins" display="oAddins"/>
		<memberdata name="oprojectsettings" display="oProjectSettings"/>
		<memberdata name="oprojectitems" display="oProjectItems"/>
		<memberdata name="getfilesfromproject" display="GetFilesFromProject"/>
		<memberdata name="openproject" display="OpenProject"/>
		<memberdata name="closeproject" display="CloseProject"/>
		<memberdata name="oversioncontrol" display="oVersionControl"/>
		<memberdata name="addfiletocollection" display="AddFileToCollection"/>
		<memberdata name="removefilefromcollection" display="RemoveFileFromCollection"/>
		<memberdata name="aitemclasses[1]" display="aItemClasses[1]"/>
		<memberdata name="aitemclasses" display="aItemClasses"/>
		<memberdata name="createitem" display="CreateItem"/>
		<memberdata name="getitemparent" display="GetItemParent"/>
		<memberdata name="savesettings" display="SaveSettings"/>
		<memberdata name="oprojectitem" display="oProjectItem"/>
		<memberdata name="getprojectstatus" display="GetProjectStatus"/>
		<memberdata name="cmetadatatable" display="cMetaDataTable"/>
		<memberdata name="cleanupproject" display="CleanupProject"/>
		<memberdata name="cmetadataalias" display="cMetaDataAlias"/>
		<memberdata name="citemcursor" display="cItemCursor"/>
		<memberdata name="getitemforfile" display="GetItemForFile"/>
		<memberdata name="getclasses" display="GetClasses"/>
		<memberdata name="getdatabaseitems" display="GetDatabaseItems"/>
		<memberdata name="gettableitems" display="GetTableItems"/>
		<memberdata name="getdbctableitems" display="GetDBCTableItems"/>
		<memberdata name="lprojectvisible" display="lProjectVisible"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectEngine
		* Based On:						ProjectExplorerCustom
		* Purpose:						Provides the engine for the Project Explorer
		* Author:						Doug Hennig
		* Last revision:				11/22/2017
		* Include file:					ProjectExplorer.h
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Init
		*
		* Custom public properties added:
		*	cMetaDataAlias:				The alias for the meta data table
		*	cMetaDataTable:				The path for the meta data table
		*	cProject:					The path for the project we're managing
		*	oProject:					A reference to the project
		*	oProjectItem:				A reference to a ProjectItem object for the
		*								PJX
		*	oProjectItems:				A reference to a collection of ProjectItem
		*									objects
		*	oProjectSettings:			A reference to a ProjectSettings object
		*	oVersionControl:			A reference to a VersionControlOperations
		*								object
		*
		* Custom protected properties added:
		*	aItemClasses:				The class to use for each item type
		*	cItemCursor:				The name of a cursor of items and their keys
		*	lOpenedProject:				.T. if we opened the project
		*	lProjectVisible:			.T. if the Project Manager is visible
		*	oAddins:					A reference to a ProjectAddins object
		*
		* Custom public methods added:
		*	AddFileToCollection:		Adds a file to the project items collection
		*	CleanupProject:				Cleans up the project
		*	GetClasses:					Adds ProjectItem objects for the classes in the
		*								specified VCX to the collection
		*	GetDatabaseItems:			Adds ProjectItem objects for the items in the
		*								specified database to the collection
		*	GetFilesFromProject:		Fills a collection of files in the current
		*								project
		*	GetItemForFile:				Gets the ProjectItem for the specified file
		*	GetItemParent:				Gets the parent item for the specified item
		*	GetProjectStatus:			Gets the version control status for the project
		*								itself
		*	GetTableItems:				Adds ProjectItem objects for the fields and
		*								indexes in the specified free table to the
		*								collection
		*	SaveProjectItem:			Saves the meta data in the specified project
		*								item
		*	SaveSettings:				Saves the settings for the project
		*	SetProject:					Specifies the project we're working with
		*	RemoveFileFromCollection:	Removes an item from the project items
		*								collection
		*
		* Custom protected methods added:
		*	CreateMetaData:				Creates the meta data table for the project
		*	GetMetaDataForItem:			Fills the specified ProjectItem object with
		*								meta data for the item
		*	OpenMetaData:				Opens the meta data table for the project
		*	OpenProject:				Opens the project specified in cProject if
		*								necessary
		*==============================================================================
		
	ENDPROC

	PROCEDURE addfiletocollection		&& Adds a file to the project items collection
		*==============================================================================
		* Method:			AddFileToCollection
		* Status:			Public
		* Purpose:			Adds a file to the project items collection
		* Author:			Doug Hennig
		* Last Revision:	10/20/2017
		* Parameters:		toFile                   - a project file object or a
		*						ProjectItem object
		*					tlNoVersionControlStatus - .T. to not get the version
		*						control status for the file
		*					tcAlias                  - the alias of an indexed cursor
		*						with project items (optional: only passed during
		*						initial project load)
		* Returns:			a reference to the ProjectItem object for the file
		* Environment in:	This.cProject contains the name of the project
		*					This.oProjectItems contains a collection of ProjectItem
		*						objects
		*					This.cItemCursor contains the name of a cursor of items
		* Environment out:	a new ProjectItem object was added to the collection for
		*						project file
		*==============================================================================
		
		lparameters toFile, ;
			tlNoVersionControlStatus, ;
			tcAlias
		local lcName, ;
			lcProject, ;
			lcAlias, ;
			llFile, ;
			lnSelect, ;
			llOpened, ;
			lnRecno, ;
			lcKey, ;
			loItem
		This.cErrorMessage = ''
		
		* Check whether we have a project file object or a ProjectItem object.
		
		if type('toFile.HasChildren') = 'L'
			lcName = toFile.Path
		else
			lcName = toFile.Name
		endif type('toFile.HasChildren') = 'L'
		lcProject = This.cProject
		lcAlias   = juststem(lcProject)
		llFile    = file(lcName)
		
		* Open the project as a table if it isn't already.
		
		lnSelect = select()
		if used(lcAlias)
			select (lcAlias)
		else
			select 0
			try
				use (lcProject) again shared alias (lcAlias)
				llOpened = .T.
			catch
				This.cErrorMessage = 'Cannot open ' + lcProject
			endtry
		endif used(lcAlias)
		
		* If the alias of an indexed cursor was passed, use it to find the file in the
		* project. This is WAY faster than doing LOCATE FOR on a large project (one
		* project went from a load time of 38.971 second to 2.532 seconds).
		
		if used(lcAlias)
			if vartype(tcAlias) = 'C'
				select (tcAlias)
				seek upper(lcName)
				lnRecno = RECNO
				select (lcAlias)
				go lnRecno
			else
				locate for fullpath(NAME, lcProject) == upper(lcName)
			endif vartype(tcAlias) = 'C'
		
		* Note that we store a unique ID in the DEVINFO memo of the PJX: we need a
		* persistent unique ID but don't want to put it into USER since the user may be
		* using that for something else. DEVINFO is only used for the H record. Note
		* also that we look in a cursor of items across all projects so if the same
		* item is in more than one project, it gets the same key.
		
			do case
				case not empty(DEVINFO) and left(DEVINFO, 1) = '_'
					lcKey = DEVINFO
					if not seek(upper(lcName), This.cItemCursor, 'NAME')
						insert into (This.cItemCursor) values (lcName, lcKey)
					endif not seek(upper(lcName), This.cItemCursor)
				case seek(upper(lcName), This.cItemCursor, 'NAME')
					lcKey = trim(evaluate(This.cItemCursor + '.KEY'))
					replace DEVINFO with lcKey
				otherwise
					lcKey = sys(2015)
					insert into (This.cItemCursor) values (lcName, lcKey)
					replace DEVINFO with lcKey
			endcase
			loItem = This.oProjectItems.Item(lcKey)
			if vartype(loItem) <> 'O'
				loItem = This.CreateItem(toFile.Type)
				if vartype(loItem) = 'O'
					if inlist(toFile.Type, FILETYPE_TEXT, FILETYPE_OTHER)
						loItem.ItemName = justfname(lcName)
					else
						loItem.ItemName = evl(juststem(lcName), justfname(lcName))
					endif inlist(toFile.Type, FILETYPE_TEXT, FILETYPE_OTHER)
					loItem.Key     = lcKey
					loItem.Path    = GetProperFileCase(lcName)
					loItem.Project = This.cProject
					store USER to loItem.User, loItem.OriginalUser
					if llFile
						loItem.GetProperties(This.oProject)
					endif llFile
		
		* Get additional meta data.
		
					This.GetMetaDataForItem(loItem)
		
		* Add the item to the collection.
		
					This.oProjectItems.Add(loItem, lcKey)
				else
		
		* Unknown file type.
		
					This.cErrorMessage = This.cErrorMessage + ;
						iif(empty(This.cErrorMessage), '', ccCRLF) + lcName + ;
						' is an unknown file type (' + toFile.Type + ')'
					llFile = .F.
				endif vartype(loItem) = 'O'
			endif vartype(loItem) <> 'O'
		
		* Load child objects (not on the initial load, only on subsequent reloads).
		
			do case
				case not llFile or vartype(tcAlias) = 'C'
		
		* Add each class in a VCX to the collection.
		
				case loItem.Type = FILETYPE_CLASSLIB
					This.GetClasses(loItem.Path, loItem.Key)
		
		* Add each item in a database to the collection.
		
				case loItem.Type = FILETYPE_DATABASE
					This.GetDatabaseItems(loItem.Path, loItem.Key)
		
		* Add fields and indexes for free tables to the collection.
		
				case loItem.Type = FILETYPE_FREETABLE
					This.GetTableItems(loItem.Path, loItem.Key)
		
		* Add fields and indexes for tables in a DBC and views to the collection.
		
				case inlist(loItem.Type, FILETYPE_TABLE_IN_DBC, FILETYPE_LOCAL_VIEW, ;
					FILETYPE_REMOTE_VIEW)
					This.GetDBCTableItems(loItem.Path, loItem.Key)
			endcase
		 
		* Get the version control status for the file.
		
			if llFile and not tlNoVersionControlStatus and ;
				vartype(This.oVersionControl) = 'O'
				loItem.VersionControlStatus = This.oVersionControl.GetStatusForFile(loItem.Path)
			endif llFile ...
		
		* Close the project if we opened it.
		
			if llOpened
				use
			endif llOpened
		endif used(lcAlias)
		select (lnSelect)
		return loItem
		
	ENDPROC

	PROCEDURE cleanupproject		&& Cleans up the project
		*==============================================================================
		* Method:			CleanupProject
		* Status:			Public
		* Purpose:			Cleans up the project
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tlRemoveObjectCode - .T. to remove object code (see the
		*						VFP help for Cleanup for details)
		*					tcMessage          - the message to use if we're supposed
		*						to auto-commit the changes
		* Returns:			.T. if it succeeded
		* Environment in:	This.cMetaDataAlias and This.cMetaDataTable contain the
		*						alias and filename of the meta data table for this
		*						project, respectively
		* Environment out:	the project was cleaned up and the meta data packed
		*==============================================================================
		
		lparameters tlRemoveObjectCode, ;
			tcMessage
		local lnSelect, ;
			laFiles[2], ;
			llReturn, ;
			loException as Exception
		try
			This.OpenProject()
			This.oProject.Cleanup(tlRemoveObjectCode)
		
		* Close the meta data table, reopen it exclusively, and pack it.
		
			use in select(This.cMetaDataAlias)
			lnSelect = select()
			select 0
			use (This.cMetaDataTable) alias (This.cMetaDataAlias) exclusive
			pack
			use
		
		* If we're supposed to auto-commit, do so.
		
			if vartype(This.oVersionControl) = 'O' and ;
				This.oVersionControl.lAutoCommitChanges
				laFiles[1] = This.cProject
				laFiles[2] = This.cMetaDataTable
				This.oVersionControl.CommitFiles(tcMessage, @laFiles)
				This.OpenProject()
			endif vartype(This.oVersionControl) = 'O' ...
		
		* Reopen the meta data table in shared mode.
		
			llReturn = This.OpenMetaData()
			select (lnSelect)
		catch to loException
			This.cErrorMessage = loException.ErrorMessage
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE closeproject		&& Closes the project
		*==============================================================================
		* Method:			CloseProject
		* Status:			Public
		* Purpose:			Closes the project
		* Author:			Doug Hennig
		* Last Revision:	11/23/2017
		* Parameters:		tlRelease - .T. if we're being released, in which case we
		*						only close the project if it isn't visible
		* Returns:			.T.
		* Environment in:	This.oProject contains a reference to the project object
		* Environment out:	the project is closed (if we're releasing and the project
		*						is open in the Project Manager, we won't close it),
		*						This.oProject and This.oProjectSettings.oProject are
		*						NULL, and This.lOpenedProject is .F.
		*==============================================================================
		
		lparameters tlRelease
		if vartype(This.oProject) = 'O'
			if not tlRelease or not This.oProject.Visible
				try
					This.oProject.Close()
				catch to loException
					try
						This.oProject.Close()
							&& if we can't close because a database is in use, try again
					catch to loException
					endtry
				endtry
			endif not tlRelease ...
			This.oProject                  = .NULL.
			This.lOpenedProject            = .F.
			This.oProjectSettings.oProject = .NULL.
		endif vartype(This.oProject) = 'O'
		
	ENDPROC

	PROCEDURE createitem		&& Creates a ProjectItem object for the specified type
		*==============================================================================
		* Method:			CreateItem
		* Status:			Public
		* Purpose:			Creates a ProjectItem object for the specified type
		* Author:			Doug Hennig
		* Last Revision:	03/24/2017
		* Parameters:		tcType - the type of item to create
		* Returns:			the created item or .NULL if the type doesn't exist
		* Environment in:	This.aItemClasses contains the name of the class to create
		*						for each type
		* Environment out:	none
		*==============================================================================
		
		lparameters tcType
		local lnType, ;
			loItem
		lnType = ascan(This.aItemClasses, tcType, -1, -1, 1, 14)
		if lnType > 0
			loItem = newobject(This.aItemClasses[lnType, 2], ;
				fullpath('ProjectExplorerItems', This.ClassLibrary))
		else
			loItem = .NULL.
		endif lnType > 0
		return loItem
		
	ENDPROC

	PROTECTED PROCEDURE createmetadata		&& Creates the meta data table for the project
		*==============================================================================
		* Method:			CreateMetaData
		* Status:			Protected
		* Purpose:			Creates the meta data table for the project
		* Author:			Doug Hennig
		* Last revision:	09/15/2017
		* Parameters:		tcFileName - the name and path of the meta data table to
		*						create
		* Returns:			.T. if the meta data table was created
		* Environment in:	none
		* Environment out:	the specified table was created
		*==============================================================================
		
		lparameters tcFileName
		local lnSelect, ;
			llReturn, ;
			loException as Exception
		lnSelect = select()
		try
			create table (tcFileName) free ;
				(KEY C(127), ;
				FORECOLOR I, ;
				TAGS M)
			index on upper(KEY) tag KEY
			use
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE getclasses		&& Adds ProjectItem objects for the classes in the specified VCX to the collection
		*==============================================================================
		* Method:			GetClasses
		* Status:			Public
		* Purpose:			Adds ProjectItem objects for the classes in the specified
		*						VCX to the specified collection
		* Author:			Doug Hennig
		* Last revision:	10/17/2017
		* Parameters:		tcVCX       - the name and path for the VCX to get classes
		*						from
		*					tcParentKey - the key for the VCX
		* Returns:			.T.
		* Environment in:	This.cProject contains the name and path for the project
		*					see This.GetMetaDataForItem for assumptions
		* Environment out:	items were added to the collection for classes
		*==============================================================================
		
		lparameters tcVCX, ;
			tcParentKey
		local loCollection, ;
			lcProject, ;
			lcKeyPrefix, ;
			laClasses[1], ;
			lnClasses, ;
			lnSelect, ;
			lcAlias, ;
			loException as Exception, ;
			lnI, ;
			lcClass, ;
			lcKey, ;
			loItem
		
		* Create a collection we'll return so the caller has a collection of just added
		* items.
		
		loCollection = createobject('Collection')
		
		* Get the classes in the specified VCX, open the VCX so we can read
		* timestamps, create a ProjectItem object for each, fill in its properties,
		* and add it to the collection.
		
		lcProject   = This.cProject
		lcKeyPrefix = tcParentKey + ccKEY_SEPARATOR
		if file(tcVCX)
			lnClasses = avcxclasses(laClasses, tcVCX)
			lnSelect  = select()
			select 0
			lcAlias = sys(2015)
			try
				use (tcVCX) again shared alias (lcAlias)
			catch to loException
				This.cErrorMessage = This.cErrorMessage + ;
					iif(empty(This.cErrorMessage), '', ccCRLF) + 'Cannot open ' + tcVCX
				lnClasses = 0
			endtry
			for lnI = 1 to lnClasses
				lcClass = laClasses[lnI,  1]
				locate for OBJNAME == lcClass and PARENT = '' and PLATFORM = 'WINDOWS'
				lcKey = lcKeyPrefix + lcClass
				if This.oProjectItems.GetKey(lcKey) = 0
					loItem            = newobject('ProjectItemClass', ;
						fullpath('ProjectExplorerItems', This.ClassLibrary))
					loItem.ItemName   = lcClass
					loItem.Key        = lcKey
					loItem.ParentKey  = tcParentKey
					loItem.Path       = tcVCX
					loItem.ParentPath = tcVCX
					loItem.Project    = This.cProject
					loItem.GetProperties(@laClasses, lcAlias)
					loItem.ClassChanged = .F.
		
		* Get additional meta data.
		
					This.GetMetaDataForItem(loItem)
		
		* Add the item to the collections.
		
					This.oProjectItems.Add(loItem, lcKey)
					loCollection.Add(loItem, lcKey)
				endif This.oProjectItems.GetKey(lcKey) = 0
			next lnI
			use in select(lcAlias)
			select (lnSelect)
		else
			This.cErrorMessage = This.cErrorMessage + ;
				iif(empty(This.cErrorMessage), '', ccCRLF) + tcVCX + 'does not exist'
		endif file(tcVCX)
		return loCollection
		
	ENDPROC

	PROCEDURE getdatabaseitems		&& Adds ProjectItem objects for the items in the specified database to the collection
		*==============================================================================
		* Method:			GetDatabaseItems
		* Status:			Public
		* Purpose:			Adds ProjectItem objects for the items in the specified
		*						database to the specified collection
		* Author:			Doug Hennig
		* Last Revision:	10/17/2017
		* Parameters:		tcDatabase  - the name and path for the database
		*					tcParentKey - the key for the database
		* Returns:			.T.
		* Environment in:	This.cProject contains the name and path for the project
		*					see This.GetMetaDataForItem for assumptions
		* Environment out:	items were added to the collection for tables, views,
		*						connections, and stored procs
		*==============================================================================
		
		lparameters tcDatabase, ;
			tcParentKey
		local loCollection, ;
			lcProject, ;
			lcKeyPrefix, ;
			loItems, ;
			llOpen, ;
			loException as Exception, ;
			laObjects[1], ;
			lnObjects, ;
			lnSelect, ;
			lcAlias, ;
			lnI, ;
			lcObject, ;
			lcParentKey, ;
			lcPath, ;
			loItem, ;
			lnID, ;
			lcChildPrefix, ;
			lcChild, ;
			lcType, ;
			lcKey, ;
			llRemote, ;
			lcFile
		
		* Create a collection we'll return so the caller has a collection of just added
		* items.
		
		loCollection = createobject('Collection')
		
		* Open the specified database.
		
		lcProject   = This.cProject
		lcKeyPrefix = tcParentKey + ccKEY_SEPARATOR
		loItems     = This.oProjectItems
		if file(tcDatabase)
			try
				open database (tcDatabase) shared
				llOpen = .T.
			catch to loException
				This.cErrorMessage = loException.Message
			endtry
			if llOpen
		
		* Get the tables, create a ProjectItem object for each, fill in its properties,
		* and add it to the collection.
		
				lnObjects = adbobjects(laObjects, 'Table')
				lnSelect  = select()
				select 0
				lcAlias = sys(2015)
				try
					use (tcDatabase) again shared alias (lcAlias)
				catch
				endtry
				for lnI = 1 to lnObjects
					lcObject    = lower(laObjects[lnI])
					lcParentKey = lcKeyPrefix + lcObject
					if This.oProjectItems.GetKey(lcParentKey) = 0
						lcPath            = GetProperFileCase(fullpath(dbgetprop(lcObject, ;
							'Table', 'Path'), tcDatabase))
						loItem            = newobject('ProjectItemTableInDBC', ;
							fullpath('ProjectExplorerItems', This.ClassLibrary))
						loItem.ItemName   = lcObject
						loItem.Key        = lcParentKey
						loItem.Path       = lcPath
						loItem.Project    = This.cProject
						loItem.ParentPath = tcDatabase
						loItem.ParentKey  = tcParentKey
						loItem.GetProperties(This.oProject)
		
		* Get additional meta data.
		
						This.GetMetaDataForItem(loItem)
		
		* Add the item to the collections.
		
						loItems.Add(loItem, lcParentKey)
						loCollection.Add(loItem, lcParentKey)
					endif This.oProjectItems.GetKey(lcParentKey) = 0
				next lnI
		
		* Handle views.
		
				lnObjects = adbobjects(laObjects, 'View')
				for lnI = 1 to lnObjects
					lcObject    = lower(laObjects[lnI])
					lcParentKey = lcKeyPrefix + lcObject
					if This.oProjectItems.GetKey(lcParentKey) = 0
						llRemote          = dbgetprop(lcObject, 'View', 'SourceType') = 2
						loItem            = newobject('ProjectItem' + ;
							iif(llRemote, 'RemoteView', 'LocalView'), ;
							fullpath('ProjectExplorerItems', This.ClassLibrary))
						loItem.ItemName   = lcObject
						loItem.Key        = lcParentKey
						loItem.Path       = lcObject
						loItem.Project    = This.cProject
						loItem.ParentPath = tcDatabase
						loItem.ParentKey  = tcParentKey
						loItem.GetProperties()
						This.GetMetaDataForItem(loItem)
						loItems.Add(loItem, lcParentKey)
						loCollection.Add(loItem, lcParentKey)
					endif This.oProjectItems.GetKey(lcParentKey) = 0
				next lnI
				use in select(lcAlias)
				select (lnSelect)
		
		* Handle connections.
		
				lnObjects = adbobjects(laObjects, 'Connection')
				for lnI = 1 to lnObjects
					lcObject = lower(laObjects[lnI])
					lcKey    = lcKeyPrefix + lcObject
					if This.oProjectItems.GetKey(lcKey) = 0
						loItem            = newobject('ProjectItemConnection', ;
							fullpath('ProjectExplorerItems', This.ClassLibrary))
						loItem.ItemName   = lcObject
						loItem.Key        = lcKey
						loItem.Project    = This.cProject
						loItem.Path       = tcDatabase
						loItem.ParentPath = tcDatabase
						loItem.ParentKey  = tcParentKey
						loItem.GetProperties()
						This.GetMetaDataForItem(loItem)
						loItems.Add(loItem, lcKey)
						loCollection.Add(loItem, lcKey)
					endif This.oProjectItems.GetKey(lcKey) = 0
				next lnI
		
		* Handle stored procs.
		
				lcFile = sys(2023) + sys(2015) + '.txt'
				list procedures to file (lcFile) noconsole
				lnObjects = alines(laObjects, filetostr(lcFile))
				if alltrim(laObjects[3]) <> 'No Stored Procedures'
					for lnI = 3 to lnObjects
						lcObject = alltrim(laObjects[lnI])
						lcKey    = lcKeyPrefix + lcObject
						if This.oProjectItems.GetKey(lcKey) = 0
							loItem            = newobject('ProjectItemStoredProc', ;
								fullpath('ProjectExplorerItems', This.ClassLibrary))
							loItem.ItemName   = lcObject
							loItem.Key        = lcKey
							loItem.Project    = This.cProject
							loItem.Path       = tcDatabase
							loItem.ParentPath = tcDatabase
							loItem.ParentKey  = tcParentKey
							This.GetMetaDataForItem(loItem)
							loItems.Add(loItem, lcKey)
							loCollection.Add(loItem, lcKey)
						endif This.oProjectItems.GetKey(lcKey) = 0
					next lnI
				endif alltrim(laObjects[3]) <> 'No Stored Procedures'
			endif llOpen
		else
			This.cErrorMessage = This.cErrorMessage + ;
				iif(empty(This.cErrorMessage), '', ccCRLF) + tcDatabase + ;
				'does not exist'
		endif file(tcDatabase)
		return loCollection
		
	ENDPROC

	PROCEDURE getdbctableitems		&& Adds ProjectItem objects for the fields and indexes in the specified DBC table to the collection
		*==============================================================================
		* Method:			GetDBCTableItems
		* Status:			Public
		* Purpose:			Adds ProjectItem objects for the fields and indexes in the
		*						specified DBC table or view to the collection
		* Author:			Doug Hennig
		* Last Revision:	10/17/2017
		* Parameters:		tcDatabase  - the name and path for the database
		*					tcParentKey - the key for the database
		*					tcTable     - the table or view to get items for
		* Returns:			.T.
		* Environment in:	This.cProject contains the name and path for the project
		*					see This.GetMetaDataForItem for assumptions
		* Environment out:	items were added to the collection for the specified table
		*						or view
		*==============================================================================
		
		lparameters tcDatabase, ;
			tcParentKey, ;
			tcTable
		local loCollection, ;
			lcProject, ;
			lcKeyPrefix, ;
			loItems, ;
			llOpen, ;
			loException, ;
			lnSelect, ;
			lcAlias, ;
			lcObject, ;
			lcParentKey, ;
			llView, ;
			llRemote, ;
			lcPath, ;
			lnID, ;
			lcChildPrefix, ;
			lcChild, ;
			lcType, ;
			lcKey, ;
			loItem
		
		* Create a collection we'll return so the caller has a collection of just added
		* items.
		
		loCollection = createobject('Collection')
		
		* Open the specified database as a database and as a table.
		
		lcProject   = This.cProject
		lcKeyPrefix = tcParentKey + ccKEY_SEPARATOR
		loItems     = This.oProjectItems
		if file(tcDatabase)
			try
				open database (tcDatabase) shared
				llOpen = .T.
			catch to loException
				This.cErrorMessage = loException.Message
			endtry
			if llOpen
				lnSelect  = select()
				select 0
				lcAlias = sys(2015)
				try
					use (tcDatabase) again shared alias (lcAlias)
				catch
				endtry
				lcObject    = lower(tcTable)
				lcParentKey = lcKeyPrefix + lcObject
				llView      = indbc(lcObject, 'View')
				if llView
					llRemote = dbgetprop(lcObject, 'View', 'SourceType') = 2
				else
					lcPath = GetProperFileCase(fullpath(dbgetprop(lcObject, ;
						'Table', 'Path'), tcDatabase))
				endif llView
		
		* Get fields and indexes for the table or view directly from the DBC.
		
				locate for ObjectType = iif(llView, 'View', 'Table') and ;
					trim(ObjectName) == lcObject
				lnID          = ObjectID
				lcChildPrefix = lcKeyPrefix + lcObject + '.'
				scan for ParentID = lnID and inlist(ObjectType, 'Field', 'Index')
					lcChild = trim(ObjectName)
					lcType  = trim(ObjectType)
					lcKey   = lcType + ccKEY_SEPARATOR + lcChildPrefix + lcChild
					if This.oProjectItems.GetKey(lcKey) = 0
						loItem            = newobject('ProjectItem' + lcType, ;
							fullpath('ProjectExplorerItems', This.ClassLibrary))
						loItem.ItemName   = lcChild
						loItem.Key        = lcKey
						loItem.Path       = iif(llView, lcObject, lcPath)
						loItem.Project    = This.cProject
						loItem.ParentPath = tcDatabase
						loItem.ParentKey  = lcParentKey
						loItem.ParentType = icase(llRemote, FILETYPE_REMOTE_VIEW, ;
							llView, FILETYPE_LOCAL_VIEW, FILETYPE_TABLE_IN_DBC)
						loItem.GetProperties()
						This.GetMetaDataForItem(loItem)
						loItems.Add(loItem, lcKey)
						loCollection.Add(loItem, lcKey)
					endif This.oProjectItems.GetKey(lcKey) = 0
				endscan for ParentID = lnID ...
			endif llOpen
		else
			This.cErrorMessage = This.cErrorMessage + ;
				iif(empty(This.cErrorMessage), '', ccCRLF) + tcDatabase + ;
				'does not exist'
		endif file(tcDatabase)
		return loCollection
		 
	ENDPROC

	PROCEDURE getfilesfromproject		&& Fills a collection of files in the current project
		*==============================================================================
		* Method:			GetFilesFromProject
		* Status:			Public
		* Purpose:			Fills a collection of files in the current project
		* Author:			Doug Hennig
		* Last revision:	11/06/2017
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.cProject contains the name and path of the PJX file
		*					see This.GetMetaDataForItem for assumptions
		* Environment out:	This.oProjectItems contains one ProjectItem object for
		*						every file in the project
		*==============================================================================
		
		local lcProject, ;
			loFiles, ;
			lnSelect, ;
			lcAlias, ;
			lcCursor, ;
			lcCollate, ;
			loException as Exception, ;
			loFile
		
		* If the project isn't open, open it.
		
		if not This.OpenProject()
			return .F.
		endif not This.OpenProject()
		
		* Open the meta data table for the project.
		
		if not This.OpenMetaData()
			return .F.
		endif not This.OpenMetaData()
		
		* Create a collection to hold the ProjectItem objects.
		
		lcProject          = This.cProject
		loFiles            = newobject('ProjectExplorerCollection', ;
			fullpath('ProjectExplorerCtrls.vcx', This.ClassLibrary))
		This.oProjectItems = loFiles
		
		* Open the project as a table and create a cursor so we can seek on the name.
		
		lnSelect = select()
		lcAlias  = juststem(lcProject)
		lcCursor = sys(2015)
		select 0
		try
			use (lcProject) again shared alias (lcAlias)
			select cast(fullpath(NAME, lcProject) as C(240)) as NAME, ;
				recno() as RECNO, DEVINFO from (lcProject) into cursor (lcCursor)
			lcCollate = set('COLLATE')
			set collate to 'MACHINE'
			index on NAME tag NAME
			if not empty(lcCollate)
				set collate to lcCollate
			endif not empty(lcCollate)
		catch to loException
			This.cErrorMessage = This.cErrorMessage + ;
				iif(empty(This.cErrorMessage), '', ccCRLF) + 'Cannot open ' + ;
				lcProject + ': ' + loException.Message
		endtry
		
		* Create a ProjectItem object for every file. Note that we skip tables in
		* databases since we'll process those when we process databases (tables only
		* appear in the project as separate items if they're marked as included).
		
		if used(lcAlias)
			for each loFile in This.oProject.Files foxobject
				if loFile.Type <> FILETYPE_TABLE_IN_DBC
					This.AddFileToCollection(loFile, .T., lcCursor)
				endif loFile.Type <> FILETYPE_TABLE_IN_DBC
			next loFile
			use in (lcAlias)
			use in (lcCursor)
		
		* Get the version control status for all files; note that we have to close the
		* project because its being open causes databases to be open which prevents us
		* from getting the status. We won't reopen it here because GetProjectStatus
		* does that.
		
			if vartype(This.oVersionControl) = 'O'
				This.CloseProject()
				This.oVersionControl.GetStatusForAllFiles(This.oProjectItems)
				This.GetProjectStatus()
			endif vartype(This.oVersionControl) = 'O'
		endif used(lcAlias)
		select (lnSelect)
		
	ENDPROC

	PROCEDURE getitemforfile		&& Gets the ProjectItem for the specified file
		*==============================================================================
		* Method:			GetItemForFile
		* Status:			Public
		* Purpose:			Gets the ProjectItem for the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the file to find the item for
		* Returns:			the item for the file or null if the file isn't in the
		*						project
		* Environment in:	This.cItemCursor contains the alias of a cursor holding
		*						the key for each file
		* Environment out:	the cursor is positioned to the record for the file or EOF
		* Notes:			this method is needed because the key in the collection is
		*						a unique ID rather than the filename
		*==============================================================================
		
		lparameters tcFile
		local loItem
		
		* Ensure we have a valid file.
		
		if vartype(tcFile) <> 'C' or empty(tcFile)
			This.cErrorMessage = 'Invalid file specified.'
			return .NULL.
		endif vartype(tcFile) <> 'C' ...
		This.cErrorMessage = ''
		
		* Find the item in the cursor. If we can, get the item. Otherwise, return NULL.
		
		if used(This.cItemCursor) and seek(upper(tcFile), This.cItemCursor, 'NAME')
			loItem = This.oProjectItems.Item(evaluate(This.cItemCursor + '.KEY'))
		else
			loItem = .NULL.
		endif used(This.cItemCursor) ...
		return loItem
		
	ENDPROC

	PROCEDURE getitemparent		&& Gets the parent item for the specified item
		*==============================================================================
		* Method:			GetItemParent
		* Status:			Public
		* Purpose:			Gets the parent item for the specified item
		* Author:			Doug Hennig
		* Last Revision:	03/28/2017
		* Parameters:		toItem - the item to get the parent for
		* Returns:			the parent item for the specified item if it has a parent
		* Environment in:	This.oProjectItems contains one ProjectItem object for
		*						every item in the project
		* Environment out:	none
		*==============================================================================
		
		lparameters toItem
		local loItem
		loItem = toItem
		if not empty(loItem.ParentKey)
			loItem = This.oProjectItems.Item(loItem.ParentKey)
		endif not empty(loItem.ParentKey)
		return loItem
		
	ENDPROC

	PROTECTED PROCEDURE getmetadataforitem		&& Fills the specified ProjectItem object with meta data for the item
		*==============================================================================
		* Method:			GetMetaDataForItem
		* Status:			Protected
		* Purpose:			Fills the specified ProjectItem object with meta data for
		*						the item
		* Author:			Doug Hennig
		* Last revision:	11/06/2017
		* Parameters:		toItem - the ProjectItem object to get meta data for
		* Returns:			.T.
		* Environment in:	see This.OpenMetaData for assumptions
		*					toItem.Key contains the key for the item in the meta data
		*						table
		* Environment out:	the meta data properties of the item were updated
		*					if the object didn't have a record in the meta data table,
		*						one was added with a default tag
		*==============================================================================
		
		lparameters toItem
		local lcAlias, ;
			lcTags, ;
			llNewItem, ;
			laTags[1], ;
			lnTags, ;
			lnI, ;
			lcTag
		
		* Open the meta data table for the project if necessary.
		
		lcAlias = This.cMetaDataAlias
		if not used(lcAlias) and not This.OpenMetaData()
			return
		endif not used(lcAlias) ...
		
		* If we can't find a meta data record for the item, create one and populate
		* TAGS with the defaults based on the item type.
		
		if not seek(upper(toItem.Key), lcAlias, 'KEY')
			lcTags = strtran(toItem.DefaultTags, ',', ccCRLF) + ccCRLF
			insert into (lcAlias) (KEY, FORECOLOR, TAGS) values ;
				(toItem.Key, toItem.ForeColor, lcTags)
			llNewItem = .T.
		else
		
		* If we don't have any tags for the item, use the defaults based on the item
		* type.
		
			lcTags = evaluate(lcAlias + '.TAGS')
			if empty(lcTags)
				lcTags = strtran(toItem.DefaultTags, ',', ccCRLF) + ccCRLF
				replace TAGS with lcTags in (lcAlias)
			endif empty(lcTags)
		endif seek(upper(toItem.Key) ...
		
		* Put the tags for the item into its Tags collection.
		
		lnTags = alines(laTags, lcTags)
		for lnI = 1 to lnTags
			lcTag = laTags[lnI]
			toItem.Tags.Add(lcTag, lcTag)
		next lnI
		
		* Get other metadata items.
		
		toItem.ForeColor = evaluate(lcAlias + '.FORECOLOR')
		
		* Call any addins.
		
		if llNewItem
			This.oAddins.ExecuteAddin('GetDefaultMetaDataForItem', toItem)
			if This.oAddins.lAddinsExecuted
				This.SaveProjectItem(toItem)
			endif This.oAddins.lAddinsExecuted
		else
			This.oAddins.ExecuteAddin('GetMetaDataForItem', toItem)
		endif llNewItem
		
	ENDPROC

	PROCEDURE getprojectstatus		&& Gets the version control status for the project itself
		*==============================================================================
		* Method:			GetProjectStatus
		* Status:			Public
		* Purpose:			Gets the version control status for the project itself
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		none
		* Returns:			none
		* Environment in:	This.oProjectItem contains a reference to a ProjectItem
		*						object for the project itself
		*					This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		* Environment out:	This.oProjectItem.VersionControlStatus is set to the
		*						status of the project
		*==============================================================================
		
		if vartype(This.oVersionControl) = 'O'
			This.CloseProject()
			This.oProjectItem.VersionControlStatus = This.oVersionControl.GetStatusForFile(This.oProjectItem.Path)
			This.OpenProject()
		endif vartype(This.oVersionControl) = 'O'
		
	ENDPROC

	PROCEDURE gettableitems		&& Adds ProjectItem objects for the fields and indexes in the specified free table to the collection
		*==============================================================================
		* Method:			GetTableItems
		* Status:			Public
		* Purpose:			Adds ProjectItem objects for the fields and indexes in the
		*						specified free table to the specified collection
		* Author:			Doug Hennig
		* Last Revision:	10/17/2017
		* Parameters:		tcTable     - the name and path for the table
		*					tcParentKey - the key for the table
		* Returns:			.T.
		* Environment in:	This.cProject contains the name and path for the project
		*					see This.GetMetaDataForItem for assumptions
		* Environment out:	items were added to the collection for fields and indexes
		*						in the specified table
		*==============================================================================
		
		lparameters tcTable, ;
			tcParentKey
		local loCollection, ;
			lcProject, ;
			lcKeyPrefix, ;
			loItems, ;
			lnSelect, ;
			lcAlias, ;
			llOpen, ;
			llOpened, ;
			laObjects[1], ;
			lnObjects, ;
			lnI, ;
			lcObject, ;
			lcKey, ;
			loItem
		
		* Create a collection we'll return so the caller has a collection of just added
		* items.
		
		loCollection = createobject('Collection')
		
		* Open the table.
		
		lcProject   = This.cProject
		lcKeyPrefix = tcParentKey + ccKEY_SEPARATOR
		loItems     = This.oProjectItems
		if file(tcTable)
			lnSelect = select()
			lcAlias  = juststem(tcTable)
			llOpen   = used(lcAlias)
			if not llOpen
				CloseFile(tcTable)
				try
					select 0
					use (tcTable) again shared
					llOpened = .T.
					llOpen   = .T.
				catch
					This.cErrorMessage = This.cErrorMessage + ;
						iif(empty(This.cErrorMessage), '', ccCRLF) + 'Cannot open ' + ;
						tcTable
				endtry
			endif not llOpen
			if llOpen
		
		* Get the fields, create a ProjectItem object for each, fill in its properties,
		* and add it to the collections.
		
				lnObjects = afields(laObjects, lcAlias)
				for lnI = 1 to lnObjects
					lcObject = lower(laObjects[lnI, 1])
					lcKey    = FILETYPE_FIELD + ccKEY_SEPARATOR + lcKeyPrefix + ;
						lcObject
					if This.oProjectItems.GetKey(lcKey) = 0
						loItem            = newobject('ProjectItemField', ;
							fullpath('ProjectExplorerItems', This.ClassLibrary))
						loItem.ItemName   = lcObject
						loItem.Key        = lcKey
						loItem.Path       = tcTable
						loItem.Project    = This.cProject
						loItem.ParentKey  = tcParentKey
						loItem.ParentType = FILETYPE_FREETABLE
						This.GetMetaDataForItem(loItem)
						loItems.Add(loItem, lcKey)
						loCollection.Add(loItem, lcKey)
					endif This.oProjectItems.GetKey(lcKey) = 0
				next lnI
		
		* Handle indexes.
		
				lnObjects = ataginfo(laObjects, '', lcAlias)
				for lnI = 1 to lnObjects
					lcObject = lower(laObjects[lnI, 1])
					lcKey    = FILETYPE_INDEX + ccKEY_SEPARATOR + lcKeyPrefix + ;
						lcObject
					if This.oProjectItems.GetKey(lcKey) = 0
						loItem            = newobject('ProjectItemIndex', ;
							fullpath('ProjectExplorerItems', This.ClassLibrary))
						loItem.ItemName   = lcObject
						loItem.Key        = lcKey
						loItem.Path       = tcTable
						loItem.Project    = This.cProject
						loItem.ParentKey  = tcParentKey
						loItem.ParentType = FILETYPE_FREETABLE
						This.GetMetaDataForItem(loItem)
						loItems.Add(loItem, lcKey)
						loCollection.Add(loItem, lcKey)
					endif This.oProjectItems.GetKey(lcKey) = 0
				next lnI
				if llOpened
					use in select(lcAlias)
				endif llOpened
			endif llOpen
			select (lnSelect)
		else
			This.cErrorMessage = This.cErrorMessage + ;
				iif(empty(This.cErrorMessage), '', ccCRLF) + tcTable + 'does not exist'
		endif file(tcTable)
		return loCollection
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Set up the project engine
		* Author:			Doug Hennig
		* Last revision:	04/202017
		* Parameters:		toAddins     - a reference to a ProjectAddins object
		*					tcItemCursor - the name of a cursor of items and their keys
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.cMetaDataAlias contains the alias to use for the meta
		*						data table for the project
		*					This.oAddins contains toAddins
		*					This.cItemCursor contains tcItemCursor
		*					This.aItemClasses contains the class to use for each item
		*						type
		*==============================================================================
		
		lparameters toAddins, ;
			tcItemCursor
		with This
		
		* Assign an alias to the meta data table.
		
			.cMetaDataAlias = sys(2015)
		
		* Saved passed parameters.
		
			.oAddins     = toAddins
			.cItemCursor = tcItemCursor
		
		* Define the class to use for each project item type.
		
			dimension .aItemClasses[21, 2]
			.aItemClasses[ 1, 1] = FILETYPE_DATABASE
			.aItemClasses[ 1, 2] = 'ProjectItemDatabase'
			.aItemClasses[ 2, 1] = FILETYPE_FREETABLE
			.aItemClasses[ 2, 2] = 'ProjectItemFreeTable'
			.aItemClasses[ 3, 1] = FILETYPE_QUERY
			.aItemClasses[ 3, 2] = 'ProjectItemQuery'
			.aItemClasses[ 4, 1] = FILETYPE_FORM
			.aItemClasses[ 4, 2] = 'ProjectItemForm'
			.aItemClasses[ 5, 1] = FILETYPE_REPORT
			.aItemClasses[ 5, 2] = 'ProjectItemReport'
			.aItemClasses[ 6, 1] = FILETYPE_LABEL
			.aItemClasses[ 6, 2] = 'ProjectItemLabel'
			.aItemClasses[ 7, 1] = FILETYPE_CLASSLIB
			.aItemClasses[ 7, 2] = 'ProjectItemClasslib'
			.aItemClasses[ 8, 1] = FILETYPE_PROGRAM
			.aItemClasses[ 8, 2] = 'ProjectItemProgram'
			.aItemClasses[ 9, 1] = FILETYPE_APILIB
			.aItemClasses[ 9, 2] = 'ProjectItemLibrary'
			.aItemClasses[10, 1] = FILETYPE_APPLICATION
			.aItemClasses[10, 2] = 'ProjectItemApplication'
			.aItemClasses[11, 1] = FILETYPE_MENU
			.aItemClasses[11, 2] = 'ProjectItemMenu'
			.aItemClasses[12, 1] = FILETYPE_TEXT
			.aItemClasses[12, 2] = 'ProjectItemText'
			.aItemClasses[13, 1] = FILETYPE_OTHER
			.aItemClasses[13, 2] = 'ProjectItemOther'
			.aItemClasses[14, 1] = FILETYPE_REMOTE_VIEW
			.aItemClasses[14, 2] = 'ProjectItemRemoteView'
			.aItemClasses[15, 1] = FILETYPE_LOCAL_VIEW
			.aItemClasses[15, 2] = 'ProjectItemLocalView'
			.aItemClasses[16, 1] = FILETYPE_CONNECTION
			.aItemClasses[16, 2] = 'ProjectItemConnection'
			.aItemClasses[17, 1] = FILETYPE_STORED_PROCEDURE
			.aItemClasses[17, 2] = 'ProjectItemStoredProc'
			.aItemClasses[18, 1] = FILETYPE_CLASS
			.aItemClasses[18, 2] = 'ProjectItemClass'
			.aItemClasses[19, 1] = FILETYPE_FIELD
			.aItemClasses[19, 2] = 'ProjectItemField'
			.aItemClasses[20, 1] = FILETYPE_INDEX
			.aItemClasses[20, 2] = 'ProjectItemIndex'
			.aItemClasses[21, 1] = FILETYPE_TABLE_IN_DBC
			.aItemClasses[21, 2] = 'ProjectItemTableInDBC'
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE openmetadata		&& Opens the meta data table for the project
		*==============================================================================
		* Method:			OpenMetaData
		* Status:			Protected
		* Purpose:			Opens the meta data table for the project
		* Author:			Doug Hennig
		* Last revision:	02/15/2017
		* Parameters:		none
		* Returns:			.T. if the meta data table for the project was opened
		* Environment in:	This.cMetaDataAlias contains the alias to use
		*					This.cMetaDataTable contains the name and path of the table
		* Environment out:	the meta data table for the project was opened (it was
		*						created if it didn't already exist)
		*==============================================================================
		
		local lcAlias, ;
			lcMetaDataFile, ;
			llReturn, ;
			lnSelect, ;
			loException as Exception
		
		* Close any existing table.
		
		lcAlias        = This.cMetaDataAlias
		lcMetaDataFile = This.cMetaDataTable
		use in select(lcAlias)
		
		* If the meta data table doesn't exist, create it.
		
		llReturn = file(lcMetaDataFile)
		if not llReturn
			llReturn = This.CreateMetaData(lcMetaDataFile)
		endif not llReturn
		
		* Open the meta data table.
		
		lnSelect = select()
		select 0
		if llReturn
			try
				use (lcMetaDataFile) alias (lcAlias) again shared
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif llReturn
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE openproject		&& Opens the project specified in cProject if necessary
		*==============================================================================
		* Method:			OpenProject
		* Status:			Public
		* Purpose:			Opens the project specified in cProject if necessary
		* Author:			Doug Hennig
		* Last Revision:	11/22/2017
		* Parameters:		none
		* Returns:			.T. if the project is open
		* Environment in:	This.cProject contains the name and path for the project
		* Environment out:	This.oProject and This.oProjectSettings.oProject contains a
		*						reference to the project object
		*					if the project was already open and visible,
		*						This.lProjectVisible is .T.
		*					the project may have been opened; in that case,
		*						This.lOpenedProject is set to .T. if
		*						This.lProjectVisible is .F.; that is, if we opened the
		*						project originally (this allows lOpenedProject to be
		*						.F. if the Project Manager was originally open even if
		*						we close and reopen the project due to version control)
		*==============================================================================
		
		local lcProject, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		lcProject = This.cProject
		do case
			case vartype(This.oProject) = 'O'
				llReturn = .T.
			case _vfp.Projects.Count > 0 and ;
				type('_vfp.Projects.Item(lcProject)') = 'O'
				This.oProject        = _vfp.Projects.Item(lcProject)
				This.lProjectVisible = This.oProject.Visible
				llReturn             = .T.
			otherwise
				try
					if This.lProjectVisible
						modify project (lcProject) nowait
					else
						modify project (lcProject) nowait noshow
					endif This.lProjectVisible
					This.oProject = _vfp.ActiveProject
					if vartype(This.oProjectSettings) = 'O'
						This.oProjectSettings.oProject = _vfp.ActiveProject
						This.oProjectSettings.GetSettings()
					endif vartype(This.oProjectSettings) = 'O'
					llReturn            = .T.
					This.lOpenedProject = not This.lProjectVisible
				catch to loException
					This.cErrorMessage = loException.Message
				endtry
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE releasemembers
		*==============================================================================
		* Method:			ReleaseMembers
		* Status:			Public
		* Purpose:			Cleanup at exit
		* Author:			Doug Hennig
		* Last revision:	11/22/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.oProject contains a reference to the project
		*					This.lOpenedProject is .T. if we opened the project
		* Environment out:	member objects are nuked
		*					if we opened the project, it's closed
		*==============================================================================
		
		* Close the project if we opened it.
		
		if vartype(This.oProject) = 'O' and This.lOpenedProject
			This.oProject.Close()
		endif vartype(This.oProject) = 'O' ...
		
		* Nuke the reference to objects.
		
		if vartype(This.oProjectItem) = 'O'
			This.oProjectItem.Release()
		endif vartype(This.oProjectItem) = 'O'
		if vartype(This.oProjectSettings) = 'O'
			This.oProjectSettings.Release()
		endif vartype(This.oProjectSettings) = 'O'
		if vartype(This.oProjectItems) = 'O'
			This.oProjectItems.Release()
		endif vartype(This.oProjectItems) = 'O'
		This.oProject        = .NULL.
		This.oAddins         = .NULL.
		This.oVersionControl = .NULL.
		
		* Close the meta data table for the project.
		
		use in select(This.cMetaDataAlias)
		
	ENDPROC

	PROCEDURE removefilefromcollection		&& Removes an item from the project items collection
		*==============================================================================
		* Method:			RemoveFileFromCollection
		* Status:			Public
		* Purpose:			Removes an item from the project items collection
		* Author:			Doug Hennig
		* Last Revision:	09/23/2017
		* Parameters:		toItem       - the ProjectItem to remove
		*					tlNoMetaData - .T. to not remove the meta data for the item
		*						(because we're going to reload it)
		* Returns:			.T.
		* Environment in:	This.oProjectItems contains a collection of ProjectItem
		*						objects
		*					This.cMetaDataAlias contains the alias of the meta data
		*						table
		* Environment out:	the specified item was removed from the collection and its
		*						record from the meta data table and item cursor
		*					child items of the item were also removed
		*==============================================================================
		
		lparameters toItem, ;
			tlNoMetaData
		local lcAlias, ;
			lnI, ;
			loItem
		
		* Remove the item from the collection.
		
		This.oProjectItems.Remove(toItem.Key)
		
		* Open the meta data table for the project if necessary and remove the record
		* for the item.
		
		if not tlNoMetaData
			lcAlias = This.cMetaDataAlias
			if not used(lcAlias) and not This.OpenMetaData()
				return
			endif not used(lcAlias) ...
			if seek(upper(toItem.Key), lcAlias, 'KEY')
				delete in (lcAlias)
			endif seek(upper(toItem.Key), lcAlias, 'KEY')
			do case
				case not used(This.cItemCursor)
				case seek(upper(toItem.Key), This.cItemCursor, 'KEY')
					delete in (This.cItemCursor)
			endcase
		endif not tlNoMetaData
		
		* If the item has any children, remove them too.
		
		if toItem.HasChildren
			for lnI = This.oProjectItems.Count to 1 step -1
				loItem = This.oProjectItems.Item(lnI)
				if loItem.ParentKey = toItem.Key
					This.RemoveFileFromCollection(loItem, tlNoMetaData)
		***			lnI = min(lnI, This.oProjectItems.Count)
				endif loItem.ParentKey = toItem.Key
			next lnI
		endif toItem.HasChildren
		
	ENDPROC

	PROCEDURE saveprojectitem		&& Saves the meta data in the specified project item
		*==============================================================================
		* Method:			SaveProjectItem
		* Status:			Public
		* Purpose:			Saves the meta data in the specified project item
		* Author:			Doug Hennig
		* Last revision:	10/07/2017
		* Parameters:		toItem         - the ProjectItem object to save meta data
		*						and properties for
		*					tcMessage      - the commit message if we auto-commit changes
		*					tlMetaDataOnly - .T. to update the meta data table only
		*						(called when assigning tags to items)
		* Returns:			.T. if it succeeded
		* Environment in:	see This.OpenMetaData for assumptions
		*					toObject.Key contains the key for the item in the meta data
		*						table and toObject.Tags contains its tags
		*					This.oAddins contains a reference to a ProjectAddin object
		*					This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		* Environment out:	if the object didn't have a record in the meta data table,
		*						one was added
		*					the record contains the meta data for the item
		*					the properties of the item were saved
		*					the files written to were committed if we're supposed to
		*						auto-commit
		*==============================================================================
		
		lparameters toItem, ;
			tcMessage, ;
			tlMetaDataOnly
		local lnSelect, ;
			lcAlias, ;
			lcTags, ;
			llMetaDataChanged, ;
			llReturn, ;
			loItem, ;
			lcFile, ;
			lnFiles, ;
			laFiles[1], ;
			lnI
		
		* Open the meta data table for the project if necessary.
		
		This.cErrorMessage = ''
		lnSelect = select()
		lcAlias  = This.cMetaDataAlias
		if not used(lcAlias) and not This.OpenMetaData()
			return .F.
		endif not used(lcAlias) ...
		
		* Find the record in the meta data table for this item; add it if necessary.
		
		if not seek(upper(toItem.Key), lcAlias, 'KEY')
			insert into (lcAlias) (KEY) values (toItem.Key)
		endif not seek(upper(toItem.Key) ...
		
		* Call any addins.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeSaveProjectItem', toItem)
			return This.oAddins.lSuccess
		endif vartype(This.oAddins) = 'O' ...
		
		* Save metadata settings if necessary.
		
		lcTags = toItem.GetTagString()
		select (lcAlias)
		if not TAGS == lcTags
			replace TAGS with lcTags
			llMetaDataChanged = .T.
		endif not TAGS == lcTags
		if FORECOLOR <> toItem.Forecolor
			replace FORECOLOR with toItem.Forecolor
			llMetaDataChanged = .T.
		endif FORECOLOR <> toItem.Forecolor
		select (lnSelect)
		if not tlMetaDataOnly
		
		* Save the properties.
		
			llReturn = toItem.SaveItem(This.oProject)
			do case
				case not llReturn
					This.cErrorMessage = toItem.cErrorMessage
		
		* If this item has MainFile changed to .T., set it to .F. for all other items.
		
				case toItem.MainFile and not toItem.OriginalMainFile
					for each loItem in This.oProjectItems foxobject
						if loItem.Key <> toItem.Key
							store .F. to loItem.MainFile, loItem.OriginalMainFile
						endif loItem.Key <> toItem.Key
					next loItem
			endcase
			toItem.OriginalMainFile = toItem.MainFile
		
		* Handle version control tasks.
		
			if llReturn and vartype(This.oVersionControl) = 'O'
				do case
		
		* For a field or index in a table in a database or a view, handle the database
		* because that's where Comment is written.
		
					case inlist(toItem.Type, FILETYPE_FIELD, FILETYPE_INDEX) and ;
						inlist(toItem.ParentType, FILETYPE_TABLE_IN_DBC, ;
						FILETYPE_REMOTE_VIEW, FILETYPE_LOCAL_VIEW)
						loItem = This.GetItemParent(toItem)
						loItem = This.GetItemParent(loItem)
						lcFile = loItem.Path
		
		* For a file, use the project.
		
					case toItem.IsFile
						lcFile = This.cProject
		
		* For anything else (class, connection, or view), handle the parent (the VCX or
		* DBC).
		
					otherwise
						loItem = This.GetItemParent(toItem)
						lcFile = loItem.Path
				endcase
		
		* Figure out which files to commit or generate text file for.
		
				lnFiles = 0
				if toItem.ChangesWritten
					lnFiles    = 1
					laFiles[1] = lcFile
				endif toItem.ChangesWritten
				if llMetaDataChanged
					lnFiles = lnFiles + 1
					dimension laFiles[lnFiles]
					laFiles[lnFiles] = This.cMetaDataTable
				endif llMetaDataChanged
		
		* For a table in a database, also handle the database because that's where
		* Comment is written.
		
				if toItem.Type = FILETYPE_TABLE_IN_DBC
					loItem = This.GetItemParent(toItem)
					lnFiles = lnFiles + 1
					dimension laFiles[lnFiles]
					laFiles[lnFiles] = loItem.Path
				endif toItem.Type = FILETYPE_TABLE_IN_DBC
				do case
		
		* If we're supposed to commit changes, do so.
		
					case This.oVersionControl.lAutoCommitChanges and ;
						not empty(tcMessage)
						This.oVersionControl.CommitFiles(tcMessage, @laFiles)
						This.OpenProject()
						This.OpenMetaData()
		
		* If we're not committing the changes, regenerate the text equivalents of VFP
		* binary files.
		
					case not This.oVersionControl.lAutoCommitChanges and ;
						This.oVersionControl.nIncludeInVersionControl > 1
						for lnI = 1 to lnFiles
							This.oVersionControl.ConvertBinaryToText(laFiles[lnI])
						next lnI
				endcase
			endif llReturn ...
		endif not tlMetaDataOnly
		
		* Call any addins.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterSaveProjectItem', toItem)
		endif vartype(This.oAddins) = 'O'
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE savesettings		&& Saves the settings for the project
		*==============================================================================
		* Method:			SaveSettings
		* Status:			Public
		* Purpose:			Saves the settings for the project
		* Author:			Doug Hennig
		* Last Revision:	05/11/2017
		* Parameters:		tcMessage - the commit message if we auto-commit changes
		* Returns:			.T.
		* Environment in:	This.oProjectSettings contains a reference to a
		*						ProjectSettings object
		*					This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		* Environment out:	project settings were saved
		*					the text equivalent of the PJX may have been regenerated
		*					the changes may have been auto-committed
		*==============================================================================
		
		lparameters tcMessage
		This.oProjectSettings.SaveSettings()
		do case
			case vartype(This.oVersionControl) <> 'O'
			case not This.oVersionControl.lAutoCommitChanges and ;
				This.oVersionControl.nIncludeInVersionControl > 1
				This.oVersionControl.ConvertBinaryToText(This.cProject)
			case This.oVersionControl.lAutoCommitChanges and not empty(tcMessage)
				This.oVersionControl.CommitFile(tcMessage, This.cProject)
				This.OpenProject()
		endcase
		
	ENDPROC

	PROCEDURE setproject		&& Specifies the project we're working with
		*==============================================================================
		* Method:			SetProject
		* Status:			Public
		* Purpose:			Specifies the project we're working with
		* Author:			Doug Hennig
		* Last revision:	04/25/2017
		* Parameters:		tuProject - the name and path for the PJX file or a
		*						reference to a project object
		* Returns:			.T. if a valid project name and path or project object was
		*						passed
		* Environment in:	none
		* Environment out:	if a name and path was specified and that project exists,
		*						it's opened
		*					This.cProject is set to the name and path for the PJX file,
		*						This.oProject is set to the project object, and
		*						This.cMetaDataTable is set to the name and path for the
		*						meta data table for the project
		*					This.oProjectSettings contains a ProjectSettings object
		*					This.oProjectItem contains ProjectItemFile object for the
		*						PJX
		*					see This.OpenProject
		*==============================================================================
		
		lparameters tuProject
		local lcType, ;
			lcProjectFile, ;
			lcProjectPath, ;
			loItem
		
		* Ensure a valid project was passed. If so, open it.
		
		lcType = vartype(tuProject)
		do case
			case lcType = 'O' and pemstatus(tuProject, 'Name', 5) and ;
				lower(justext(tuProject.Name)) = 'pjx' and file(tuProject.Name)
				This.oProject = tuProject
				This.cProject = tuProject.Name
			case lcType = 'C' and lower(justext(tuProject)) = 'pjx' and file(tuProject)
				This.cProject = tuProject
				if not This.OpenProject()
					return .F.
				endif not This.OpenProject()
			otherwise
				This.cErrorMessage = tuProject + ' does not exist.'
				return .F.
		endcase
		This.cErrorMessage = ''
		
		* Store the project path and name and path for its meta data table.
		
		lcProjectFile       = juststem(This.cProject)
		lcProjectPath       = addbs(justpath(This.cProject))
		This.cMetaDataTable = lcProjectPath + lcProjectFile + ccMETADATA_FILE
		
		* Create a ProjectSettings object.
		
		This.oProjectSettings = newobject('ProjectSettings', This.ClassLibrary, '', ;
			This.oProject, This.oAddins)
		
		* Create a ProjectItem object for the project itself.
		
		loItem = newobject('ProjectItemFile', ;
			fullpath('ProjectExplorerItems', This.ClassLibrary))
		store This.cProject to loItem.Path, loItem.Project
		loItem.Key           = justfname(This.cProject)
		loItem.TreeViewImage = 'project'
		loItem.Type          = ccHEADER_TYPE
		This.oProjectItem    = loItem
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerserver AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: description		&& The server description
		*p: instancing		&& The COM instancing setting
		*p: progid		&& The COM ProgID
		*p: serverclass		&& The server class
		*p: serverclasslibrary		&& The library containing the class specified in ServerClass
	*</DefinedPropArrayMethod>

	description = 		&& The server description
	instancing = 0		&& The COM instancing setting
	Name = "projectexplorerserver"
	progid = 		&& The COM ProgID
	serverclass = 		&& The server class
	serverclasslibrary = 		&& The library containing the class specified in ServerClass
	_memberdata = <VFPData>
		<memberdata name="description" display="Description"/>
		<memberdata name="instancing" display="Instancing"/>
		<memberdata name="serverclass" display="ServerClass"/>
		<memberdata name="serverclasslibrary" display="ServerClassLibrary"/>
		<memberdata name="progid" display="ProgID"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerServer
		* Based On:						ProjectExplorerCustom
		* Purpose:						Handle COM server settings
		* Author:						Doug Hennig
		* Last revision:				04/04/2017
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	none
		*
		* Changes in "Based On" class methods:
		*	About:						provides documentation for the class
		*	Init:						sets up the object
		*
		* Custom public properties added:
		*	Description:				The server description
		*	Instancing:					The COM instancing setting
		*	ProgID:						The COM ProgID
		*	ServerClass:				The server class
		*	ServerClassLibrary:			The library containing the class specified in
		*								ServerClass
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	none
		*
		* Custom protected methods added:
		*	none
		*==============================================================================
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Set up the object
		* Author:			Doug Hennig
		* Last revision:	04/04/2017
		* Parameters:		toServer - a reference to a project server object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the properties of this object were set to the properties of
		*						the server object
		*==============================================================================
		
		lparameters toServer
		This.Description        = toServer.Description
		This.HelpContextID      = toServer.HelpContextID
		This.Instancing         = toServer.Instancing
		This.ServerClass        = toServer.ServerClass
		This.ServerClassLibrary = toServer.ServerClassLibrary
		This.ProgID             = toServer.ProgID
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorersolution AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	*<DefinedPropArrayMethod>
		*m: addproject		&& Adds a project to the solution
		*m: addversioncontrol		&& Adds version control to the solution
		*m: cfileaddmessage_assign
		*m: cfileremovemessage_assign
		*m: cleanupsolution		&& Cleans up all projects in solution
		*m: closeprojects		&& Closes all projects
		*m: commitallfiles		&& Commits changes to all files
		*m: commitfile		&& Commits changes to the specified file
		*m: commititems		&& Commits changes to the specified items
		*m: getstatusforallfiles		&& Gets the version control status for all files in all projects
		*m: getstatusforfile		&& Gets the version control status for the specified file
		*m: lautocommitchanges_assign
		*m: lhaveversioncontrol_access
		*m: nincludeinversioncontrol_assign
		*m: openprojects		&& Opens all projects
		*m: opensolution		&& Opens the solution
		*m: removeproject		&& Removes a project from the solution
		*m: renameitem		&& Renames the specified item
		*m: revertfile		&& Reverts the specified file
		*m: savesolution		&& Saves the solution file
		*m: setupproject		&& Sets up the specified project
		*p: cbuildmessage		&& The commit message to use when the project is built
		*p: ccleanupmessage		&& The commit message to use when the solution is cleaned up
		*p: cfileaddmessage		&& The commit message to use for file additions
		*p: cfileremovemessage		&& The commit message to use for file removals
		*p: citemcursor		&& The name of a cursor of items and their keys
		*p: cprojectengineclass		&& The class used for project objects
		*p: cprojectenginelibrary		&& The library containing the class specified in cProjectEngineClass
		*p: crepositoryfolder		&& The folder where the repository is located
		*p: csavedsolutionmessage		&& The commit message to use when the solution file is saved
		*p: csolutionfile		&& The name and path for the current solution file
		*p: cversioncontrolclass		&& The class for the version control provider
		*p: cversioncontrollibrary		&& The library containing the class specified in cVersionControlClass
		*p: lautocommitchanges		&& .T. to auto-commit changes
		*p: lhaveversioncontrol		&& .T. if the solution uses version control
		*p: nincludeinversioncontrol		&& What to include in version control: 1 = VFP binaries only, 2 = text equivalents only, 3 = both
		*p: oaddins		&& A reference to a ProjectAddins object
		*p: oprojects		&& A collection of ProjectEngine objects for the projects in this solution
		*p: oversioncontrol		&& A reference to a VersionControlOperations object
	*</DefinedPropArrayMethod>

	PROTECTED oaddins
	cbuildmessage = Built the project: version {Project.VersionNumber}		&& The commit message to use when the project is built
	ccleanupmessage = Project cleanup		&& The commit message to use when the solution is cleaned up
	cfileaddmessage = File added to project		&& The commit message to use for file additions
	cfileremovemessage = File removed from project		&& The commit message to use for file removals
	citemcursor = 		&& The name of a cursor of items and their keys
	cprojectengineclass = ProjectEngine		&& The class used for project objects
	cprojectenginelibrary = ( This.ClassLibrary)		&& The library containing the class specified in cProjectEngineClass
	crepositoryfolder = 		&& The folder where the repository is located
	csavedsolutionmessage = Solution settings changed		&& The commit message to use when the solution file is saved
	csolutionfile = 		&& The name and path for the current solution file
	cversioncontrolclass = 		&& The class for the version control provider
	cversioncontrollibrary = 		&& The library containing the class specified in cVersionControlClass
	lautocommitchanges = .F.		&& .T. to auto-commit changes
	lhaveversioncontrol = .F.		&& .T. if the solution uses version control
	Name = "projectexplorersolution"
	nincludeinversioncontrol = 0		&& What to include in version control: 1 = VFP binaries only, 2 = text equivalents only, 3 = both
	oaddins = .NULL.		&& A reference to a ProjectAddins object
	oprojects = .NULL.		&& A collection of ProjectEngine objects for the projects in this solution
	oversioncontrol = .NULL.		&& A reference to a VersionControlOperations object
	_memberdata = <VFPData>
		<memberdata name="savesolution" display="SaveSolution"/>
		<memberdata name="oprojects" display="oProjects"/>
		<memberdata name="addproject" display="AddProject"/>
		<memberdata name="oaddins" display="oAddins"/>
		<memberdata name="removeproject" display="RemoveProject"/>
		<memberdata name="oversioncontrol" display="oVersionControl"/>
		<memberdata name="lhaveversioncontrol" display="lHaveVersionControl"/>
		<memberdata name="lhaveversioncontrol_access" display="lHaveVersionControl_Access"/>
		<memberdata name="getstatusforallfiles" display="GetStatusForAllFiles"/>
		<memberdata name="closeprojects" display="CloseProjects"/>
		<memberdata name="openprojects" display="OpenProjects"/>
		<memberdata name="opensolution" display="OpenSolution"/>
		<memberdata name="setupproject" display="SetupProject"/>
		<memberdata name="addversioncontrol" display="AddVersionControl"/>
		<memberdata name="csolutionfile" display="cSolutionFile"/>
		<memberdata name="cprojectengineclass" display="cProjectEngineClass"/>
		<memberdata name="cprojectenginelibrary" display="cProjectEngineLibrary"/>
		<memberdata name="getstatusforfile" display="GetStatusForFile"/>
		<memberdata name="revertfile" display="RevertFile"/>
		<memberdata name="commitfile" display="CommitFile"/>
		<memberdata name="commitallfiles" display="CommitAllFiles"/>
		<memberdata name="lautocommitchanges" display="lAutoCommitChanges"/>
		<memberdata name="cfileaddmessage" display="cFileAddMessage"/>
		<memberdata name="cfileremovemessage" display="cFileRemoveMessage"/>
		<memberdata name="nincludeinversioncontrol" display="nIncludeInVersionControl"/>
		<memberdata name="cversioncontrolclass" display="cVersionControlClass"/>
		<memberdata name="cversioncontrollibrary" display="cVersionControlLibrary"/>
		<memberdata name="cfileaddmessage_assign" display="cFileAddMessage_Assign"/>
		<memberdata name="cfileremovemessage_assign" display="cFileRemoveMessage_Assign"/>
		<memberdata name="lautocommitchanges_assign" display="lAutoCommitChanges_Assign"/>
		<memberdata name="nincludeinversioncontrol_assign" display="nIncludeInVersionControl_Assign"/>
		<memberdata name="ccleanupmessage" display="cCleanupMessage"/>
		<memberdata name="cleanupsolution" display="CleanupSolution"/>
		<memberdata name="csavedsolutionmessage" display="cSavedSolutionMessage"/>
		<memberdata name="cbuildmessage" display="cBuildMessage"/>
		<memberdata name="commititems" display="CommitItems"/>
		<memberdata name="renameitem" display="RenameItem"/>
		<memberdata name="citemcursor" display="cItemCursor"/>
		<memberdata name="crepositoryfolder" display="cRepositoryFolder"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerSolution
		* Based On:						ProjectExplorerCustom
		* Purpose:						Represents a solution (a collection of
		*								projects)
		* Author:						Doug Hennig
		* Last revision:				11/22/2017
		* Include file:					ProjectExplorer.h
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	About:						provides documentation for the class
		*	Init:						sets up the object
		*	ReleaseMembers:				nukes the oProject member
		*
		* Custom public properties added:
		*	cCleanupMessage:			The commit message to use when the solution is
		*									cleaned up
		*	cFileAddMessage:			The commit message to use for file additions
		*	cFileRemoveMessage:			The commit message to use for file removals
		*	cProjectEngineClass:		The class used for project objects
		*	cProjectEngineLibrary:		The library containing the class specified in
		*								cProjectEngineClass
		*	cSavedSolutionMessage:		The commit message to use when the solution
		*								file is saved
		*	cSolutionFile:				The name and path for the current solution file
		*	cVersionControlClass:		The class for the version control provider
		*	cVersionControlLibrary:		The library containing the class specified in
		*								cVersionControlClass
		*	lAutoCommitChanges:			.T. to auto-commit changes
		*	lHaveVersionControl:		.T. if the solution uses version control
		*	nIncludeInVersionControl:	What to include in version control:
		*									1 = VFP binaries only
		*									2 = text equivalents only
		*									3 = both
		*	oProjects:					A collection of ProjectEngine objects for the
		*								projects in this solution
		*	oVersionControl:			A reference to a VersionControlOperations
		*								object
		*
		* Custom protected properties added:
		*	cItemCursor:				The name of a cursor of items and their keys
		*	oAddins:					A reference to a ProjectAddins object
		*
		* Custom public methods added:
		*	AddProject:					Adds a project to the solution
		*	AddVersionControl:			Adds version control to the solution
		*	CleanupSolution:			Cleans up all projects in the solution
		*	CloseProjects:				Closes all projects
		*	CommitAllFiles:				Commits changes to all files in all projects
		*	CommitFile:					Commits changes to the specified file
		*	CommitItems:				Commits changes to the specified items
		*	GetStatusForAllFiles:		Gets the version control status for all files
		*								in all projects
		*	GetStatusForFile:			Gets the version control status for the
		*								specified file
		*	OpenProjects:				Opens all projects
		*	OpenSolution:				Opens the solution
		*	RemoveProject:				Removes a project from the solution
		*	RevertFile:					Reverts the specified file
		*	SaveSolution:				Saves the solution file
		*
		* Custom protected methods added:
		*	SetupProject:				Sets up the specified project
		*==============================================================================
		
	ENDPROC

	PROCEDURE addproject		&& Adds a project to the solution
		*==============================================================================
		* Method:			AddProject
		* Status:			Public
		* Purpose:			Adds a project to the solution
		* Author:			Doug Hennig
		* Last Revision:	05/08/2017
		* Parameters:		tcProject - the name and path of the project to add
		* Returns:			.T. if the project was added to the solution
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		*					see This.SetupProject()
		* Environment out:	This.cSolutionFile contains the name and path the solution
		*						file
		*					the project was added to the collection and to the
		*						solution file if it was successfully loaded
		*					the project and its file were added to version control if
		*						we're using version control
		*					see This.SetupProject()
		*==============================================================================
		
		lparameters tcProject
		
		* Ensure a project was specified.
		
		local llOK, ;
			loProject, ;
			loVersionControl, ;
			loItem, ;
			laProjects[1]
		This.cErrorMessage = ''
		if vartype(tcProject) <> 'C' or empty(tcProject) or ;
			lower(justext(tcProject)) <> 'pjx' or not file(tcProject)
			This.cErrorMessage = 'A valid project file was not specified.'
			return .F.
		endif vartype(tcProject) <> 'C' ...
		
		* Set the solution file.
		
		This.cSolutionFile = iif(empty(This.cSolutionFile), ;
			addbs(justpath(tcProject)) + ccSOLUTION_FILE, This.cSolutionFile)
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeAddProjectToSolution', This, ;
			tcProject)
			return This.oAddins.lSuccess
		endif vartype(This.oAddins) = 'O' ...
		
		* Add the project to the solution.
		
		llOK = This.SetupProject(tcProject)
		if llOK
		
		* If we have version control, add the project, its meta data table, and the
		* files in it to version control.
		
			if This.lHaveVersionControl
				loProject = This.oProjects.Item(tcProject)
				loProject.GetFilesFromProject()
				This.CloseProjects()
				loVersionControl = This.oVersionControl
				loVersionControl.AddFile(tcProject, .T.)
				loVersionControl.AddFile(loProject.cMetaDataTable, .T.)
				for each loItem in loProject.oProjectItems foxobject
					if loItem.IsFile
						loVersionControl.AddFile(loItem.Path, .T.)
					endif loItem.IsFile
				next loItem
		
		* If we're supposed to, commit the changes.
		
				if This.lAutoCommitChanges
					laProjects[1] = tcProject
					loVersionControl.CommitAllFiles(This.cFileAddMessage, ;
						@laProjects, .T.)
				endif This.lAutoCommitChanges
				This.OpenProjects()
			endif This.lHaveVersionControl
		
		* Save the solution and execute any addin.
		
			This.SaveSolution()
			if vartype(This.oAddins) = 'O'
				This.oAddins.ExecuteAddin('AfterAddProjectToSolution', This, tcProject)
			endif vartype(This.oAddins) = 'O'
		endif llOK
		return llOK
		
	ENDPROC

	PROCEDURE addversioncontrol		&& Adds version control to the solution
		*==============================================================================
		* Method:			AddVersionControl
		* Status:			Public
		* Purpose:			Adds version control to the solution
		* Author:			Doug Hennig
		* Last Revision:	05/04/2017
		* Parameters:		tcClass   - the class for the version control provider
		*					tcLibrary - the library containing the class
		*					tnIncludeInVersionControl - what to include in version
		*						control
		*					tlAutoCommit         - .T. to auto-commit changes
		*					tcFileAddMessage     - the commit message to use for file
		*						additions
		*					tcFileRemoveMessage  - the commit message to use for file
		*						removals
		*					tcCleanupMessage     - the commit message to use when the
		*						solution is cleaned up
		*					tcMessage            - the message to use when committing
		*						all the changes
		*					tcFoxBin2PRGLocation - the folder where FoxBin2PRG is
		*						located
		*					tcRepositoryFolder   - the folder where the repository is
		*						located
		*					tlCreateRepository   - .T. to create a repository
		* Returns:			.T. if it succeeded
		* Environment in:	This.oProjects contains a collection of projects (a
		*						reference to a ProjectEngineCollection object)
		* Environment out:	This.cVersionControlClass, This.cVersionControlLibrary,
		*						This.nIncludeInVersionControl, This.lAutoCommitChanges,
		*						This.cFileAddMessage, and This.cFileRemoveMessage
		*						contain the specified settings
		*					This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		*					the oVersionControl property of each project object
		*						contains the same instance as This.oVersionControl
		*					a repository was created and all files in all projects
		*						were added to it
		*==============================================================================
		
		lparameters tcClass, ;
			tcLibrary, ;
			tnIncludeInVersionControl, ;
			tlAutoCommit, ;
			tcFileAddMessage, ;
			tcFileRemoveMessage, ;
			tcCleanupMessage, ;
			tcMessage, ;
			tcFoxBin2PRGLocation, ;
			tcRepositoryFolder, ;
			tlCreateRepository
		local lcLibrary, ;
			loVersionControl, ;
			laProjects[1], ;
			lnI, ;
			loProject, ;
			lcProject, ;
			lcPath, ;
			loItem
		
		* Make sure we have at least one project.
		
		This.cErrorMessage = ''
		if This.oProjects.Count = 0
			This.cErrorMessage = 'There are no projects in this solution.'
			return .F.
		endif This.oProjects.Count = 0
		
		* Save the parameters and the solution settings.
		
		This.cVersionControlClass     = tcClass
		This.cVersionControlLibrary   = tcLibrary
		This.nIncludeInVersionControl = tnIncludeInVersionControl
		This.lAutoCommitChanges       = tlAutoCommit
		This.cFileAddMessage          = tcFileAddMessage
		This.cFileRemoveMessage       = tcFileRemoveMessage
		This.cCleanupMessage          = tcCleanupMessage
		This.cRepositoryFolder        = tcRepositoryFolder
		This.SaveSolution()
		
		* Create a version control object.
		
		lcLibrary = tcLibrary
		if not file(lcLibrary)
			lcLibrary = fullpath(lcLibrary, This.ClassLibrary)
		endif not file(lcLibrary)
		This.oVersionControl = newobject(tcClass, lcLibrary, '', ;
			tnIncludeInVersionControl, tlAutoCommit, tcFileAddMessage, ;
			tcFileRemoveMessage, This.oAddins, tcFoxBin2PRGLocation, ;
			tcRepositoryFolder)
		loVersionControl     = This.oVersionControl
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeAddVersionControl', This)
			return This.oAddins.lSuccess
		endif vartype(This.oAddins) = 'O' ...
		
		* Close all projects to prevent interference.
		
		This.CloseProjects()
		
		* Create a repository (if we're supposed to) and for each project, add the
		* project file and all files in it.
		
		dimension laProjects[This.oProjects.Count]
		for lnI = 1 to This.oProjects.Count
			loProject = This.oProjects.Item(lnI)
			laProjects[lnI] = loProject.cProject
			loProject.oVersionControl = loVersionControl
			lcProject = loProject.cProject
			lcPath    = justpath(lcProject)
			if lnI = 1
				if tlCreateRepository
					loVersionControl.CreateRepository(lcPath)
				endif tlCreateRepository
				loVersionControl.AddFile(This.cSolutionFile, .T.)
			endif lnI = 1
			if tlCreateRepository
				loVersionControl.AddFile(lcProject, .T.)
			endif tlCreateRepository
			loVersionControl.AddFile(loProject.cMetaDataTable, .T.)
			if tlCreateRepository
				for each loItem in loProject.oProjectItems foxobject
					if loItem.IsFile
						loVersionControl.AddFile(loItem.Path, .T.)
					endif loItem.IsFile
				next loItem
			endif tlCreateRepository
		next loProject
		
		* If we're supposed to, commit the changes.
		
		if tlAutoCommit
			loVersionControl.CommitAllFiles(tcMessage, @laProjects, .T.)
		endif tlAutoCommit
		
		* Reopen the projects.
		
		This.OpenProjects()
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterAddVersionControl', This)
		endif vartype(This.oAddins) = 'O'
		
	ENDPROC

	PROCEDURE cfileaddmessage_assign
		lparameters tcFileAddMessage
		This.cFileAddMessage = tcFileAddMessage
		if This.lHaveVersionControl
			This.oVersionControl.cFileAddMessage = tcFileAddMessage
		endif This.lHaveVersionControl
		
	ENDPROC

	PROCEDURE cfileremovemessage_assign
		lparameters tcFileRemoveMessage
		This.cFileRemoveMessage = tcFileRemoveMessage
		if This.lHaveVersionControl
			This.oVersionControl.cFileRemoveMessage = tcFileRemoveMessage
		endif This.lHaveVersionControl
		
	ENDPROC

	PROCEDURE cleanupsolution		&& Cleans up all projects in solution
		*==============================================================================
		* Method:			CleanupSolution
		* Status:			Public
		* Purpose:			Cleans up all projects in solution
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tlRemoveObjectCode - .T. to remove object code (see the
		*						VFP help for Cleanup for details)
		* Returns:			.T. if it succeeded
		* Environment in:	This.oProjects contains a collection of projects (a
		*						reference to a ProjectEngineCollection object)
		*					This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the projects were cleaned up and committed if
		*						This.lAutoCommitChanges is .T.
		*==============================================================================
		
		lparameters tlRemoveObjectCode
		local llReturn, ;
			loProject, ;
			loException
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeCleanupSolution', This, ;
			tlRemoveObjectCode)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* Cleanup the projects.
		
		llReturn = .T.
		for each loProject in This.oProjects foxobject
			llReturn = loProject.CleanupProject(tlRemoveObjectCode, ;
				This.cCleanupMessage)
			do case
				case not llReturn
					exit
				case This.lHaveVersionControl
					loProject.oProjectItem.VersionControlStatus = This.GetStatusForFile(loProject.cProject)
			endcase
		next loProject
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterCleanupSolution', This, tlRemoveObjectCode)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROCEDURE closeprojects		&& Closes all projects
		*==============================================================================
		* Method:			CloseProjects
		* Status:			Public
		* Purpose:			Closes all projects
		* Author:			Doug Hennig
		* Last Revision:	11/22/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.oProjects contains a collection of projects (a
		*						reference to a ProjectEngineCollection object)
		* Environment out:	all projects were closed if they weren't originally open
		*==============================================================================
		
		local loProject
		for each loProject in This.oProjects foxobject
			loProject.CloseProject(This.lRelease)
		next loProject
		
	ENDPROC

	PROCEDURE commitallfiles		&& Commits changes to all files
		*==============================================================================
		* Method:			CommitAllFiles
		* Status:			Public
		* Purpose:			Commits changes to all files in all projects
		* Author:			Doug Hennig
		* Last Revision:	05/05/2017
		* Parameters:		tcMessage - the commit message
		* Returns:			.T. if it succeeded
		* Environment in:	This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		*					This.oProjects contains a collection of projects (a
		*						reference to a ProjectEngineCollection object)
		* Environment out:	the file was committed
		*==============================================================================
		
		lparameters tcMessage
		local lnI, ;
			laProjects[1], ;
			llReturn
		
		* Ensure we have a message.
		
		if vartype(tcMessage) <> 'C' or empty(tcMessage)
			This.cErrorMessage = 'Invalid message specified.'
			return .F.
		endif vartype(tcFile) <> 'C' ...
		
		* Close all projects first because being open prevents us from committing.
		
		This.CloseProjects()
		
		* Commit all files.
		
		dimension laProjects[This.oProjects.Count]
		for lnI = 1 to This.oProjects.Count
			loProject = This.oProjects.Item(lnI)
			laProjects[lnI] = loProject.cProject
		next lnI
		llReturn = This.oVersionControl.CommitAllFiles(tcMessage, @laProjects)
		This.cErrorMessage = This.oVersionControl.cErrorMessage
		
		* Reopen the projects.
		
		This.OpenProjects()
		return llReturn
		
	ENDPROC

	PROCEDURE commitfile		&& Commits changes to the specified file
		*==============================================================================
		* Method:			CommitFile
		* Status:			Public
		* Purpose:			Commits changes to the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcMessage - the commit message
		*					tcFile    - the file to commit
		* Returns:			the file status if it succeeded
		* Environment in:	This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		* Environment out:	the file was committed
		*==============================================================================
		
		lparameters tcMessage, ;
			tcFile
		local lcStatus, ;
			lcExt, ;
			llClosed, ;
			llOK
		lcStatus = ''
		if This.lHaveVersionControl
		
		* Ensure we have a valid file.
		
			if vartype(tcFile) <> 'C' or empty(tcFile) or not file(tcFile)
				This.cErrorMessage = 'Invalid file specified.'
				return ''
			endif vartype(tcFile) <> 'C' ...
		
		* Ensure we have a message.
		
			if vartype(tcMessage) <> 'C' or empty(tcMessage)
				This.cErrorMessage = 'Invalid message specified.'
				return ''
			endif vartype(tcFile) <> 'C' ...
			This.cErrorMessage = ''
		
		* If this is a database container or a project, close all projects first because
		* they may be holding it open, which prevents us from committing.
		
			lcExt = lower(justext(tcFile))
			do case
				case lcExt = 'pjx'
					loProject = This.oProjects.Item(tcFile)
					loProject.CloseProject()
					llClosed = .T.
				case inlist(This.nIncludeInVersionControl, 1, 3) and lcExt = 'dbc'
					This.CloseProjects()
					llClosed = .T.
			endcase
		
		* Commit the file.
		
			llOK = This.oVersionControl.CommitFile(tcMessage, tcFile)
			if llOK
				lcStatus = This.oVersionControl.GetStatusForFile(tcFile)
			else
				lcStatus = ''
			endif llOK
		
		* Reopen the projects if we closed them.
		
			do case
				case not llClosed
				case lcExt = 'pjx'
					loProject.OpenProject()
				otherwise
					This.OpenProjects()
			endcase
		endif This.lHaveVersionControl
		return lcStatus
		
	ENDPROC

	PROCEDURE commititems		&& Commits changes to the specified items
		*==============================================================================
		* Method:			CommitItems
		* Status:			Public
		* Purpose:			Commits changes to the specified items
		* Author:			Doug Hennig
		* Last Revision:	09/15/2017
		* Parameters:		tcMessage - the commit message
		*					taItems   - an array of items or files to commit
		* Returns:			.T. if it succeeded
		* Environment in:	This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		* Environment out:	the files for the items were committed and the item
		*						status updated
		*==============================================================================
		
		lparameters tcMessage, ;
			taItems
		local lnFiles, ;
			lcError, ;
			lnI, ;
			loItem, ;
			lcType, ;
			lcFile, ;
			lcExt, ;
			llClosed, ;
			laFiles[1], ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taItems[1]
		endif .F.
		if This.lHaveVersionControl
		
		* Ensure we have a message.
		
			if vartype(tcMessage) <> 'C' or empty(tcMessage)
				This.cErrorMessage = 'Invalid message specified.'
				return .F.
			endif vartype(tcFile) <> 'C' ...
		
		* Ensure we have valid items.
		
			if type('taItems', 1) = 'A'
				lnFiles = 0
				lcError = ''
				for lnI = 1 to alen(taItems)
					loItem = taItems[lnI]
					lcType = vartype(loItem)
					do case
						case lcType = 'C'
							lcFile = loItem
						case lcType = 'O'
							lcFile = loItem.Path
					endcase
					if empty(lcFile)
						lcError = lcError + iif(empty(lcError), '', ccCRLF) + ;
							'Invalid item specified in element ' + transform(lnI)
					else
						lcExt = lower(justext(lcFile))
						do case
							case empty(lcFile) or not file(lcFile)
								lcError = lcError + iif(empty(lcError), '', ccCRLF) + ;
									'Invalid file specified in element ' + ;
									transform(lnI)
		
		* If this is a database container or a project, close all projects first because
		* they may be holding it open, which prevents us from committing.
		
							case (lcExt = 'pjx' or ;
								(inlist(This.nIncludeInVersionControl, 1, 3) and ;
								lcExt = 'dbc')) and not llClosed
								This.CloseProjects()
								llClosed = .T.
						endcase
		
		* Add this file to the list of files to commit.
		
						lnFiles = lnFiles + 1
						dimension laFiles[lnFiles]
						laFiles[lnFiles] = lcFile
					endif empty(lcFile)
				next loItem
				if not empty(lcError)
					This.cErrorMessage = lcError
					return .F.
				endif not empty(lcError)
			else
				This.cErrorMessage = 'Invalid items specified'
				return .F.
			endif type('taItems', 1) = 'A'
			This.cErrorMessage = ''
		
		* Do the commit.
		
			llReturn = This.oVersionControl.CommitFiles(tcMessage, @laFiles)
		
		* Get the status for each item.
		
			if llReturn 
				for each loItem in taItems foxobject
					if vartype(loItem) = 'O'
						lcFile = loItem.Path
						loItem.VersionControlStatus = This.oVersionControl.GetStatusForFile(lcFile)
					endif vartype(loItem) = 'O'
				next loItem
			endif llReturn 
		
		* Reopen the projects if we closed them.
		
			if llClosed
				This.OpenProjects()
			endif llClosed
		endif This.lHaveVersionControl
		return llReturn
		
	ENDPROC

	PROCEDURE getstatusforallfiles		&& Gets the version control status for all files in all projects
		*==============================================================================
		* Method:			GetStatusForAllFiles
		* Status:			Public
		* Purpose:			Gets the version control status for all files in all
		*						projects
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		*					This.oProjects contains a collection of projects (a
		*						reference to a ProjectEngineCollection object)
		* Environment out:	the version control status for all files in all projects
		*						has been set
		*==============================================================================
		
		if This.lHaveVersionControl
		
		* Close all projects first because being open prevents us from getting the
		* status.
		
			This.CloseProjects()
		
		* Get the status for all files in all projects and for the projects themselves.
		
			for each loProject in This.oProjects foxobject
				This.oVersionControl.GetStatusForAllFiles(loProject.oProjectItems)
				loProject.oProjectItem.VersionControlStatus = This.oVersionControl.GetStatusForFile(loProject.oProjectItem.Path)
			next loProject
		
		* Reopen the projects.
		
			This.OpenProjects()
		endif This.lHaveVersionControl
		
	ENDPROC

	PROCEDURE getstatusforfile		&& Gets the version control status for the specified file
		*==============================================================================
		* Method:			GetStatusForFile
		* Status:			Public
		* Purpose:			Gets the version control status for the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the file to get the status for
		* Returns:			the file status if it succeeded
		* Environment in:	This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		* Environment out:	none
		*==============================================================================
		
		lparameters tcFile
		local lcStatus, ;
			lcExt, ;
			llClosed
		lcStatus = ''
		if This.lHaveVersionControl
		
		* Ensure we have a valid filename.
		
			if vartype(tcFile) <> 'C' or empty(tcFile) or not file(tcFile)
				This.cErrorMessage = 'Invalid file specified'
				return ''
			endif vartype(tcFile) <> 'C' ...
			This.cErrorMessage = ''
		
		* If this is a database container or a project, close all projects first because
		* they may be holding it open, which prevents us from getting the status.
		
			lcExt = lower(justext(tcFile))
			if inlist(This.nIncludeInVersionControl, 1, 3) and ;
				inlist(lcExt, 'dbc', 'pjx')
				This.CloseProjects()
				llClosed = .T.
			endif inlist(This.nIncludeInVersionControl ...
		
		* Get the status.
		
			lcStatus = This.oVersionControl.GetStatusForFile(tcFile)
		
		* Reopen the projects if we closed them.
		
			if llClosed
				This.OpenProjects()
			endif llClosed
		endif This.lHaveVersionControl
		return lcStatus
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Set up the project engine
		* Author:			Doug Hennig
		* Last revision:	02/27/2017
		* Parameters:		toAddins - a reference to a ProjectAddins object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.oAddins contains toAddins
		*					This.oProjects contains a reference to a
		*						ProjectExplorerCollection object
		*==============================================================================
		
		lparameters toAddins
		local lnSelect
		
		* Save the passed parameters.
		
		This.oAddins = toAddins
		
		* Create a collection of ProjectEngine objects.
		
		This.oProjects = newobject('ProjectExplorerCollection', ;
			fullpath('ProjectExplorerCtrls.vcx', This.ClassLibrary))
		
		* Create a cursor of items and their keys.
		
		lnSelect = select()
		This.cItemCursor = sys(2015)
		create cursor (This.cItemCursor) (NAME C(240), KEY C(10))
		index on upper(NAME) tag NAME
		index on KEY         tag KEY
		select (lnSelect)
		
	ENDPROC

	PROCEDURE lautocommitchanges_assign
		lparameters tlAutoCommitChanges
		This.lAutoCommitChanges = tlAutoCommitChanges
		if This.lHaveVersionControl
			This.oVersionControl.lAutoCommitChanges = tlAutoCommitChanges
		endif This.lHaveVersionControl
		
	ENDPROC

	PROCEDURE lhaveversioncontrol_access
		return vartype(This.oVersionControl) = 'O'
		
	ENDPROC

	PROCEDURE nincludeinversioncontrol_assign
		lparameters tnIncludeInVersionControl
		This.nIncludeInVersionControl = tnIncludeInVersionControl
		if This.lHaveVersionControl
			This.oVersionControl.nIncludeInVersionControl = tnIncludeInVersionControl
		endif This.lHaveVersionControl
		
	ENDPROC

	PROCEDURE openprojects		&& Opens all projects
		*==============================================================================
		* Method:			OpenProjects
		* Status:			Public
		* Purpose:			Opens all projects
		* Author:			Doug Hennig
		* Last Revision:	02/25/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.oProjects contains a collection of projects (a
		*						reference to a ProjectEngineCollection object)
		* Environment out:	all projects were opened
		*==============================================================================
		
		local loProject
		for each loProject in This.oProjects foxobject
			loProject.OpenProject()
		next loProject
		
	ENDPROC

	PROCEDURE opensolution		&& Opens the solution
		*==============================================================================
		* Method:			OpenSolution
		* Status:			Public
		* Purpose:			Opens the solution
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFolder - the folder containing the solution to open
		* Returns:			.T. if all projects were opened
		* Environment in:	see This.SetupProject()
		* Environment out:	This.cSolutionFile contains the name and path the solution
		*						file
		*					the projects specified in This.cSolutionFile were opened
		*					This.cVersionControlClass, This.cVersionControlLibrary, and
		*						This.nIncludeInVersionControl contain the settings from
		*						the solution file
		*					if version control settings are specified,
		*						This.oVersionControl contains a reference to the class
		*						specified in This.cVersionControlClass
		*					This.oAddins contains a reference to a ProjectAddins object
		*					see This.SetupProject()
		*==============================================================================
		
		lparameters tcFolder
		local lcSolution, ;
			lcProjects, ;
			lnI, ;
			lcProject, ;
			llOK, ;
			loProject, ;
			lcSettings, ;
			lcRepositoryFolder, ;
			lcLibrary
		
		* Ensure a valid folder was passed.
		
		This.cErrorMessage = ''
		if vartype(tcFolder) <> 'C' or empty(tcFolder) or not directory(tcFolder)
			This.cErrorMessage = 'A valid folder was not specified.'
			return .F.
		endif vartype(tcProject) <> 'C' ...
		
		* Open the solution file.
		
		This.cSolutionFile = addbs(tcFolder) + ccSOLUTION_FILE
		if not file(This.cSolutionFile)
			This.cErrorMessage = 'That folder does not contain a solution file.'
			return .F.
		endif not file(This.cSolutionFile)
		lcSolution = filetostr(This.cSolutionFile)
		if left(lcSolution, 10) <> '<solution>'
			This.cErrorMessage = 'The solution file in that folder does not appear to be valid.'
			return .F.
		endif left(lcSolution, 10) <> '<solution>'
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeOpenSolution', This, tcFolder)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* Get the version control settings.
		
		lcSettings = strextract(lcSolution, '<versioncontrol ', '/>')
		This.cVersionControlClass     = strextract(lcSettings, 'class="', '"')
		This.cVersionControlLibrary   = strextract(lcSettings, 'library="', '"')
		This.nIncludeInVersionControl = val(strextract(lcSettings, ;
			'includeinversioncontrol="', '"'))
		This.lAutoCommitChanges       = strextract(lcSettings, 'autocommit="', '"') = 'true'
		This.cFileAddMessage          = evl(strextract(lcSettings, 'fileaddmessage="', '"'), ;
			This.cFileAddMessage)
		This.cFileRemoveMessage       = evl(strextract(lcSettings, 'fileremovemessage="', '"'), ;
			This.cFileRemoveMessage)
		This.cCleanupMessage          = evl(strextract(lcSettings, 'cleanupmessage="', '"'), ;
			This.cCleanupMessage)
		This.cSavedSolutionMessage    = evl(strextract(lcSettings, 'savedsolutionmessage="', '"'), ;
			This.cSavedSolutionMessage)
		This.cBuildMessage            = evl(strextract(lcSettings, 'buildmessage="', '"'), ;
			This.cBuildMessage)
		lcRepositoryFolder            = evl(strextract(lcSettings, 'repository="', '"'), ;
			tcFolder)
		if not empty(This.cVersionControlClass)
			lcLibrary = This.cVersionControlLibrary
			if not file(lcLibrary)
				lcLibrary = fullpath(lcLibrary, This.ClassLibrary)
			endif not file(lcLibrary)
			This.oVersionControl = newobject(This.cVersionControlClass, ;
				lcLibrary, '', This.nIncludeInVersionControl, ;
				This.lAutoCommitChanges, This.cFileAddMessage, ;
				This.cFileRemoveMessage, This.oAddins, '', lcRepositoryFolder)
		endif not empty(This.cVersionControlClass)
		
		* Get the projects.
		
		lcProjects = strextract(lcSolution, '<projects>', '</projects>')
		for lnI = 1 to occurs('<project ', lcProjects)
			lcProject = fullpath(strextract(lcProjects, 'name="', '"', lnI), ;
				This.cSolutionFile)
			llOK      = This.SetupProject(lcProject)
			if llOK
				loProject = This.oProjects.Item(lcProject)
				loProject.oProjectSettings.BuildAction = val(strextract(lcProjects, ;
					'buildaction="', '"', lnI))
				loProject.oProjectSettings.Recompile = strextract(lcProjects, ;
					'recompile="', '"', lnI) = 'true'
				loProject.oProjectSettings.DisplayErrors = strextract(lcProjects, ;
					'displayerrors="', '"', lnI) = 'true'
				loProject.oProjectSettings.RegenerateGUIDs = strextract(lcProjects, ;
					'regenerate="', '"', lnI) = 'true'
				loProject.oProjectSettings.RunAfterBuild = strextract(lcProjects, ;
					'runafterbuild="', '"', lnI) = 'true'
				loProject.oProjectSettings.OutputFile = strextract(lcProjects, ;
					'outputfile="', '"', lnI)
			else
				exit
			endif llOK
		next lnI
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterOpenSolution', This, tcFolder)
		endif vartype(This.oAddins) = 'O'
		return llOK
		
	ENDPROC

	PROCEDURE releasemembers
		* Release all objects we're using.
		
		This.CloseProjects()
		if vartype(This.oProjects) = 'O'
			This.oProjects.Release()
		endif vartype(This.oProjects) = 'O'
		if vartype(This.oVersionControl) = 'O'
			This.oVersionControl.Release()
		endif vartype(This.oVersionControl) = 'O'
		This.oAddIns = .NULL.
		
	ENDPROC

	PROCEDURE removeproject		&& Removes a project from the solution
		*==============================================================================
		* Method:			RemoveProject
		* Status:			Public
		* Purpose:			Removes a project from the solution
		* Author:			Doug Hennig
		* Last Revision:	03/05/2017
		* Parameters:		tcProject - the name and path of the project to add
		* Returns:			.T. if the project was removed
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		*					This.oProjects contains a collection of projects (a
		*						reference to a ProjectEngineCollection object)
		* Environment out:	the project was removed from the collection and the
		*						solution file
		*==============================================================================
		
		lparameters tcProject
		
		* Ensure a project was specified.
		
		This.cErrorMessage = ''
		if vartype(tcProject) <> 'C' or empty(tcProject) or ;
			lower(justext(tcProject)) <> 'pjx' or not file(tcProject)
			This.cErrorMessage = 'A valid project file was not specified.'
			return .F.
		endif vartype(tcProject) <> 'C' ...
		if vartype(This.oProjects.Item(tcProject)) <> 'O'
			This.cErrorMessage = 'That project is not in the solution.'
			return .F.
		endif vartype(This.oProjects.Item(tcProject)) <> 'O'
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeRemoveProjectFromSolution', This, ;
			tcProject)
			return This.oAddins.lSuccess
		endif vartype(This.oAddins) = 'O' ...
		
		* Remove the project from the collection and save the solution file.
		
		This.oProjects.Remove(tcProject)
		This.SaveSolution()
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterRemoveProjectFromSolution', This, ;
				tcProject)
		endif vartype(This.oAddins) = 'O'
		return .T.
		
	ENDPROC

	PROCEDURE renameitem		&& Renames the specified item
		*==============================================================================
		* Method:			RenameItem
		* Status:			Public
		* Purpose:			Renames the specified item
		* Author:			Doug Hennig
		* Last Revision:	06/09/2017
		* Parameters:		toItem    - a reference to a ProjectItem object for the
		*						item
		*					tcNewName - the new name for the item (the stem part only
		*						in the case of a file)
		*					tcMessage - the auto-commit message to use
		* Returns:			.T. if it succeeded
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the file may have been renamed and version control told
		*						about it
		*					the change may have been committed if we're supposed to
		*						auto-commit
		*==============================================================================
		
		lparameters toItem, ;
			tcNewName, ;
			tcMessage
		local lcPath, ;
			lcKey, ;
			loProject, ;
			llReturn, ;
			lnSelect, ;
			loItem, ;
			loProjectItem, ;
			lnI, ;
			lcCursorKey, ;
			laProjects[1], ;
			lcFile
		
		* Ensure we have a valid item.
		
		if vartype(toItem) <> 'O'
			This.cErrorMessage = 'Invalid item specified.'
			return .F.
		endif vartype(toItem) <> 'O'
		
		* Ensure a name was passed.
		
		if vartype(tcNewName) <> 'C' or empty(tcNewName)
			This.cErrorMessage = 'Invalid name specified.'
			return .F.
		endif vartype(tcNewName) <> 'C' ...
		
		* Ensure the new name is valid.
		
		if not toItem.IsNameValid(tcNewName)
			This.cErrorMessage = 'There is already a ' + toItem.TypeName + ;
				' named ' + tcNewName + '.'
			return .F.
		endif not toItem.IsNameValid(tcNewName)
		This.cErrorMessage = ''
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeRenameItem', toItem, tcNewName)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* If we're renaming a database or a table, close it first.
		
		lcPath = toItem.Path
		lcKey  = toItem.Key
		if inlist(toItem.Type, FILETYPE_DATABASE, FILETYPE_FREETABLE)
			CloseFile(lcPath)
		endif inlist(toItem.Type ...
		
		* Rename the item. Close and reopen the project so it sees the new name.
		
		loProject = This.oProjects.Item(toItem.Project)
		llReturn  = toItem.RenameItem(loProject.oProject, tcNewName)
		loProject.CloseProject()
		loProject.OpenProject()
		if llReturn
		
		* Go through all projects (in case this item is in more than one) and handle
		* other renaming tasks.
		
			lnSelect = select()
			for each loProject in This.oProjects foxobject
		
		* If the renamed file exists in another project, rename it in that project too.
		
				if loProject.cProject <> toItem.Project
					for each loItem in loProject.oProjectItems foxobject
						if loItem.Path == lcPath
							loItem.RenameItem(loProject.oProject, tcNewName)
							loProject.CloseProject()
							loProject.OpenProject()
							exit
						endif loItem.Path == lcPath
					next loItem
				endif loProject.cProject <> toItem.Project
				do case
		
		* For objects that contain other objects (such as a VCX), fix the Path and
		* ParentPath for any child objects.
		
					case toItem.HasChildren and not toItem.HasParent
						for each loItem in loProject.oProjectItems foxobject
							if loItem.Path == lcPath
								loItem.Path = toItem.Path
							endif loItem.Path == lcPath
							if loItem.ParentPath == lcPath
								&& only the case for databases
								loItem.ParentPath = toItem.Path
							endif loItem.ParentPath == lcPath
						next loItem
		
		* For items in a database, the item name is part of the key, so we have to
		* change the key for child items and meta data records (toItem.Key was changed
		* in the call to RenameItem). Note that because we change the key, we have to
		* remove the item from the collection and re-add it.
		
					case inlist(toItem.Type, FILETYPE_REMOTE_VIEW, FILETYPE_LOCAL_VIEW, ;
						FILETYPE_CONNECTION, FILETYPE_TABLE_IN_DBC)
						loProjectItem = loProject.oProjectItems.Item(lcKey)
						if vartype(loProjectItem) = 'O'
							loProject.oProjectItems.Remove(lcKey)
							loProjectItem.Key      = toItem.Key
							loProjectItem.ItemName = toItem.ItemName
							loProject.oProjectItems.Add(loProjectItem, ;
								loProjectItem.Key)
						endif vartype(loProjectItem) = 'O'
						if toItem.HasChildren
							for lnI = loProject.oProjectItems.Count to 1 step -1
								loItem = loProject.oProjectItems.Item(lnI)
								if loItem.ParentKey == lcKey
									loItem.Key       = strtran(loItem.Key, lcKey, ;
										toItem.Key)
									loItem.ParentKey = toItem.Key
									loItem.Path      = toItem.Path
									loProject.oProjectItems.Remove(lnI)
									loProject.oProjectItems.Add(loItem, loItem.Key)
								endif loItem.ParentKey == lcKey
							next lnI
						endif toItem.HasChildren
						select (loProject.cMetaDataAlias)
						lcCursorKey = padr(lcKey, len(KEY))
						scan for KEY = lcCursorKey or lcKey + '.' $ KEY
							replace KEY with strtran(KEY, lcKey, toItem.Key)
						endscan for KEY = lcCursorKey ...
				endcase
			next loProject
		
		* Update the item cursor.
		
			if toItem.IsFile and seek(upper(lcPath), This.cItemCursor, 'NAME')
				replace NAME with lower(toItem.Path) in (This.cItemCursor)
			endif toItem.IsFile ...
			select (lnSelect)
		
		* If we're using version control, tell it about the rename.
		
			if This.lHaveVersionControl
				This.oVersionControl.RenameFile(lcPath, tcNewName, '', .T.)
				do case
		
		* If we're supposed to auto-commit changes, the version control RenameFile
		* already took care of that.
		
					case This.lAutoCommitChanges
		
		* If we're not auto-committing changes, regenerate the text for the projects
		* and the renamed item or its parent if necessary.
		
					case This.nIncludeInVersionControl > 1
						if toItem.IsFile
							for each loProject in This.oProjects foxobject
								This.oVersionControl.ConvertBinaryToText(loProject.cProject)
							next loProject
						endif toItem.IsFile
						lcFile = evl(toItem.ParentPath, toItem.Path)
						if IsVFPBinaryFile(lcFile)
							This.oVersionControl.ConvertBinaryToText(lcFile)
						endif IsVFPBinaryFile(lcFile)
						if toItem.Type = FILETYPE_TABLE_IN_DBC
							This.oVersionControl.ConvertBinaryToText(toItem.Path)
						endif toItem.Type = FILETYPE_TABLE_IN_DBC
				endcase
			endif This.lHaveVersionControl
		
		* Execute any addin.
		
			if vartype(This.oAddins) = 'O'
				This.oAddins.ExecuteAddin('AfterRenameItem', toItem, tcNewName)
			endif vartype(This.oAddins) = 'O'
		else
			This.cErrorMessage = toItem.cErrorMessage
		endif llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE revertfile		&& Reverts the specified file
		*==============================================================================
		* Method:			RevertFile
		* Status:			Public
		* Purpose:			Reverts the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the file to get the status for
		* Returns:			the file status if it succeeded
		* Environment in:	This.oVersionControl contains a reference to a
		*						VersionControlOperations object
		* Environment out:	the file was reverted
		*==============================================================================
		
		lparameters tcFile
		local lcStatus, ;
			lcExt, ;
			llClosed, ;
			llOK
		lcStatus = ''
		if This.lHaveVersionControl
		
		* Ensure we have a valid file.
		
			if vartype(tcFile) <> 'C' or empty(tcFile) or not file(tcFile)
				This.cErrorMessage = 'Invalid file specified.'
				return ''
			endif vartype(tcFile) <> 'C' ...
			This.cErrorMessage = ''
		
		* If this is a database container or a project, close all projects first because
		* they may be holding it open, which prevents us from reverting.
		
			lcExt = lower(justext(tcFile))
			do case
				case lcExt = 'pjx'
					loProject = This.oProjects.Item(tcFile)
					loProject.CloseProject()
					llClosed = .T.
				case inlist(This.nIncludeInVersionControl, 1, 3) and lcExt = 'dbc'
					This.CloseProjects()
					llClosed = .T.
			endcase
		
		* Revert the file.
		
			llOK = This.oVersionControl.RevertFile(tcFile)
			if llOK
				lcStatus = This.oVersionControl.GetStatusForFile(tcFile)
			else
				lcStatus = ''
			endif llOK
		
		* Reopen the projects if we closed them.
		
			do case
				case not llClosed
				case lcExt = 'pjx'
					loProject.OpenProject()
				otherwise
					This.OpenProjects()
			endcase
		endif This.lHaveVersionControl
		return lcStatus
		
	ENDPROC

	PROCEDURE savesolution		&& Saves the solution file
		*==============================================================================
		* Method:			SaveSolution
		* Status:			Public
		* Purpose:			Saves the solution file
		* Author:			Doug Hennig
		* Last Revision:	09/15/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.cSolutionFile contains the name and path the solution
		*						file
		*					This.oProjects contains a collection of projects (a
		*						reference to a ProjectEngineCollection object)
		*					This.cVersionControlClass, This.cVersionControlLibrary,
		*						This.nIncludeInVersionControl, This.lAutoCommitChanges,
		*						This.cRepositoryFolder,  and several *Message
		*						properties contain the version control settings for the
		*						solution
		*					This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	The file specified in This.cSolutionFile was written to
		*==============================================================================
		
		local lcXML, ;
			loProject
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeSaveSolution', This)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* Save the solution file.
		
		lcXML = '<solution>' + ccCRLF + ccTAB + '<projects>' + ccCRLF
		for each loProject in This.oProjects foxobject
			loSettings = loProject.oProjectSettings
			lcXML = lcXML + ccTAB + ccTAB + '<project name="' + ;
				lower(justfname(loProject.cProject)) + '"' + ;
				' buildaction="' + transform(loSettings.BuildAction) + '"' + ;
				' recompile="' + iif(loSettings.Recompile, 'true', 'false') + '"' + ;
				' displayerrors="' + iif(loSettings.DisplayErrors, 'true', 'false') + '"' + ;
				' regenerate="' + iif(loSettings.RegenerateGUIDs, 'true', 'false') + '"' + ;
				' runafterbuild="' + iif(loSettings.RunAfterBuild, 'true', 'false') + '"' + ;
				' outputfile="' + loSettings.OutputFile + '" />' + ccCRLF
		next loProject
		lcXML = lcXML + ccTAB + '</projects>' + ccCRLF + ccTAB + ;
			'<versioncontrol class="' + This.cVersionControlClass + '"' + ;
			' library="' + This.cVersionControlLibrary + '"' + ;
			' repository="' + This.cRepositoryFolder + '"' + ;
			' includeinversioncontrol="' + transform(This.nIncludeInVersionControl) + '"' + ;
			' autocommit="' + iif(This.lAutoCommitChanges, 'true', 'false') + '"' + ;
			' fileaddmessage="' + This.cFileAddMessage + '"' + ;
			' fileremovemessage="' + This.cFileRemoveMessage + '"' + ;
			' cleanupmessage="' + This.cCleanupMessage + '"' + ;
			' savedsolutionmessage="' + This.cSavedSolutionMessage + '"' + ;
			' buildmessage="' + This.cBuildMessage + '"' + ;
			' />' + ccCRLF + '</solution>'
		strtofile(lcXML, This.cSolutionFile)
		
		* Commit the changes to the solution file if we're supposed to.
		
		if This.lAutoCommitChanges
			This.CommitFile(This.cSavedSolutionMessage, This.cSolutionFile)
		endif This.lAutoCommitChanges
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterSaveSolution', This)
		endif vartype(This.oAddins) = 'O'
		
	ENDPROC

	PROTECTED PROCEDURE setupproject		&& Sets up the specified project
		*==============================================================================
		* Method:			SetupProject
		* Status:			Protected
		* Purpose:			Sets up the specified project
		* Author:			Doug Hennig
		* Last Revision:	04/20/2017
		* Parameters:		tcProject - the name and path of the project to set up
		* Returns:			.T. if the project was set up
		* Environment in:	This.oProjects contains a collection of projects (a
		*						reference to a ProjectEngineCollection object)
		*					This.oAddins contains a reference to a ProjectAddins object
		*					This.cItemCursor contains the name of the item cursor
		* Environment out:	the project was added to the collection if it was
		*						successfully loaded
		*					if there was a problem in the project's SetProject method,
		*						This.cErrorMessage contains the error message
		*==============================================================================
		
		lparameters tcProject
		local loProject, ;
			llOK
		This.cErrorMessage = ''
		loProject = newobject(This.cProjectEngineClass, This.cProjectEngineLibrary, ;
			'', This.oAddins, This.cItemCursor)
		llOK      = loProject.SetProject(tcProject)
		if llOK
			loProject.oVersionControl = This.oVersionControl
			This.oProjects.Add(loProject, tcProject)
		else
			This.cErrorMessage = loProject.cErrorMessage
		endif llOK
		return llOK
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectoperations AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	*<DefinedPropArrayMethod>
		*m: additem		&& Adds an item to the project
		*m: buildproject		&& Builds the project
		*m: edititem		&& Edits the specified item
		*m: newitem		&& Creates a new item
		*m: removeitem		&& Removes the item from the project
		*m: runitem		&& Runs the specified item
		*p: nerrorcode		&& The error number
		*p: oaddins		&& A reference to a ProjectAddins object
	*</DefinedPropArrayMethod>

	PROTECTED oaddins
	Name = "projectoperations"
	nerrorcode = 0		&& The error number
	oaddins = .NULL.		&& A reference to a ProjectAddins object
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="edititem" type="method" display="EditItem"/>
		<memberdata name="runitem" type="method" display="RunItem"/>
		<memberdata name="oaddins" display="oAddins"/>
		<memberdata name="buildproject" display="BuildProject"/>
		<memberdata name="nerrorcode" display="nErrorCode"/>
		<memberdata name="removeitem" display="RemoveItem"/>
		<memberdata name="additem" display="AddItem"/>
		<memberdata name="newitem" display="NewItem"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectOperations
		* Based On:						ProjectExplorerCustom
		* Purpose:						Provides project operations
		* Author:						Doug Hennig
		* Last revision:				04/27/2017
		* Include file:					ProjectExplorer.h
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	About:						provides documentation for the class
		*	Init:						sets up the object
		*	ReleaseMembers:				nukes the oProject member
		*
		* Custom public properties added:
		*	nErrorCode:					The error number
		*
		* Custom protected properties added:
		*	oAddins:					A reference to a ProjectAddins object
		*
		* Custom public methods added:
		*	AddItem:					Adds an item to the project
		*	BuildProject:				Builds the project
		*	EditItem:					Edits the specified item
		*	NewItem:					Creates a new item
		*	RemoveItem:					Removes the item from the project
		*	RunItem:					Runs the specified item
		*
		* Custom protected methods added:
		*	none
		*==============================================================================
		
	ENDPROC

	PROCEDURE additem		&& Adds an item to the project
		*==============================================================================
		* Method:			AddItem
		* Status:			Public
		* Purpose:			Adds an item to the project
		* Author:			Doug Hennig
		* Last Revision:	04/25/2017
		* Parameters:		toProject - a reference to the project object
		*					tcFile    - the name and path of the file to add
		*					tcType    - the type for the file
		* Returns:			a reference to the newly added file or NULL if something
		*						failed
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	a file was added to the project
		*==============================================================================
		
		lparameters toProject, ;
			tcFile, ;
			tcType
		local loFile
		
		* Ensure a project is passed.
		
		if vartype(toProject) <> 'O'
			This.cErrorMessage = 'Invalid project specified.'
			return .NULL.
		endif vartype(toProject) <> 'O'
		
		* Ensure we have a valid file.
		
		if vartype(tcFile) <> 'C' or empty(tcFile) or not file(tcFile)
			This.cErrorMessage = 'Invalid file specified.'
			return .NULL.
		endif vartype(tcFile) <> 'C' ...
		
		* Ensure we have a valid type.
		
		if pcount() = 3 and (vartype(tcType) <> 'C' or (not empty(tcType) and ;
			not inlist(tcType, FILETYPE_DATABASE, FILETYPE_FREETABLE, FILETYPE_QUERY, ;
			FILETYPE_FORM, FILETYPE_REPORT, FILETYPE_LABEL, FILETYPE_CLASSLIB, ;
			FILETYPE_PROGRAM, FILETYPE_APILIB, FILETYPE_APPLICATION, FILETYPE_MENU, ;
			FILETYPE_TEXT, FILETYPE_OTHER)))
			This.cErrorMessage = 'Invalid type specified.'
			return .NULL.
		endif pcount() = 3 ...
		
		* Execute any addin.
		
		This.cErrorMessage = ''
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeAddItem', toProject, tcFile)
			return .NULL.
		endif vartype(This.oAddins) = 'O' ...
		
		* Add the file to the project (if it's already there, we simply get a reference
		* to the existing file).
		
		loFile = toProject.Files.Add(tcFile)
		
		* Ensure the type for the item matches the expected type. This is mostly to
		* handle a bug in the Project Manager: Files.Add for an EXE adds it as "x"
		* (Other) so we'll force it to be "Z" (Application).
		
		if not empty(tcType) and loFile.Type <> tcType
			loFile.Type = tcType
		endif not empty(tcType) ...
		
		* Handle another bug in the Project Manager: a VCX is set to the main file when
		* added if there is no main file for the project (this is a throwback to the
		* days when ActiveDoc was supported). Note that we have to hack the PJX file;
		* calling toProject.SetMain('') works but doesn't clear toProject.MainFile
		* until close and reopen the project.
		
		if toProject.MainFile = loFile.Name and loFile.Type = FILETYPE_CLASSLIB
			lnSelect = select()
			try
				select 0
				use (toProject.Name) again shared
				locate for fullpath(NAME, toProject.Name) = upper(loFile.Name)
				replace MAINPROG with .F.
				use
			catch
			endtry
			select (lnSelect)
		endif toProject.MainFile = loFile.Name ...
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterAddItem', toProject, tcFile)
		endif vartype(This.oAddins) = 'O'
		return loFile
		
	ENDPROC

	PROCEDURE buildproject		&& Builds the project
		*==============================================================================
		* Method:			BuildProject
		* Status:			Public
		* Purpose:			Builds the project
		* Author:			Doug Hennig
		* Last Revision:	07/24/2017
		* Parameters:		toProject       - a reference to the project object
		*					tcOutputName    - the name of the file to create
		*					tnBuildAction   - the build action to use
		*					tlRebuildAll    - .T. to recompile all files
		*					tlShowErrors    - .T. to display errors
		*					tlBuildNewGUIDs - .T. to regenerate component IDs
		* Returns:			.T. if the project built successfully
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the project may have been built
		*					if there was a problem building the project, cErrorMessage
		*						contains the error message
		*==============================================================================
		
		lparameters toProject, ;
			tcOutputName, ;
			tnBuildAction, ;
			tlRebuildAll, ;
			tlShowErrors, ;
			tlBuildNewGUIDs
		local lcErrors, ;
			lcType, ;
			lcName, ;
			loException as Exception, ;
			llOK, ;
			laError[1]
		This.nErrorCode    = 0
		This.cErrorMessage = ''
		
		* Ensure a project is passed.
		
		if vartype(toProject) <> 'O'
			This.cErrorMessage = 'Invalid project specified.'
			return .F.
		endif vartype(toProject) <> 'O'
		
		* Call any addins.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeBuildProject', toProject)
			return This.oAddins.lSuccess
		endif vartype(This.oAddins) = 'O' ...
		
		* If we're supposed to rebuild all, manually recompile all appropriate files so
		* we can tell which if any fail (the Project.Build command doesn't tell us
		* that).
		
		if tlRebuildAll
			lcErrors = ''
			for each loFile in toProject.Files foxobject
				lcType = loFile.Type
				lcName = loFile.Name
				try
					do case
						case lcType = FILETYPE_PROGRAM
							compile (lcName)
						case lcType = FILETYPE_DATABASE
							compile database (lcName)
						case lcType = FILETYPE_FORM
							compile form (lcName)
						case lcType = FILETYPE_REPORT or lcType = FILETYPE_LABEL
							compile report (lcName)
						case lcType = FILETYPE_CLASSLIB
							clear classlib (lcName)
							compile classlib (lcName)
					endcase
				catch to loException
					lcErrors = lcErrors + lcName + ': ' + loException.Message + ccCRLF
				endtry
			next loFile
		endif tlRebuildAll
		
		* Build the project.
		
		if empty(lcErrors)
			try
				llOK = toProject.Build(tcOutputName, tnBuildAction, .F., tlShowErrors, ;
					tlBuildNewGUIDs)
				if not llOK
					aerror(laError)
					This.nErrorCode    = laError[1]
					This.cErrorMessage = laError[2]
				endif not llOK
			catch to loException
				This.cErrorMessage = loException.Message
			endtry
		else
			This.cErrorMessage = 'There was a problem compiling one or more files.' + ;
				ccCRLF + ccCRLF + lcErrors
		endif empty(lcErrors)
		
		* Call any addins.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterBuildProject', toProject)
		endif vartype(This.oAddins) = 'O'
		return llOK
		
	ENDPROC

	PROCEDURE edititem		&& Edits the specified item
		*==============================================================================
		* Method:			EditItem
		* Status:			Public
		* Purpose:			Edits the specified item
		* Author:			Doug Hennig
		* Last Revision:	03/20/2017
		* Parameters:		toProject - a reference to the project object
		*					toItem    - a reference to a ProjectItem object
		* Returns:			.T. if the editor was opened
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the item has been edited
		*==============================================================================
		
		lparameters toProject, ;
			toItem
		local llReturn
		
		* Ensure a project is passed.
		
		if vartype(toProject) <> 'O'
			This.cErrorMessage = 'Invalid project specified.'
			return .F.
		endif vartype(toProject) <> 'O'
		
		* Ensure we have a valid item.
		
		if vartype(toItem) <> 'O'
			This.cErrorMessage = 'Invalid item specified.'
			return .F.
		endif vartype(toItem) <> 'O'
		
		* Ensure the item can be edited.
		
		if not toItem.CanEdit
			This.cErrorMessage = 'This item cannot be edited.'
			return .F.
		endif not toItem.CanEdit
		
		* Call any addins.
		
		This.cErrorMessage = ''
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeModifyItem', toItem)
			return This.oAddins.lSuccess
		endif vartype(This.oAddins) = 'O' ...
		
		* Have the project item edit its physical item. Notice that QueryModifyFile
		* of any projecthook for the project isn't called for non-file items but that's
		* the same behavior as the Project Manager has because these aren't files in
		* the project.
		
		llReturn = toItem.EditItem(toProject)
		if not llReturn
			This.cErrorMessage = toItem.cErrorMessage
		endif not llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Set up the object
		* Author:			Doug Hennig
		* Last revision:	03/01/2017
		* Parameters:		toAddins - a reference to a ProjectAddins object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.oAddins contains a reference to a ProjectAddins object
		*==============================================================================
		
		lparameters toAddins
		This.oAddins = toAddins
		
	ENDPROC

	PROCEDURE newitem		&& Creates a new item
		*==============================================================================
		* Method:			NewItem
		* Status:			Public
		* Purpose:			Creates a new item
		* Author:			Doug Hennig
		* Last Revision:	03/29/2017
		* Parameters:		toProject - a reference to the project object
		*					toItem    - a ProjectItem object for the item to be created
		* Returns:			.T. if it succeeded
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	a new item was created
		*==============================================================================
		
		lparameters toProject, ;
			toItem
		
		* Ensure a project is passed.
		
		if vartype(toProject) <> 'O'
			This.cErrorMessage = 'Invalid project specified.'
			return .F.
		endif vartype(toProject) <> 'O'
		
		* Ensure we have a valid item.
		
		if vartype(toItem) <> 'O'
			This.cErrorMessage = 'Invalid item specified.'
			return .F.
		endif vartype(toItem) <> 'O'
		
		* Execute any addin.
		
		This.cErrorMessage = ''
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeNewItem', toProject, toItem)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* If the project has a project hook, call the QueryNewFile method.
		
		if vartype(toProject.ProjectHook) = 'O' and ;
			toItem.Type <> FILETYPE_STORED_PROCEDURE
			toProject.ProjectHook.QueryNewFile(toItem.Type)
		endif vartype(toProject.ProjectHook) = 'O' ...
		
		* Call the NewItem method of the item.
		
		toItem.NewItem()
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterNewItem', toProject, toItem)
		endif vartype(This.oAddins) = 'O'
		return .T.
		
	ENDPROC

	PROCEDURE releasemembers
		* Nuke member objects.
		
		This.oAddins = .NULL.
		
	ENDPROC

	PROCEDURE removeitem		&& Removes the item from the project
		*==============================================================================
		* Method:			RemoveItem
		* Status:			Public
		* Purpose:			Removes the item from the project
		* Author:			Doug Hennig
		* Last Revision:	03/18/2017
		* Parameters:		toProject - a reference to the project object
		*					toItem    - a reference to a ProjectItem object
		* Returns:			.T. if the removal succeeded
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the item has been removed
		*==============================================================================
		
		lparameters toProject, ;
			toItem, ;
			tlDelete
		local llReturn
		
		* Ensure a project is passed.
		
		if vartype(toProject) <> 'O'
			This.cErrorMessage = 'Invalid project specified.'
			return .F.
		endif vartype(toProject) <> 'O'
		
		* Ensure we have a valid item.
		
		if vartype(toItem) <> 'O'
			This.cErrorMessage = 'Invalid item specified.'
			return .F.
		endif vartype(toItem) <> 'O'
		
		* Ensure the item can be removed.
		
		if not toItem.CanRemove
			This.cErrorMessage = 'This item cannot be removed.'
			return .F.
		endif not toItem.CanRemove
		
		* Execute any addin.
		
		This.cErrorMessage = ''
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeRemoveItem', ;
			toItem)
			return This.oAddins.lSuccess
		endif vartype(This.oAddins) = 'O' ...
		
		* Have the project item remove its physical item. Notice that QueryRemoveFile
		* of any projecthook for the project isn't called for non-file items but that's
		* the same behavior as the Project Manager has because these aren't files in
		* the project.
		
		llReturn = toItem.RemoveItem(toProject, tlDelete)
		if not llReturn
			This.cErrorMessage = toItem.cErrorMessage
		endif not llReturn
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterRemoveItem', toItem)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROCEDURE runitem		&& Runs the specified item
		*==============================================================================
		* Method:			RunItem
		* Status:			Public
		* Purpose:			Runs the specified item
		* Author:			Doug Hennig
		* Last Revision:	04/27/2017
		* Parameters:		toProject - a reference to the project object
		*					toItem    - a reference to a ProjectItem object
		* Returns:			.T. if it succeeded
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the item has been run
		*==============================================================================
		
		lparameters toProject, ;
			toItem
		local llReturn
		
		* Ensure a project is passed.
		
		if vartype(toProject) <> 'O'
			This.cErrorMessage = 'Invalid project specified.'
			return .F.
		endif vartype(toProject) <> 'O'
		
		* Ensure we have a valid item.
		
		if vartype(toItem) <> 'O'
			This.cErrorMessage = 'Invalid item specified.'
			return .F.
		endif vartype(toItem) <> 'O'
		
		* Ensure the item can be run.
		
		if not toItem.CanRun
			This.cErrorMessage = 'This item cannot be run.'
			return .F.
		endif not toItem.CanRun
		
		* Call any addins.
		
		This.cErrorMessage = ''
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeRunItem', toItem)
			return This.oAddins.lSuccess
		endif vartype(This.oAddins) = 'O' ...
		
		* Have the project item run its physical item.
		
		llReturn = toItem.RunItem(toProject)
		if not llReturn and vartype(toItem) = 'O'
			This.cErrorMessage = toItem.cErrorMessage
		endif not llReturn ...
		
		* Call any addins.
		
		if vartype(This.oAddins) = 'O' and vartype(toItem) = 'O'
			This.oAddins.ExecuteAddin('AfterRunItem', toItem)
		endif vartype(This.oAddins) = 'O' ...
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectsettings AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: clone		&& Creates a clone of the object
		*m: getinfosetting		&& Gets a setting from the specified string
		*m: getservers		&& Gets the COM servers for the project
		*m: getsettings		&& Gets the settings for the project
		*m: savesettings		&& Saves the settings for the project
		*m: updatefromclone		&& Updates the properties of this object from the specified clone
		*p: address		&& The author's address
		*p: attachicon		&& .T. to attach an icon
		*p: author		&& The project author
		*p: autoincrement		&& Specifies if the build version number is automatically incremented each time the project is built
		*p: buildaction		&& The default build action for the project
		*p: buildnumber		&& The build number
		*p: city		&& The author's city
		*p: company		&& The author's company
		*p: country		&& The author's country
		*p: debug		&& .T. to include debug information
		*p: displayerrors		&& .T. to display error when the project is built
		*p: encrypted		&& .T. to encrypt the EXE
		*p: home		&& The home directory for the project
		*p: icon		&& The path for the icon to use
		*p: lastbuilt		&& The date and time the project was last built
		*p: mainfile		&& The main file in the project
		*p: majorversionnumber		&& The major version number
		*p: minorversionnumber		&& The minor version number
		*p: nincludeinversioncontrol		&& What to include in version control: 1 = VFP binaries only, 2 = text equivalents only, 3 = both
		*p: oaddins		&& A reference to a ProjectAddins object
		*p: oproject		&& A reference to the project object
		*p: oservers		&& A collection of ProjectExplorerServer objects
		*p: outputfile		&& The name of the file to create when the project is built
		*p: postalcode		&& The author's postal code
		*p: project		&& The name and path of the project file
		*p: projecthookclass		&& The class to use for the project hook
		*p: projecthooklibrary		&& The library containing the class specified in ProjectHookClass
		*p: recompile		&& .T. to recompile all files when the project is built
		*p: regenerateguids		&& .T. to regenerate GUIDs when the project is built
		*p: region		&& The author's region
		*p: runafterbuild		&& .T. to run the application after the project is built
		*p: serverhelpfile		&& The COM server help file
		*p: serverproject		&& The COM server project name
		*p: typelibdesc		&& The COM server TypeLib description
		*p: user		&& User-defined information for the project
		*p: versioncomments		&& The comments for the project
		*p: versioncompany		&& The company name information for the project
		*p: versioncopyright		&& The copyright information for the project
		*p: versiondescription		&& The description for the project
		*p: versionlanguage		&& The language ID for the project
		*p: versionproduct		&& The product name information for the project
		*p: versiontrademarks		&& The trademarks information for the project
	*</DefinedPropArrayMethod>

	PROTECTED oaddins
	address = 		&& The author's address
	attachicon = .F.		&& .T. to attach an icon
	author = 		&& The project author
	autoincrement = .F.		&& Specifies if the build version number is automatically incremented each time the project is built
	buildaction = 0		&& The default build action for the project
	buildnumber = 		&& The build number
	city = 		&& The author's city
	company = 		&& The author's company
	country = 		&& The author's country
	debug = .F.		&& .T. to include debug information
	displayerrors = .T.		&& .T. to display error when the project is built
	encrypted = .F.		&& .T. to encrypt the EXE
	home = 		&& The home directory for the project
	icon = 		&& The path for the icon to use
	lastbuilt = {}		&& The date and time the project was last built
	mainfile = 		&& The main file in the project
	majorversionnumber = 		&& The major version number
	minorversionnumber = 		&& The minor version number
	Name = "projectsettings"
	nincludeinversioncontrol = 0		&& What to include in version control: 1 = VFP binaries only, 2 = text equivalents only, 3 = both
	oaddins = .NULL		&& A reference to a ProjectAddins object
	oproject = .NULL.		&& A reference to the project object
	oservers = .NULL.		&& A collection of ProjectExplorerServer objects
	outputfile = 		&& The name of the file to create when the project is built
	postalcode = 		&& The author's postal code
	project = 		&& The name and path of the project file
	projecthookclass = 		&& The class to use for the project hook
	projecthooklibrary = 		&& The library containing the class specified in ProjectHookClass
	recompile = .F.		&& .T. to recompile all files when the project is built
	regenerateguids = .F.		&& .T. to regenerate GUIDs when the project is built
	region = 		&& The author's region
	runafterbuild = .F.		&& .T. to run the application after the project is built
	serverhelpfile = 		&& The COM server help file
	serverproject = 		&& The COM server project name
	typelibdesc = 		&& The COM server TypeLib description
	user = 		&& User-defined information for the project
	versioncomments = 		&& The comments for the project
	versioncompany = 		&& The company name information for the project
	versioncopyright = 		&& The copyright information for the project
	versiondescription = 		&& The description for the project
	versionlanguage = 		&& The language ID for the project
	versionproduct = 		&& The product name information for the project
	versiontrademarks = 		&& The trademarks information for the project
	_memberdata = <VFPData>
		<memberdata name="author" type="property" display="Author"/>
		<memberdata name="company" type="property" display="Company"/>
		<memberdata name="address" type="property" display="Address"/>
		<memberdata name="city" type="property" display="City"/>
		<memberdata name="region" type="property" display="Region"/>
		<memberdata name="country" type="property" display="Country"/>
		<memberdata name="postalcode" type="property" display="PostalCode"/>
		<memberdata name="debug" type="property" display="Debug"/>
		<memberdata name="encrypted" type="property" display="Encrypted"/>
		<memberdata name="icon" type="property" display="Icon"/>
		<memberdata name="projecthookclass" type="property" display="ProjectHookClass"/>
		<memberdata name="projecthooklibrary" type="property" display="ProjectHookLibrary"/>
		<memberdata name="lastbuilt" type="property" display="LastBuilt"/>
		<memberdata name="home" type="property" display="Home"/>
		<memberdata name="getsettings" display="GetSettings"/>
		<memberdata name="savesettings" display="SaveSettings"/>
		<memberdata name="autoincrement" display="AutoIncrement"/>
		<memberdata name="majorversionnumber" display="MajorVersionNumber"/>
		<memberdata name="minorversionnumber" display="MinorVersionNumber"/>
		<memberdata name="buildnumber" display="BuildNumber"/>
		<memberdata name="versioncomments" display="VersionComments"/>
		<memberdata name="versioncompany" display="VersionCompany"/>
		<memberdata name="versioncopyright" display="VersionCopyright"/>
		<memberdata name="versiondescription" display="VersionDescription"/>
		<memberdata name="versionlanguage" display="VersionLanguage"/>
		<memberdata name="versionproduct" display="VersionProduct"/>
		<memberdata name="versiontrademarks" display="VersionTrademarks"/>
		<memberdata name="mainfile" display="MainFile"/>
		<memberdata name="outputfile" display="OutputFile"/>
		<memberdata name="buildaction" display="BuildAction"/>
		<memberdata name="recompile" display="Recompile"/>
		<memberdata name="displayerrors" display="DisplayErrors"/>
		<memberdata name="regenerateguids" display="RegenerateGUIDs"/>
		<memberdata name="runafterbuild" display="RunAfterBuild"/>
		<memberdata name="user" display="User"/>
		<memberdata name="oaddins" display="oAddins"/>
		<memberdata name="nincludeinversioncontrol" display="nIncludeInVersionControl"/>
		<memberdata name="clone" display="Clone"/>
		<memberdata name="updatefromclone" display="UpdateFromClone"/>
		<memberdata name="getinfosetting" display="GetInfoSetting"/>
		<memberdata name="serverhelpfile" display="ServerHelpFile"/>
		<memberdata name="serverproject" display="ServerProject"/>
		<memberdata name="typelibdesc" display="TypeLibDesc"/>
		<memberdata name="oproject" display="oProject"/>
		<memberdata name="getservers" display="GetServers"/>
		<memberdata name="oservers" display="oServers"/>
		<memberdata name="attachicon" display="AttachIcon"/>
		<memberdata name="project" display="Project"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectSettings
		* Based On:						ProjectExplorerCustom
		* Purpose:						Handle project-level settings
		* Author:						Doug Hennig
		* Last revision:				04/05/2017
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	none
		*
		* Changes in "Based On" class methods:
		*	About:						provides documentation for the class
		*	Init:						sets up the object
		*	ReleaseMembers:				nukes the oProject member
		*
		* Custom public properties added:
		*	Address:					The author's address
		*	AttachIcon:					.T. to attach an icon
		*	Author:						The project author
		*	AutoIncrement:				Specifies if the build version number is
		*								automatically incremented each time the project
		*								is built
		*	BuildAction:				The default build action for the project
		*	BuildNumber:				The build number
		*	City:						The author's city
		*	Company:					The author's company
		*	Country:					The author's country
		*	Debug:						.T. to include debug information
		*	DisplayErrors:				.T. to display error when the project is built
		*	Encrypted:					.T. to encrypt the EXE
		*	Home:						The home directory for the project
		*	Icon:						The path for the icon to use
		*	LastBuilt:					The date and time the project was last built
		*	MainFile:					The main file in the project
		*	MajorVersionNumber:			The major version number
		*	MinorVersionNumber:			The minor version number
		*	oProject:					A reference to the project object
		*	oServers:					A collection of ProjectExplorerServer objects
		*	OutputFile:					The name of the file to create when the project
		*								is built
		*	PostalCode:					The author's postal code
		*	Project:					The name and path of the project file
		*	ProjectHookClass:			The class to use for the project hook
		*	ProjectHookLibrary:			The library containing the class specified in
		*								ProjectHookClass
		*	Recompile:					.T. to recompile all files when the project is
		*								built
		*	RegenerateGUIDs:			.T. to regenerate GUIDs when the project is
		*								built
		*	Region:						The author's region
		*	RunAfterBuild:				.T. to run the application after the project
		*								is built
		*	ServerHelpFile:				The COM server help file
		*	ServerProject:				The COM server project name
		*	TypeLibDesc:				The COM server TypeLib description
		*	User:						User-defined information for the project
		*	VersionComments:			The comments for the project
		*	VersionCompany:				The company name information for the project
		*	VersionCopyright:			The copyright information for the project
		*	VersionDescription:			The description for the project
		*	VersionLanguage:			The language ID for the project
		*	VersionProduct:				The product name information for the project
		*	VersionTrademarks:			The trademarks information for the project
		*
		* Custom protected properties added:
		*	oAddins:					A reference to a ProjectAddins object
		*
		* Custom public methods added:
		*	Clone:						Creates a clone of the object
		*	GetServers:					Gets the COM servers for the project
		*	GetSettings:				Gets the settings for the project
		*	SaveSettings:				Saves the settings for the project
		*								change code in one place
		*
		* Custom protected methods added:
		*	GetInfoSetting:				Gets a setting from the specified string
		*==============================================================================
		
	ENDPROC

	PROCEDURE clone		&& Creates a clone of the object
		*==============================================================================
		* Method:			Clone
		* Status:			Public
		* Purpose:			Creates a clone of the object
		* Author:			Doug Hennig
		* Last Revision:	04/04/2017
		* Parameters:		none
		* Returns:			a clone of this object
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local loItem, ;
			loServer, ;
			loServerObject
		loItem = newobject(This.Class, This.ClassLibrary, '', This.oProject, ;
			This.oAddins, .T.)
		CopyProperties(This, loItem)
		loItem.oServers = newobject('ProjectExplorerCollection', ;
			fullpath('ProjectExplorerCtrls.vcx', This.ClassLibrary))
		for each loServer in This.oServers foxobject
			loServerObject = newobject('ProjectExplorerServer', This.ClassLibrary, ;
				'', loServer)
			loItem.oServers.Add(loServerObject, loServer.ProgID)
		next loServer
		return loItem
		
	ENDPROC

	PROTECTED PROCEDURE getinfosetting		&& Gets a setting from the specified string
		*==============================================================================
		* Method:			GetInfoSetting
		* Status:			Protected
		* Purpose:			Gets a setting from the specified string
		* Author:			Doug Hennig
		* Last Revision:	03/22/2017
		* Parameters:		tcSetting - the string containing the setting
		* Returns:			the setting from the string
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcSetting
		return left(tcSetting, at(chr(0), tcSetting) - 1)
		
	ENDPROC

	PROCEDURE getservers		&& Gets the COM servers for the project
		*==============================================================================
		* Method:			GetServers
		* Status:			Public
		* Purpose:			Gets the COM servers for the project
		* Author:			Doug Hennig
		* Last Revision:	04/04/2017
		* Parameters:		taServers - an array to fill with servers
		* Returns:			the number of servers
		* Environment in:	This.oServers contains a collection
		* Environment out:	This.oServers contains a collection of
		*						ProjectExplorerServer objects
		*					taServers is filled with the server objects
		*==============================================================================
		
		lparameters taServers
		This.oServers.Clear()
		for each loServer in This.oProject.Servers foxobject
			loServerObject = newobject('ProjectExplorerServer', This.ClassLibrary, ;
				'', loServer)
			This.oServers.Add(loServerObject, loServer.ProgID)
		next loServer
		return This.oServers.GetArray(@taServers)
		
	ENDPROC

	PROCEDURE getsettings		&& Gets the settings for the project
		*==============================================================================
		* Method:			GetSettings
		* Status:			Public
		* Purpose:			Gets the settings for the project
		* Author:			Doug Hennig
		* Last Revision:	04/04/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.oProject contains a reference to the project
		* Environment out:	project settings were retrieved
		* Notes:			We're not handling MainClass since ActiveDoc isn't
		*						supported
		*==============================================================================
		
		local loProject, ;
			lnSelect
		
		* Call any addins.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeGetProjectSettings', This)
			return
		endif vartype(This.oAddins) = 'O' ...
		
		* Get the settings.
		
		loProject = This.oProject
		lnSelect  = select()
		select 0
		try
			use (loProject.Name) again shared
			This.Author     = This.GetInfoSetting(substr(DEVINFO,   1, 46))
			This.Company    = This.GetInfoSetting(substr(DEVINFO,  47, 46))
			This.Address    = This.GetInfoSetting(substr(DEVINFO,  93, 46))
			This.City       = This.GetInfoSetting(substr(DEVINFO, 139, 21))
			This.Region     = This.GetInfoSetting(substr(DEVINFO, 160,  6))
			This.PostalCode = This.GetInfoSetting(substr(DEVINFO, 166, 11))
			This.Country    = This.GetInfoSetting(substr(DEVINFO, 177, 46))
			This.User       = USER
			use
		catch
		endtry
		select (lnSelect)
		This.Debug              = loProject.Debug
		This.Encrypted          = loProject.Encrypted
		This.Home               = loProject.HomeDir
		This.LastBuilt          = loProject.BuildDateTime
		This.Icon               = loProject.Icon
		This.MainFile           = loProject.MainFile
		This.ProjectHookClass   = loProject.ProjectHookClass
		This.ProjectHookLibrary = loProject.ProjectHookLibrary
		This.AutoIncrement      = loProject.AutoIncrement
		This.VersionComments    = loProject.VersionComments
		This.VersionCompany     = loProject.VersionCompany
		This.VersionCopyright   = loProject.VersionCopyright
		This.VersionDescription = loProject.VersionDescription
		This.VersionLanguage    = loProject.VersionLanguage
		This.VersionProduct     = loProject.VersionProduct
		This.VersionTrademarks  = loProject.VersionTrademarks
		This.MajorVersionNumber = strextract(loProject.VersionNumber, '', '.', 1)
		This.MinorVersionNumber = strextract(loProject.VersionNumber, '.', '.', 1)
		This.BuildNumber        = strextract(loProject.VersionNumber, '.', '', 2)
		This.ServerHelpFile     = loProject.ServerHelpFile
		This.ServerProject      = loProject.ServerProject
		This.TypeLibDesc        = loProject.TypeLibDesc
		*** FUTURE: support TypeLibCLSID, TypeLibName, SCCProvider?
		
		* Call any addins.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterGetProjectSettings', This)
		endif vartype(This.oAddins) = 'O'
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Set up the project engine
		* Author:			Doug Hennig
		* Last revision:	04/05/2017
		* Parameters:		toProject    - a reference to the project object
		*					toAddins     - a reference to a ProjectAddins object
		*					tlNoSettings - .T. to not get the settings
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.oProject contains toProject
		*					This.oAddins contains toAddins
		*					This.oServers contains a collection
		*==============================================================================
		
		lparameters toProject, ;
			toAddins, ;
			tlNoSettings
		This.oProject = toProject
		This.oAddins  = toAddins
		This.oServers = newobject('ProjectExplorerCollection', ;
			fullpath('ProjectExplorerCtrls.vcx', This.ClassLibrary))
		if vartype(This.oProject) = 'O'
			This.Project = GetProperFileCase(toProject.Name)
			if not tlNoSettings
				This.GetSettings()
			endif not tlNoSettings
		endif vartype(This.oProject) = 'O'
		
	ENDPROC

	PROCEDURE releasemembers
		* Nuke member references.
		
		if vartype(This.oServers) = 'O'
			This.oServers.Release()
		endif vartype(This.oServers) = 'O'
		This.oProject = .NULL.
		This.oAddins  = .NULL.
		
	ENDPROC

	PROCEDURE savesettings		&& Saves the settings for the project
		*==============================================================================
		* Method:			SaveSettings
		* Status:			Public
		* Purpose:			Saves the settings for the project
		* Author:			Doug Hennig
		* Last Revision:	04/05/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.oProject contains a reference to the project
		* Environment out:	project settings were saved
		*==============================================================================
		
		local loProject, ;
			lnSelect, ;
			loServer, ;
			loServerObject
		
		* Call any addins.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeSaveProjectSettings', This)
			return
		endif vartype(This.oAddins) = 'O' ...
		
		* Save the settings.
		
		loProject = This.oProject
		lnSelect  = select()
		select 0
		try
			use (loProject.Name) again shared
			replace DEVINFO with padr(alltrim(This.Author), 46, chr(0)) + ;
				padr(alltrim(This.Company), 46, chr(0)) + ;
				padr(alltrim(This.Address), 46, chr(0)) + ;
				padr(alltrim(This.City), 21, chr(0)) + ;
				padr(alltrim(This.Region), 6, chr(0)) + ;
				padr(alltrim(This.PostalCode), 11, chr(0)) + ;
				padr(alltrim(This.Country), 46, chr(0)) + ;
				substr(DEVINFO, 223)
			if not USER == This.User
				replace USER with This.User
			endif not USER == This.User
			use
		catch
		endtry
		loProject.Debug              = This.Debug
		loProject.Encrypted          = This.Encrypted
		loProject.HomeDir            = This.Home
		loProject.Icon               = This.Icon
		loProject.AutoIncrement      = This.AutoIncrement
		loProject.VersionComments    = This.VersionComments
		loProject.VersionCompany     = This.VersionCompany
		loProject.VersionCopyright   = This.VersionCopyright
		loProject.VersionDescription = This.VersionDescription
		loProject.VersionLanguage    = This.VersionLanguage
		loProject.VersionProduct     = This.VersionProduct
		loProject.VersionTrademarks  = This.VersionTrademarks
		loProject.VersionNumber      = alltrim(This.MajorVersionNumber) + '.' + ;
			alltrim(This.MinorVersionNumber) + '.' + alltrim(This.BuildNumber)
		
		* We can't save these things unless we have COM servers.
		
		if loProject.Servers.Count > 0
			loProject.ServerHelpFile = alltrim(This.ServerHelpFile)
			loProject.ServerProject  = alltrim(This.ServerProject)
			loProject.TypeLibDesc    = alltrim(This.TypeLibDesc)
		endif loProject.Servers.Count > 0
		
		* Save server settings.
		
		for each loServer in loProject.Servers foxobject
			loServerObject = This.oServers.Item(loServer.ProgID)
			if vartype(loServerObject) = 'O'
				loServer.Description   = loServerObject.Description
				loServer.HelpContextID = loServerObject.HelpContextID
				loServer.Instancing    = loServerObject.Instancing
			endif vartype(loServerObject) = 'O'
		next loServer
		
		* Only update the ProjectHook* properties if they've changed. Note that we only
		* set ProjectHookClass if it isn't empty; setting ProjectHookLibrary blanks it
		* plus setting it to a blank string brings up a dialog.
		
		if not loProject.ProjectHookClass == This.ProjectHookClass and ;
			not loProject.ProjectHookLibrary == This.ProjectHookLibrary
			loProject.ProjectHookLibrary = This.ProjectHookLibrary
			if empty(This.ProjectHookClass)
				loProject.ProjectHook = .NULL.
			else
				loProject.ProjectHookClass = This.ProjectHookClass
				loProject.ProjectHook      = newobject(This.ProjectHookClass, ;
					This.ProjectHookLibrary)
			endif empty(This.ProjectHookClass)
		endif not loProject.ProjectHookClass == This.ProjectHookClass ...
		
		* Call any addins.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterSaveProjectSettings', This)
		endif vartype(This.oAddins) = 'O'
		
	ENDPROC

	PROCEDURE updatefromclone		&& Updates the properties of this object from the specified clone
		*==============================================================================
		* Method:			UpdateFromClone
		* Status:			Public
		* Purpose:			Updates the properties of this object from the specified
		*						clone
		* Author:			Doug Hennig
		* Last Revision:	04/04/2017
		* Parameters:		toItem - the clone to copy properties from
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	this object's properties have the same values as the
		*						clone's
		*==============================================================================
		
		lparameters toItem
		local loServer, ;
			loServerObject
		
		* Ensure a valid object was passed.
		
		if type('toItem.Class') <> 'C' or not toItem.Class == This.Class
			This.cErrorMessage = 'Invalid item passed.'
			return .F.
		endif type('toItem.Class') <> 'C' ...
		
		* Copy the properties.
		
		This.cErrorMessage = ''
		CopyProperties(toItem, This)
		This.oServers = newobject('ProjectExplorerCollection', ;
			fullpath('ProjectExplorerCtrls.vcx', This.ClassLibrary))
		for each loServer in toItem.oServers foxobject
			loServerObject = newobject('ProjectExplorerServer', This.ClassLibrary, ;
				'', loServer)
			This.oServers.Add(loServerObject, loServer.ProgID)
		next loServer
		return .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS versioncontroloperations AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	*<DefinedPropArrayMethod>
		*m: addfile		&& Adds the specified file to version control
		*m: addfiles		&& Adds several files to version control
		*m: addfilesinternal		&& Adds several files to version control
		*m: commitallfiles		&& Commit all changes
		*m: commitallfilesinternal		&& Commits all changes
		*m: commitfile		&& Commits the specified file
		*m: commitfiles		&& Commits changes to several files
		*m: commitfilesinternal		&& Commits changes to several files
		*m: convertbinarytotext		&& Converts VFP binary files to their text equivalents
		*m: createrepository		&& Creates a repository in the specified folder
		*m: createrepositoryinternal		&& Creates a repository in the specified folder
		*m: crepositoryfolder_assign
		*m: getstatusforallfiles		&& Gets the status for all files in the specified collection
		*m: getstatusforallfilesinternal		&& Gets the status for all files in the specified collection
		*m: getstatusforfile		&& Gets the status for the specified file
		*m: getstatusforfileinternal		&& Gets the status for the specified file
		*m: removefile		&& Removes the specified file from version control
		*m: removefiles		&& Removes several files from version control
		*m: removefilesinternal		&& Removes several files from version control
		*m: renamefile		&& Renames the specified file in version control
		*m: renamefileinternal		&& Renames the specified file in version control
		*m: repositorybrowser		&& Displays the repository browser
		*m: repositorybrowserinternal		&& Displays the repository browser
		*m: revertfile		&& Reverts the specified file
		*m: revertfiles		&& Reverts several files
		*m: revertfilesinternal		&& Reverts several files
		*m: revisionhistory		&& Display the revision history for the specified file
		*m: revisionhistoryinternal		&& Display the revision history for the specified file
		*m: visualdiff		&& Displays the visual diff for the file
		*m: visualdiffinternal		&& Displays the visual diff for the file
		*p: cfileaddmessage		&& The message to use when auto-committing file additions
		*p: cfileremovemessage		&& The message to use when auto-committing file removals
		*p: cfoxbin2prglocation		&& The folder where FoxBin2PRG is located
		*p: crepositoryfolder		&& The folder containing the repository
		*p: lautocommitchanges		&& .T. to auto-commit changes
		*p: nincludeinversioncontrol		&& What to include in version control: 1 = VFP binaries only, 2 = text equivalents only, 3 = both
		*p: oaddins		&& A reference to a ProjectAddins object
	*</DefinedPropArrayMethod>

	PROTECTED oaddins
	cfileaddmessage = 		&& The message to use when auto-committing file additions
	cfileremovemessage = 		&& The message to use when auto-committing file removals
	cfoxbin2prglocation = 		&& The folder where FoxBin2PRG is located
	crepositoryfolder = 		&& The folder containing the repository
	lautocommitchanges = .F.		&& .T. to auto-commit changes
	Name = "versioncontroloperations"
	nincludeinversioncontrol = 0		&& What to include in version control: 1 = VFP binaries only, 2 = text equivalents only, 3 = both
	oaddins = .NULL.		&& A reference to a ProjectAddins object
	_memberdata = <VFPData>
		<memberdata name="getstatusforallfiles" display="GetStatusForAllFiles"/>
		<memberdata name="addfile" display="AddFile"/>
		<memberdata name="removefile" display="RemoveFile"/>
		<memberdata name="revertfile" display="RevertFile"/>
		<memberdata name="revisionhistory" display="RevisionHistory"/>
		<memberdata name="visualdiff" display="VisualDiff"/>
		<memberdata name="getstatusforfile" display="GetStatusForFile"/>
		<memberdata name="convertbinarytotext" display="ConvertBinaryToText"/>
		<memberdata name="repositorybrowser" display="RepositoryBrowser"/>
		<memberdata name="createrepository" display="CreateRepository"/>
		<memberdata name="commitallfilesinternal" display="CommitAllFilesInternal"/>
		<memberdata name="commitfile" display="CommitFile"/>
		<memberdata name="commitallfiles" display="CommitAllFiles"/>
		<memberdata name="commitfiles" display="CommitFiles"/>
		<memberdata name="createrepositoryinternal" display="CreateRepositoryInternal"/>
		<memberdata name="commitfilesinternal" display="CommitFilesInternal"/>
		<memberdata name="getstatusforfileinternal" display="GetStatusForFileInternal"/>
		<memberdata name="getstatusforallfilesinternal" display="GetStatusForAllFilesInternal"/>
		<memberdata name="oaddins" display="oAddins"/>
		<memberdata name="repositorybrowserinternal" display="RepositoryBrowserInternal"/>
		<memberdata name="revisionhistoryinternal" display="RevisionHistoryInternal"/>
		<memberdata name="visualdiffinternal" display="VisualDiffInternal"/>
		<memberdata name="addfiles" display="AddFiles"/>
		<memberdata name="addfilesinternal" display="AddFilesInternal"/>
		<memberdata name="removefiles" display="RemoveFiles"/>
		<memberdata name="removefilesinternal" display="RemoveFilesInternal"/>
		<memberdata name="revertfiles" display="RevertFiles"/>
		<memberdata name="revertfilesinternal" display="RevertFilesInternal"/>
		<memberdata name="lautocommitchanges" display="lAutoCommitChanges"/>
		<memberdata name="cfoxbin2prglocation" display="cFoxBin2PRGLocation"/>
		<memberdata name="cfileaddmessage" display="cFileAddMessage"/>
		<memberdata name="cfileremovemessage" display="cFileRemoveMessage"/>
		<memberdata name="nincludeinversioncontrol" display="nIncludeInVersionControl"/>
		<memberdata name="renamefile" display="RenameFile"/>
		<memberdata name="renamefileinternal" display="RenameFileInternal"/>
		<memberdata name="crepositoryfolder" display="cRepositoryFolder"/>
		<memberdata name="crepositoryfolder_assign" display="cRepositoryFolder_Assign"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						VersionControlOperations
		* Based On:						ProjectExplorerCustom
		* Purpose:						Provides version control support
		* Author:						Doug Hennig
		* Last revision:				09/15/2017
		* Include file:					ProjectExplorer.h
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	About:						provides documentation for the class
		*	Init:						sets up the object
		*
		* Custom public properties added:
		*	cFoxBin2PRGLocation:		Contains the folder where FoxBin2PRG is located
		*	cFileAddMessage:			The message to use when auto-committing file
		*								additions
		*	cFileRemoveMessage:			The message to use when auto-committing file
		*								removals
		*	cRepositoryFolder:			The folder containing the repository (has
		*									Assign method)
		*	lAutoCommitChanges:			.T. to auto-commit changes
		*	nIncludeInVersionControl:	What to include in version control:
		*									1 = VFP binaries only
		*									2 = text equivalents only
		*									3 = both
		*
		* Custom protected properties added:
		*	oAddins:					A reference to a ProjectAddins object
		*
		* Custom public methods added:
		*	AddFile:					Adds the specified file to version control
		*	AddFiles:					Adds several files to version control
		*	CommitAllFiles:				Commit all changes
		*	CommitFile:					Commits the specified file
		*	CommitFiles:				Commits changes to several files
		*	ConvertBinaryToText:		Converts VFP binary files to their text
		*								equivalents
		*	CreateRepository:			Creates a repository in the specified folder
		*	GetStatusForAllFiles:		Gets the status for all files in the specified
		*								collection
		*	GetStatusForFile:			Gets the status for the specified file
		*	RemoveFile:					Removes the specified file from version control
		*	RemoveFiles:				Removes several files from version control
		*	RenameFile:					Renames the specified file in version control
		*	RepositoryBrowser:			Displays the repository browser
		*	RevertFile:					Reverts the specified file
		*	RevertFiles:				Reverts several files
		*	RevisionHistory:			Display the revision history for the specified
		*								file
		*	VisualDiff:					Displays the visual diff for the file
		*
		* Custom protected methods added:
		*	AddFilesInternal:			Adds several files to version control
		*	CommitAllFilesInternal:		Commits all changes
		*	CommitFilesInternal:		Commits changes to several files
		*	CreateRepositoryInternal:	Creates a repository in the specified folder
		*	GetStatusForAllFilesInternal:	Gets the status for all files in the
		*									specified collection
		*	GetStatusForFileInternal:	Gets the status for the specified file
		*	RemoveFilesInternal:		Removes several files from version control
		*	RenameFileInternal:			Renames the specified file in version control
		*	RepositoryBrowserInternal:	Displays the repository browser
		*	RevertFilesInternal:		Reverts several files
		*	RevisionHistoryInternal:	Display the revision history for the specified
		*								file
		*	VisualDiffInternal:			Displays the visual diff for the file
		*==============================================================================
		
	ENDPROC

	PROCEDURE addfile		&& Adds the specified file to version control
		*==============================================================================
		* Method:			AddFile
		* Status:			Public
		* Purpose:			Adds a file to version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile         - the name and path of the file to add
		*					tlNoAutoCommit - .T. to not auto-commit changes (overrides
		*						the setting of This.lAutoCommitChanges)
		* Returns:			.T. if it succeeded
		* Environment in:	see This.AddFiles
		* Environment out:	see This.AddFiles
		*==============================================================================
		
		lparameters tcFile, ;
			tlNoAutoCommit
		local laFiles[1]
		laFiles[1] = tcFile
		return This.AddFiles(@laFiles, tlNoAutoCommit)
		
	ENDPROC

	PROCEDURE addfiles		&& Adds several files to version control
		*==============================================================================
		* Method:			AddFiles
		* Status:			Public
		* Purpose:			Adds several files to version control
		* Author:			Doug Hennig
		* Last Revision:	09/15/2017
		* Parameters:		taFiles        - an array of files to add
		*					tlNoAutoCommit - .T. to not auto-commit changes (overrides
		*						the setting of This.lAutoCommitChanges)
		* Returns:			.T. if it succeeded
		* Environment in:	This.nIncludeInVersionControl contains what to include in
		*						version control
		*					This.lAutoCommitChanges if we're supposed to auto-commit
		*					This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the files were added to version control
		*					the adds were committed if we're supposed to
		*==============================================================================
		
		lparameters taFiles, ;
			tlNoAutoCommit
		local lcError, ;
			lnI, ;
			lcFile, ;
			lnFiles, ;
			llAddFile, ;
			lcOther, ;
			llBinary, ;
			lcTextFile, ;
			laFiles[1], ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Ensure we have valid files.
		
		if type('taFiles', 1) = 'A'
			lcError = ''
			for lnI = 1 to alen(taFiles)
				lcFile = taFiles[lnI]
				if vartype(lcFile) <> 'C' or empty(lcFile) or not file(lcFile)
					lcError = lcError + iif(empty(lcError), '', ccCRLF) + ;
						'Invalid file specified in element ' + transform(lnI)
				endif vartype(lcFile) <> 'C' ...
			next lnI
			if not empty(lcError)
				This.cErrorMessage = lcError
				return .F.
			endif not empty(lcError)
		else
			This.cErrorMessage = 'Invalid files specified'
			return .F.
		endif type('taFiles', 1) = 'A'
		This.cErrorMessage = ''
		
		* Use the correct case for the files because some version control providers are
		* case-sensitive. For some file types, close it first.
		
		lnFiles = 0
		for lnI = 1 to alen(taFiles)
			lcFile = GetProperFileCase(taFiles[lnI])
			CloseFile(lcFile)
		
		* Determine what to add.
		
			llAddFile = .T.
			lcOther   = GetVFPBinaryOtherFile(lcFile)
			llBinary  = not empty(lcOther) or IsVFPBinaryFile(lcFile)
		
		* This is a binary file and we're either only including text equivalents or
		* including both, so create the text file, add it to version control, and flag
		* whether we're adding the binary file.
		
			if llBinary and This.nIncludeInVersionControl > 1
				This.ConvertBinaryToText(lcFile)
				lcTextFile = GetTextFileName(lcFile)
				lnFiles    = lnFiles + 1
				dimension laFiles[lnFiles]
				laFiles[lnFiles] = lcTextFile
				llAddFile        = This.nIncludeInVersionControl = 3
			endif llBinary ...
		
		* Add the file to version control, including associated files such as SCT.
		
			if llAddFile
				lnFiles = lnFiles + 1
				dimension laFiles[lnFiles]
				laFiles[lnFiles] = lcFile
				if not empty(lcOther)
					lnFiles = lnFiles + 1
					dimension laFiles[lnFiles]
					laFiles[lnFiles] = lcOther
					lcOther = GetVFPBinaryOtherFile(lcFile, .T.)
					if not empty(lcOther)
						lnFiles = lnFiles + 1
						dimension laFiles[lnFiles]
						laFiles[lnFiles] = lcOther
					endif not empty(lcOther)
				endif not empty(lcOther)
			endif llAddFile
		next lnI
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeAddFilesToVersionControl', @laFiles)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* If everything is good so far, use the internal method to do the work.
		
		llReturn = This.AddFilesInternal(@laFiles)
		
		* If we're supposed to auto-commit changes, do so.
		
		if llReturn and This.lAutoCommitChanges and not tlNoAutoCommit
			This.CommitFiles(This.cFileAddMessage, @laFiles, .T.)
		endif llReturn ...
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterAddFilesToVersionControl', @laFiles)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE addfilesinternal		&& Adds several files to version control
		*==============================================================================
		* Method:			AddFilesInternal
		* Status:			Protected
		* Purpose:			Adds several files to version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		taFiles - an array of files to add
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were added to version control
		*==============================================================================
		
		* Abstract method.
		
		lparameters taFiles
		
	ENDPROC

	PROCEDURE commitallfiles		&& Commit all changes
		*==============================================================================
		* Method:			CommitAllFiles
		* Status:			Public
		* Purpose:			Commits all changes
		* Author:			Doug Hennig
		* Last Revision:	09/15/2017
		* Parameters:		tcMessage  - the commit message
		*					taProjects - an array containing the name and path for
		*						the project to generate text files for (optional: not
		*						required if tlNoText is .T.
		*					tlNoText   - .T. to not create text files (such as when
		*						we're adding version control to a project so it was
		*						already done)
		* Returns:			.T. if it succeeded
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		*					This.nIncludeInVersionControl contains what to include in
		*						version control
		* Environment out:	the changes may have been committed
		*==============================================================================
		
		lparameters tcMessage, ;
			taProjects, ;
			tlNoText
		local lcError, ;
			lnI, ;
			lcProject
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taProjects[1]
		endif .F.
		
		* Ensure we have valid projects.
		
		do case
			case tlNoText
			case type('taProjects', 1) = 'A'
				lcError = ''
				for lnI = 1 to alen(taProjects)
					lcProject = taProjects[lnI]
					if vartype(lcProject) <> 'C' or empty(lcProject) or not file(lcProject)
						lcError = lcError + iif(empty(lcError), '', ccCRLF) + ;
							'Invalid project specified in element ' + transform(lnI)
					endif vartype(lcProject) <> 'C' ...
				next lnI
				if not empty(lcError)
					This.cErrorMessage = lcError
					return .F.
				endif not empty(lcError)
			otherwise
				This.cErrorMessage = 'Invalid projects specified'
				return .F.
		endcase
		
		* Ensure we have a message.
		
		if vartype(tcMessage) <> 'C' or empty(tcMessage)
			This.cErrorMessage = 'Invalid message specified.'
			return .F.
		endif vartype(tcFile) <> 'C' ...
		This.cErrorMessage = ''
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeCommitAllFiles', tcMessage, ;
				@taProjects)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* If we're supposed to include text equivalents in version control, create them.
		
		if This.nIncludeInVersionControl > 1 and not tlNoText
			for lnI = 1 to alen(taProjects)
				This.ConvertBinaryToText(taProjects[lnI], .T.)
			next lnI
		endif This.nIncludeInVersionControl > 1 ...
		
		* Commit all files.
		
		llReturn = This.CommitAllFilesInternal(tcMessage)
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterCommitAllFiles', tcMessage, @taProjects)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE commitallfilesinternal		&& Commits all changes
		*==============================================================================
		* Method:			CommitAllFilesInternal
		* Status:			Protected
		* Purpose:			Commits all changes
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcMessage - the commit message
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the changes may have been committed
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcMessage
		
	ENDPROC

	PROCEDURE commitfile		&& Commits the specified file
		*==============================================================================
		* Method:			CommitFile
		* Status:			Public
		* Purpose:			Commits the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/13/2017
		* Parameters:		tcMessage - the commit message
		*					tcFile    - the file to commit
		* Returns:			.T.
		* Environment in:	see This.CommitFiles
		* Environment out:	see This.CommitFiles
		*==============================================================================
		
		lparameters tcMessage, ;
			tcFile
		local laFiles[1]
		laFiles[1] = tcFile
		return This.CommitFiles(tcMessage, @laFiles)
		
	ENDPROC

	PROCEDURE commitfiles		&& Commits changes to several files
		*==============================================================================
		* Method:			CommitFiles
		* Status:			Public
		* Purpose:			Commits changes to several files
		* Author:			Doug Hennig
		* Last Revision:	09/15/2017
		* Parameters:		tcMessage - the commit message
		*					taFiles   - an array of files to commit
		*					tlNoCheck - .T. to do all the files specified, .F. to check
		*						for binary files
		* Returns:			.T. if it succeeded
		* Environment in:	This.nIncludeInVersionControl contains what to include in
		*						version control
		*					This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the changes may have been committed
		*==============================================================================
		
		lparameters tcMessage, ;
			taFiles, ;
			tlNoCheck
		local lcError, ;
			lnI, ;
			lcFile, ;
			lnFiles, ;
			lcOther, ;
			llBinary, ;
			laFiles[1], ;
			lcTextFile, ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Ensure we have a message.
		
		if vartype(tcMessage) <> 'C' or empty(tcMessage)
			This.cErrorMessage = 'Invalid message specified.'
			return .F.
		endif vartype(tcFile) <> 'C' ...
		
		* Ensure we have valid files.
		
		if type('taFiles', 1) = 'A'
			lcError = ''
			for lnI = 1 to alen(taFiles)
				lcFile = taFiles[lnI]
				if vartype(lcFile) <> 'C' or empty(lcFile) or not file(lcFile)
					lcError = lcError + iif(empty(lcError), '', ccCRLF) + ;
						'Invalid file specified in element ' + transform(lnI)
				endif vartype(lcFile) <> 'C' ...
			next lnI
			if not empty(lcError)
				This.cErrorMessage = lcError
				return .F.
			endif not empty(lcError)
		else
			This.cErrorMessage = 'Invalid files specified'
			return .F.
		endif type('taFiles', 1) = 'A'
		This.cErrorMessage = ''
		
		* Use the correct case for the files because some version control providers are
		* case-sensitive. For some file types, close it first.
		
		lnFiles = 0
		for lnI = 1 to alen(taFiles)
			lcFile = GetProperFileCase(taFiles[lnI])
			CloseFile(lcFile)
		
		* If we're not supposed to check files, add this to the list. Otherwise, determine
		* which files to commit.
		
			if tlNoCheck
				lnFiles = lnFiles + 1
				dimension laFiles[lnFiles]
				laFiles[lnFiles] = lcFile
			else
				lcOther  = GetVFPBinaryOtherFile(lcFile)
				llBinary = not empty(lcOther) or IsVFPBinaryFile(lcFile)
		
		* If this isn't a VFP binary file or it is and it's included in version
		* control, commit it.
		
				if not llBinary or inlist(This.nIncludeInVersionControl, 1, 3)
					lnFiles = lnFiles + 1
					dimension laFiles[lnFiles]
					laFiles[lnFiles] = lcFile
		
		* If this is a binary file, commit the associated files.
		
					if not empty(lcOther)
						lnFiles = lnFiles + 1
						dimension laFiles[lnFiles]
						laFiles[lnFiles] = lcOther
						lcOther = GetVFPBinaryOtherFile(lcFile, .T.)
						if not empty(lcOther)
							lnFiles = lnFiles + 1
							dimension laFiles[lnFiles]
							laFiles[lnFiles] = lcOther
						endif not empty(lcOther)
					endif not empty(lcOther)
				endif not llBinary ...
		
		* If the text equivalent is in version control, create it and commit it.
		
				if llBinary and This.nIncludeInVersionControl > 1
					This.ConvertBinaryToText(lcFile)
					lcTextFile = GetTextFileName(lcFile)
					lnFiles    = lnFiles + 1
					dimension laFiles[lnFiles]
					laFiles[lnFiles] = lcTextFile
				endif llBinary ...
			endif not tlNoCheck
		next lnI
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeCommitFiles', tcMessage, @laFiles)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* If everything is good so far, use the internal method to do the work.
		
		llReturn = This.CommitFilesInternal(tcMessage, @laFiles)
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterCommitFiles', tcMessage, @laFiles)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE commitfilesinternal		&& Commits changes to several files
		*==============================================================================
		* Method:			CommitFilesInternal
		* Status:			Protected
		* Purpose:			Commits changes to several files
		* Author:			Doug Hennig
		* Last Revision:	03/24/2017
		* Parameters:		tcMessage - the commit message
		*					taFiles   - an array of files to commit
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the changes may have been committed
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcMessage, ;
			taFiles
		
	ENDPROC

	PROCEDURE convertbinarytotext		&& Converts VFP binary files to their text equivalents
		*==============================================================================
		* Method:			ConvertBinaryToText
		* Status:			Public
		* Purpose:			Converts VFP binary files to their text equivalents
		* Author:			Doug Hennig
		* Last Revision:	04/25/2017
		* Parameters:		tcFile - the name and path of the file to convert
		*					tlAll  - .T. to convert all files
		* Returns:			.T.
		* Environment in:	This.cFoxBin2PRGLocation contains the folder where
		*						FoxBin2PRG is located
		* Environment out:	the text equivalent of the binary file was created or
		*						updated (if a project was specified, all binaries in
		*						the project are processed) or vice versa if a text
		*						file was specified
		*==============================================================================
		
		lparameters tcFile, ;
			tlAll
		if not empty(This.cFoxBin2PRGLocation)
			if lower(justext(tcFile)) = 'dbf'
				CloseFile(tcFile)
			endif lower(justext(tcFile)) = 'dbf'
			do (This.cFoxBin2PRGLocation + ccFOXBIN2PRG_MAIN_EXE_FILENAME) with ;
				tcFile, iif(tlAll, '*', '')
		endif not empty(This.cFoxBin2PRGLocation)
		
	ENDPROC

	PROCEDURE createrepository		&& Creates a repository in the specified folder
		*==============================================================================
		* Method:			CreateRepository
		* Status:			Public
		* Purpose:			Creates a repository in the specified folder
		* Author:			Doug Hennig
		* Last Revision:	04/20/2017
		* Parameters:		tcFolder - the folder to create the repository in
		* Returns:			.T. if it succeeded
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the repository was created
		*==============================================================================
		
		lparameters tcFolder
		local llReturn
		
		* Ensure we have a valid folder.
		
		if vartype(tcFolder) <> 'C' or empty(tcFolder) or not directory(tcFolder)
			This.cErrorMessage = 'Invalid folder specified.'
			return .F.
		endif vartype(tcFolder) <> 'C' ...
		This.cErrorMessage = ''
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeCreateRepository', tcFolder)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* Save the folder.
		
		This.cRepositoryFolder = tcFolder
		
		* Have the internal method do the actual work.
		
		llReturn = This.CreateRepositoryInternal()
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterCreateRepository', tcFolder)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE createrepositoryinternal		&& Creates a repository in the specified folder
		*==============================================================================
		* Method:			CreateRepositoryInternal
		* Status:			Protected
		* Purpose:			Creates a repository in the specified folder
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.cRepositoryFolder contains the folder to create the
		*						repository in
		* Environment out:	the repository was created
		*==============================================================================
		
		* Abstract method.
		
	ENDPROC

	PROCEDURE crepositoryfolder_assign
		* Strip a trailing backslash because that prevents the launch directory from
		* being set properly in APIAppRun. Also, use the correct case.
		
		lparameters tcFolder
		local lcFolder
		lcFolder = GetProperFileCase(tcFolder, .T.)
		This.cRepositoryFolder = iif(right(lcFolder, 1) = '\', ;
			left(lcFolder, len(lcFolder) - 1), lcFolder)
		
	ENDPROC

	PROCEDURE getstatusforallfiles		&& Gets the status for all files in the specified collection
		*==============================================================================
		* Method:			GetStatusForAllFiles
		* Status:			Public
		* Purpose:			Gets the status for all files in the specified collection
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		toFiles - a collection of ProjectItem objects to get the
		*						status for
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the status of each ProjectItem object has been set
		*==============================================================================
		
		lparameters toFiles
		
		* Ensure we have a valid collection.
		
		if vartype(toFiles) <> 'O' or not pemstatus(toFiles, 'Count', 5)
			This.cErrorMessage = 'Invalid collection specified.'
			return .F.
		endif vartype(toFiles) <> 'O' ...
		This.cErrorMessage = ''
		
		* Have the internal method to the work.
		
		return This.GetStatusForAllFilesInternal(toFiles)
		
	ENDPROC

	PROTECTED PROCEDURE getstatusforallfilesinternal		&& Gets the status for all files in the specified collection
		*==============================================================================
		* Method:			GetStatusForAllFilesInternal
		* Status:			Protected
		* Purpose:			Gets the status for all files in the specified collection
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		toFiles - a collection of ProjectItem objects to get the
		*						status for
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the status of each ProjectItem object has been set
		*==============================================================================
		
		* Abstract method.
		
		lparameters toFiles
		
	ENDPROC

	PROCEDURE getstatusforfile		&& Gets the status for the specified file
		*==============================================================================
		* Method:			GetStatusForFile
		* Status:			Public
		* Purpose:			Gets the status for the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to get the status
		*						for
		* Returns:			the status of the file
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcFile
		local lcFile, ;
			lcOther, ;
			llBinary, ;
			lcFiles
		
		* Ensure we have a valid file.
		
		if vartype(tcFile) <> 'C' or empty(tcFile) or not file(tcFile)
			This.cErrorMessage = 'Invalid file specified.'
			return .F.
		endif vartype(tcFile) <> 'C' ...
		This.cErrorMessage = ''
		
		* Use the correct case for the file because some version control providers are
		* case-sensitive.
		
		lcFile = GetProperFileCase(tcFile)
		
		* Determine what to get the status for.
		
		lcOther  = GetVFPBinaryOtherFile(lcFile)
		llBinary = not empty(lcOther) or IsVFPBinaryFile(lcFile)
		lcFiles  = ''
		do case
		
		* This isn't a binary file, so add quotes to the filename in case there are
		* spaces in the path.
		
			case not llBinary
				lcFiles = '"' + lcFile + '"'
		
		* If this is a VFP binary file and we're storing text equivalents only, get the
		* status for that file.
		
			case This.nIncludeInVersionControl = 2
				lcFiles = '"' + GetTextFileName(lcFile) + '"'
		
		* If this is a VFP binary file, we'll get the status for all associated files.
		* For some file types, close it first.
		
			otherwise
				CloseFile(lcFile)
				lcFiles = '"' + lcFile + '"'
				if not empty(lcOther)
					lcFiles = lcFiles + ' "' + lcOther + '"'
					lcOther = GetVFPBinaryOtherFile(lcFile, .T.)
					if not empty(lcOther)
						lcFiles = lcFiles + ' "' + lcOther + '"'
					endif not empty(lcOther)
				endif not empty(lcOther)
		endcase
		
		* Have the internal method do the work.
		
		return This.GetStatusForFileInternal(lcFiles)
		
	ENDPROC

	PROTECTED PROCEDURE getstatusforfileinternal		&& Gets the status for the specified file
		*==============================================================================
		* Method:			GetStatusForFileInternal
		* Status:			Protected
		* Purpose:			Gets the status for the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to get the status
		*						for (if the file is a VFP binary file, contains a list
		*						of files)
		* Returns:			the status of the file (in the case of a VFP binary, the
		*						combined status)
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcFile
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Sets up the object
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tnIncludeInVersionControl - what to include in version
		*						control (see About)
		*					tlAutoCommit              - .T. to auto-commit changes
		*					tcFileAddMessage          - the message to use when
		*						auto-committing file additions
		*					tcFileRemoveMessage       - the message to use when
		*						auto-committing file removals
		*					toAddins                  - a reference to a ProjectAddins
		*						object
		*					tcFoxBin2PRGLocation      - the folder where FoxBin2PRG is
		*						located
		*					tcRepositoryFolder        - the folder where the repository
		*						is located
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.nIncludeInVersionControl, This.lAutoCommitChanges,
		*						This.cFileAddMessage, This.cFileRemoveMessage,
		*						This.oAddins, This.cFoxBin2PRGLocation, and
		*						This.cRepositoryFolder contain the passed parameters
		*==============================================================================
		
		lparameters tnIncludeInVersionControl, ;
			tlAutoCommit, ;
			tcFileAddMessage, ;
			tcFileRemoveMessage, ;
			toAddins, ;
			tcFoxBin2PRGLocation, ;
			tcRepositoryFolder
		This.nIncludeInVersionControl = tnIncludeInVersionControl
		This.lAutoCommitChanges       = tlAutoCommit
		This.cFileAddMessage          = tcFileAddMessage
		This.cFileRemoveMessage       = tcFileRemoveMessage
		This.oAddins                  = toAddins
		This.cFoxBin2PRGLocation      = tcFoxBin2PRGLocation
		This.cRepositoryFolder        = evl(tcRepositoryFolder, '')
		
	ENDPROC

	PROCEDURE releasemembers
		* Nuke member objects.
		
		This.oAddins = .NULL.
		
	ENDPROC

	PROCEDURE removefile		&& Removes the specified file from version control
		*==============================================================================
		* Method:			RemoveFile
		* Status:			Public
		* Purpose:			Removes a file from version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to remove
		* Returns:			.T. if it succeeded
		*					see This.RemoveFiles
		* Environment out:	see This.RemoveFiles
		*==============================================================================
		
		lparameters tcFile
		local laFiles[1]
		laFiles[1] = tcFile
		return This.RemoveFiles(@laFiles)
		
	ENDPROC

	PROCEDURE removefiles		&& Removes several files from version control
		*==============================================================================
		* Method:			RemoveFiles
		* Status:			Public
		* Purpose:			Removes several files from version control
		* Author:			Doug Hennig
		* Last Revision:	09/15/2017
		* Parameters:		taFiles - an array of files to remove
		* Returns:			.T. if it succeeded
		* Environment in:	This.nIncludeInVersionControl contains what to include in
		*						version control
		*					This.lAutoCommitChanges if we're supposed to auto-commit
		*					This.cFileRemoveMessage contains the message to use for the
		*						commit
		*					This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the file, any associated files (such as SCT for an SCX),
		*						and the text equivalent (if necessary) were removed
		*						from version control
		*==============================================================================
		
		lparameters taFiles
		local lcError, ;
			lnI, ;
			lcFile, ;
			lnFiles, ;
			llRemoveFile, ;
			lcOther, ;
			llBinary, ;
			lcTextFile, ;
			laFiles[1], ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Ensure we have valid files.
		
		if type('taFiles', 1) = 'A'
			lcError = ''
			for lnI = 1 to alen(taFiles)
				lcFile = taFiles[lnI]
				if vartype(lcFile) <> 'C' or empty(lcFile) or not file(lcFile)
					lcError = lcError + iif(empty(lcError), '', ccCRLF) + ;
						'Invalid file specified in element ' + transform(lnI)
				endif vartype(lcFile) <> 'C' ...
			next lnI
			if not empty(lcError)
				This.cErrorMessage = lcError
				return .F.
			endif not empty(lcError)
		else
			This.cErrorMessage = 'Invalid files specified'
			return .F.
		endif type('taFiles', 1) = 'A'
		This.cErrorMessage = ''
		
		* Use the correct case for the files because some version control providers are
		* case-sensitive. For some file types, close it first.
		
		lnFiles = 0
		for lnI = 1 to alen(taFiles)
			lcFile = GetProperFileCase(taFiles[lnI])
			CloseFile(lcFile)
		
		* Determine what to remove.
		
			llRemoveFile = .T.
			lcOther      = GetVFPBinaryOtherFile(lcFile)
			llBinary     = not empty(lcOther) or IsVFPBinaryFile(lcFile)
		
		* This is a binary file and we're either only including text equivalents or
		* including both, so remove the text file and flag whether we're removing the
		* binary file.
		
			if llBinary and	This.nIncludeInVersionControl > 1
				lcTextFile = GetTextFileName(lcFile)
				lnFiles    = lnFiles + 1
				dimension laFiles[lnFiles]
				laFiles[lnFiles] = lcTextFile
				llRemoveFile     = This.nIncludeInVersionControl = 3
			endif llBinary ...
		
		* Remove the file from version control (including "other" files such as SCT)
		* and update its status.
		
			if llRemoveFile
				lnFiles = lnFiles + 1
				dimension laFiles[lnFiles]
				laFiles[lnFiles] = lcFile
				if not empty(lcOther)
					lnFiles = lnFiles + 1
					dimension laFiles[lnFiles]
					laFiles[lnFiles] = lcOther
					lcOther = GetVFPBinaryOtherFile(lcFile, .T.)
					if not empty(lcOther)
						lnFiles = lnFiles + 1
						dimension laFiles[lnFiles]
						laFiles[lnFiles] = lcOther
					endif not empty(lcOther)
				endif not empty(lcOther)
			endif llRemoveFile
		next lnI
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeRemoveFilesFromVersionControl', ;
			@laFiles)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* If everything is good so far, use the internal method to do the work.
		
		llReturn = This.RemoveFilesInternal(@laFiles)
		
		* If we're supposed to auto-commit changes, do so.
		
		if This.lAutoCommitChanges
			This.CommitFiles(This.cFileRemoveMessage, @laFiles, .T.)
		endif This.lAutoCommitChanges
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterRemoveFilesFromVersionControl', @laFiles)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE removefilesinternal		&& Removes several files from version control
		*==============================================================================
		* Method:			RemoveFileFromVersionControl
		* Status:			Protected
		* Purpose:			Removes the specified file from version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to remove
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the file was removed from version control
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcFile
		
	ENDPROC

	PROCEDURE renamefile		&& Renames the specified file in version control
		*==============================================================================
		* Method:			RenameFile
		* Status:			Public
		* Purpose:			Renames the specified file in version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile         - the name and path of the file to rename
		*					tcNewName      - the new name of the file (the stem part
		*						only)
		*					tcMessage      - the message to use for auto-commits
		*					tlNoAutoCommit - .T. to not auto-commit changes (overrides
		*						the setting of This.lAutoCommitChanges)
		* Returns:			.T. if it succeeded
		* Environment in:	This.nIncludeInVersionControl contains what to include in
		*						version control
		*					This.lAutoCommitChanges if we're supposed to auto-commit
		*					This.oAddins contains a reference to a ProjectAddins object
		*					the file has already been renamed so tcFile no longer
		*						exists while tcNewName does
		* Environment out:	the file was renamed in version control
		*					the change was committed if we're supposed to
		* Note:				this code assumes the file was already renamed in the file
		*						system
		*==============================================================================
		
		lparameters tcFile, ;
			tcNewName, ;
			tcMessage, ;
			tlNoAutoCommit
		local lcNewFile, ;
			lnFiles, ;
			llRenameFile, ;
			lcOther, ;
			llBinary, ;
			lcTextFile, ;
			laFiles[1], ;
			laNewNames[1], ;
			lnI, ;
			llReturn
		
		* Ensure we have valid files.
		
		if vartype(tcFile) <> 'C' or empty(tcFile) or file(tcFile)
			This.cErrorMessage = 'Invalid file specified'
			return .F.
		endif vartype(tcFile) <> 'C' ...
		if vartype(tcNewName) <> 'C' or empty(tcNewName)
			This.cErrorMessage = 'Invalid new file specified'
			return .F.
		endif vartype(tcNewName) <> 'C' ...
		
		* Get the new name of the file, using the correct case because some version
		* control providers are case-sensitive, and ensure it exists.
		
		lcNewFile = GetProperFileCase(ChangeFileName(tcFile, tcNewName))
		if not file(lcNewFile)
			This.cErrorMessage = 'Invalid new file specified'
			return .F.
		endif not file(lcNewFile)
		
		* Ensure a commit message was passed if we need it.
		
		if This.lAutoCommitChanges and not tlNoAutoCommit and ;
			(vartype(tcMessage) <> 'C' or empty(tcMessage))
			This.cErrorMessage = 'Invalid message specified.'
			return .F.
		endif This.lAutoCommitChanges ...
		This.cErrorMessage = ''
		
		* Determine what to rename. Note that we get the associated filename of the
		* renamed file because the original file doesn't exist anymore.
		
		lnFiles      = 0
		llRenameFile = .T.
		lcOther      = GetVFPBinaryOtherFile(lcNewFile)
		llBinary     = not empty(lcOther) or IsVFPBinaryFile(lcNewFile)
		
		* This is a binary file and we're either only including text equivalents or
		* including both, so rename the text file and flag whether we're renaming the
		* binary file.
		
		if llBinary and This.nIncludeInVersionControl > 1
			lcTextFile = GetTextFileName(tcFile)
			lnFiles    = lnFiles + 1
			dimension laFiles[lnFiles], laNewNames[lnFiles]
			laFiles[lnFiles]    = lcTextFile
			laNewNames[lnFiles] = ChangeFileName(lcTextFile, tcNewName)
			llRenameFile        = This.nIncludeInVersionControl = 3
		endif llBinary ...
		
		* Rename the file in version control, including associated files such as SCT.
		
		if llRenameFile
			lnFiles = lnFiles + 1
			dimension laFiles[lnFiles], laNewNames[lnFiles]
			laFiles[lnFiles]    = tcFile
			laNewNames[lnFiles] = lcNewFile
			if not empty(lcOther)
				lnFiles = lnFiles + 1
				dimension laFiles[lnFiles], laNewNames[lnFiles]
				laFiles[lnFiles]    = ChangeFileName(lcOther, juststem(tcFile))
				laNewNames[lnFiles] = lcOther
				lcOther = GetVFPBinaryOtherFile(lcNewFile, .T.)
				if not empty(lcOther)
					lnFiles = lnFiles + 1
					dimension laFiles[lnFiles], laNewNames[lnFiles]
					laFiles[lnFiles]    = ChangeFileName(lcOther, juststem(tcFile))
					laNewNames[lnFiles] = lcOther
				endif not empty(lcOther)
			endif not empty(lcOther)
		endif llRenameFile
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeRenameFileInVersionControl', tcFile, ;
				tcNewName)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* If everything is good so far, use the internal method to do the work.
		
		for lnI = 1 to lnFiles
			llReturn = This.RenameFileInternal(laFiles[lnI], laNewNames[lnI])
			if not llReturn
				exit
			endif not llReturn
		next lnI
		
		* If we're supposed to auto-commit changes, do so. Note that we have to commit
		* all changes since we can't list the original file.
		
		if llReturn and This.lAutoCommitChanges and not tlNoAutoCommit
			This.CommitAllFiles(tcMessage, , .T.)
		endif llReturn ...
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterRenameFileInVersionControl', tcFile, ;
				tcNewName)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE renamefileinternal		&& Renames the specified file in version control
		*==============================================================================
		* Method:			RenameFileInternal
		* Status:			Protected
		* Purpose:			Renames the specified file in version control
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile    - the name and path of the file to rename
		*					tcNewName - the new name of the file
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the files were renamed in version control
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcFile, ;
			tcNewName
		
	ENDPROC

	PROCEDURE repositorybrowser		&& Displays the repository browser
		*==============================================================================
		* Method:			RepositoryBrowser
		* Status:			Public
		* Purpose:			Displays the repository browser
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the repository browser was displayed
		*==============================================================================
		
		local llReturn
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeRepositoryBrowser')
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* Display the browser.
		
		llReturn = This.RepositoryBrowserInternal()
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterRepositoryBrowser')
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE repositorybrowserinternal		&& Displays the repository browser
		*==============================================================================
		* Method:			RepositoryBrowserInternal
		* Status:			Protected
		* Purpose:			Displays the repository browser
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* Abstract method.
		
	ENDPROC

	PROCEDURE revertfile		&& Reverts the specified file
		*==============================================================================
		* Method:			RevertFile
		* Status:			Public
		* Purpose:			Reverts the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to revert
		* Returns:			.T. if it succeeded
		* Environment in:	see This.RevertFiles
		* Environment out:	see This.RevertFiles
		*==============================================================================
		
		lparameters tcFile
		local laFiles[1]
		laFiles[1] = tcFile
		return This.RevertFiles(@laFiles)
		
	ENDPROC

	PROCEDURE revertfiles		&& Reverts several files
		*==============================================================================
		* Method:			RevertFiles
		* Status:			Public
		* Purpose:			Reverts several files
		* Author:			Doug Hennig
		* Last Revision:	09/15/2017
		* Parameters:		taFiles - an array of files to revert
		* Returns:			.T. if it succeeded
		* Environment in:	This.nIncludeInVersionControl contains what to include in
		*						version control
		*					This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the files were reverted
		*==============================================================================
		
		lparameters taFiles
		local lcError, ;
			lnI, ;
			lcFile, ;
			lnFiles, ;
			lnBinaryFiles, ;
			llRevert, ;
			lcOther, ;
			llBinary, ;
			lcTextFile, ;
			laFiles[1], ;
			laBinaryFiles[1], ;
			llReturn
		
		* A trick so the Project Manager doesn't complain.
		
		if .F.
			dimension taFiles[1]
		endif .F.
		
		* Ensure we have valid files.
		
		if type('taFiles', 1) = 'A'
			lcError = ''
			for lnI = 1 to alen(taFiles)
				lcFile = taFiles[lnI]
				if vartype(lcFile) <> 'C' or empty(lcFile) or not file(lcFile)
					lcError = lcError + iif(empty(lcError), '', ccCRLF) + ;
						'Invalid file specified in element ' + transform(lnI)
				endif vartype(lcFile) <> 'C' ...
			next lnI
			if not empty(lcError)
				This.cErrorMessage = lcError
				return .F.
			endif not empty(lcError)
		else
			This.cErrorMessage = 'Invalid files specified'
			return .F.
		endif type('taFiles', 1) = 'A'
		This.cErrorMessage = ''
		
		* Use the correct case for the files because some version control providers are
		* case-sensitive. For some file types, close it first.
		
		lnFiles       = 0
		lnBinaryFiles = 0
		for lnI = 1 to alen(taFiles)
			lcFile = GetProperFileCase(taFiles[lnI])
			taFiles[lnI] = lcFile
			CloseFile(lcFile)
		
		* Determine what to revert.
		
			llRevert = .T.
			lcOther  = GetVFPBinaryOtherFile(lcFile)
			llBinary = not empty(lcOther) or IsVFPBinaryFile(lcFile)
		
		* If this is a binary file and we're either only including text equivalents or
		* including both, revert the text file and flag whether we're reverting the
		* binary file. Store the name of the text file so we can regenerate the binary
		* files later.
		
			if llBinary and This.nIncludeInVersionControl > 1
				lcTextFile = GetTextFileName(lcFile)
				lnFiles    = lnFiles + 1
				dimension laFiles[lnFiles]
				laFiles[lnFiles] = lcTextFile
				llRevert         = This.nIncludeInVersionControl = 3
				lnBinaryFiles    = lnBinaryFiles + 1
				dimension laBinaryFiles[lnBinaryFiles]
				laBinaryFiles[lnBinaryFiles] = lcTextFile
			endif llBinary ...
		
		* Revert the file (including "other" files such as SCT).
		
			if llRevert
				lnFiles = lnFiles + 1
				dimension laFiles[lnFiles]
				laFiles[lnFiles] = lcFile
				if not empty(lcOther)
					lnFiles = lnFiles + 1
					dimension laFiles[lnFiles]
					laFiles[lnFiles] = lcOther
					lcOther = GetVFPBinaryOtherFile(lcFile, .T.)
					if not empty(lcOther)
						lnFiles = lnFiles + 1
						dimension laFiles[lnFiles]
						laFiles[lnFiles] = lcOther
					endif not empty(lcOther)
				endif not empty(lcOther)
			endif llRevert
		next lnI
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeRevertFiles', @laFiles)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* If everything is good so far, use the internal method to do the work.
		
		llReturn = This.RevertFilesInternal(@laFiles)
		
		* If it succeeded and we reverted only the text equivalents, regenerate the
		* binary files.
		
		if llReturn and This.nIncludeInVersionControl = 2
			for lnI = 1 to lnBinaryFiles
				This.ConvertBinaryToText(laBinaryFiles[lnI])
			next lnI
		endif llReturn ...
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterRevertFiles', @laFiles)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE revertfilesinternal		&& Reverts several files
		*==============================================================================
		* Method:			RevertFileInternal
		* Status:			Protected
		* Purpose:			Reverts the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/28/2017
		* Parameters:		tcFile - the name and path of the file to revert
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the file was reverted
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcFile
		
	ENDPROC

	PROCEDURE revisionhistory		&& Display the revision history for the specified file
		*==============================================================================
		* Method:			RevisionHistory
		* Status:			Public
		* Purpose:			Display the revision history for the specified file
		* Author:			Doug Hennig
		* Last Revision:	04/20/2017
		* Parameters:		tcFile - the name and path of the file to display revision
		*						history for
		* Returns:			.T. if it succeeded
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the revision history was displayed
		*==============================================================================
		
		lparameters tcFile
		local lcFile, ;
			llReturn
		
		* Ensure we have a valid file.
		
		if vartype(tcFile) <> 'C' or empty(tcFile) or not file(tcFile)
			This.cErrorMessage = 'Invalid file specified.'
			return .F.
		endif vartype(tcFile) <> 'C' ...
		This.cErrorMessage = ''
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeRevisionHistory', tcFile)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* Use the correct case for the files because some version control providers are
		* case-sensitive.
		
		lcFile = GetProperFileCase(tcFile)
		
		* If this is a binary file and we're only including text equivalents, use the
		* text file.
		
		lcFile = GetTextFileName(lcFile)
		if empty(lcFile) or This.nIncludeInVersionControl <> 2
			lcFile = tcFile
		endif empty(lcFile) ...
		
		* Display the revision history.
		
		llReturn = This.RevisionHistoryInternal(lcFile)
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterRevisionHistory', tcFile)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE revisionhistoryinternal		&& Display the revision history for the specified file
		*==============================================================================
		* Method:			RevisionHistoryInternal
		* Status:			Protected
		* Purpose:			Display the revision history for the specified file
		* Author:			Doug Hennig
		* Last Revision:	03/17/2017
		* Parameters:		tcFile - the name and path of the file to display revision
		*						history for
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the revision history was displayed
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcFile
		
	ENDPROC

	PROCEDURE visualdiff		&& Displays the visual diff for the file
		*==============================================================================
		* Method:			VisualDiff
		* Status:			Public
		* Purpose:			Displays the visual diff for the file
		* Author:			Doug Hennig
		* Last Revision:	04/20/2017
		* Parameters:		tcFile - the name and path of the file to display the
		*						visual diff for
		* Returns:			.T. if it succeeded
		* Environment in:	This.oAddins contains a reference to a ProjectAddins object
		* Environment out:	the visual diff was displayed
		*==============================================================================
		
		lparameters tcFile
		local lcFile, ;
			llReturn
		
		* Ensure we have a valid file.
		
		if vartype(tcFile) <> 'C' or empty(tcFile) or not file(tcFile)
			This.cErrorMessage = 'Invalid file specified.'
			return .F.
		endif vartype(tcFile) <> 'C' ...
		This.cErrorMessage = ''
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O' and ;
			not This.oAddins.ExecuteAddin('BeforeVisualDiff', tcFile)
			return .F.
		endif vartype(This.oAddins) = 'O' ...
		
		* Use the correct case for the files because some version control providers are
		* case-sensitive.
		
		lcFile = GetProperFileCase(tcFile)
		
		* If this is a binary file and we're only including text equivalents, use the
		* text file.
		
		lcFile = GetTextFileName(lcFile)
		if empty(lcFile) or This.nIncludeInVersionControl <> 2
			lcFile = tcFile
		endif empty(lcFile) ...
		
		* Display the visual diff
		
		llReturn = This.VisualDiffInternal(lcFile)
		
		* Execute any addin.
		
		if vartype(This.oAddins) = 'O'
			This.oAddins.ExecuteAddin('AfterVisualDiff', tcFile)
		endif vartype(This.oAddins) = 'O'
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE visualdiffinternal		&& Displays the visual diff for the file
		*==============================================================================
		* Method:			VisualDiffInternal
		* Status:			Protected
		* Purpose:			Displays the visual diff for the file
		* Author:			Doug Hennig
		* Last Revision:	03/17/2017
		* Parameters:		tcFile - the name and path of the file to display the
		*						visual diff for
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	the visual diff was displayed
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcFile
		
	ENDPROC

ENDDEFINE
