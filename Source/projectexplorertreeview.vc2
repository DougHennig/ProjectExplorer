*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="projectexplorertreeview.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS projectexplorertreeviewcontainer AS projectexplorercontainer OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oTree" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oImageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrSync" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrReload" UniqueID="" Timestamp="" />

	#INCLUDE "projectexplorertreeview.h"
	*<DefinedPropArrayMethod>
		*m: calctwipsperpixel		&& Calculate the conversion factor between VFP window units (in pixels) and TreeView window units (in twips)
		*m: candrop		&& Returns .T. if the specified source can be dropped on the specified node
		*m: canstartdrag		&& Returns .T. if the current node in the TreeView can be dragged
		*m: createnodeobject		&& Returns an object with properties about a node in the TreeView
		*m: deletenode		&& Deletes the selected node
		*m: executenode		&& Called when the user presses Enter for a node if lAllowEnter is .T.
		*m: fontname_assign
		*m: fontsize_assign
		*m: getchildnodes		&& Fills the passed collection with objects containing properties about the child nodes of the specified node
		*m: getdragdropdataobject		&& Returns an object with properties about a dragged object and the node it's dropped on
		*m: getnodeitemfromnode		&& Returns a node item object from the specified TreeView node
		*m: getnodeundermouse		&& Returns a reference to the node under the mouse
		*m: getregistrykey		&& Gets the Registry key to use
		*m: getrootnodes		&& Fills the passed collection with objects containing properties about the root nodes
		*m: gettypeandidfromnode		&& Returns an object containing Type and ID properties for the specified node
		*m: goback		&& Goes back to the previously selected node
		*m: handledragdrop		&& Handles the completion of a DragDrop operation
		*m: insertnode		&& Inserts a new node
		*m: loadexpandednode		&& Loads the children for the specified node
		*m: loadimages		&& Loads the ImageList control with desired images
		*m: loadnode		&& Loads the specified node into the TreeView
		*m: loadnodechildren		&& Loads the children of the specified node
		*m: loadtree		&& Loads the TreeView
		*m: locktreeview		&& Locks the TreeView so updates don't appear immediately
		*m: nodeclicked		&& Called when a node is clicked
		*m: oselectednode_access
		*m: pushkey		&& Pushes the specified key onto the stack
		*m: removenode		&& Removes the selected node
		*m: restoreselectednode		&& Restores the selected node from whereever it was saved when this was last used
		*m: saveselectednode		&& Saves the selected node so it can be restored at restart
		*m: selectnode		&& Selects the specified node
		*m: treeafterlabeledit		&& Called after the text of a node has been edited in the TreeView
		*m: treebeforelabeledit		&& Called before the text of a node is edited in the TreeView
		*m: treedblclick		&& Fired when the user double-clicks on the TreeView
		*m: treeexpand		&& Called when a node is expanded in the TreeView
		*m: treekeydown		&& Called when a key is pressed when the TreeView has focus
		*m: treemousedown		&& Called when a mouse button is pressed over the TreeView
		*m: treemouseup		&& Called when a mouse button is released over the TreeView
		*m: treenodecheck		&& Called when a node is checked in the TreeView
		*m: treenodeclick		&& Called when a node is selected in the TreeView
		*m: treeolecompletedrag		&& Called when an OLECompleteDrag events occurs in the TreeView
		*m: treeoledragdrop		&& Called when an OLEDragDrop event occurs in the TreeView
		*m: treeoledragover		&& Called when an OLEDragOver event occurs in the TreeView
		*m: treeolegivefeedback		&& Called when an OLEGiveFeedback event occurs in the TreeView
		*m: treeolestartdrag		&& Called when an OLEStartDrag event occurs in the TreeView
		*m: visible_assign
		*p: ccurrentnodeid		&& The ID of the currently selected node
		*p: ccurrentnodekey		&& The key of the currently selected node
		*p: ccurrentnodetype		&& The type of the currently selected node
		*p: clastnode		&& The key for the node selected the last time this container was used
		*p: cregistryclass		&& The class to use for Registry handling
		*p: cregistrykey		&& The key used to persist expanded and selected nodes
		*p: cregistrykeysuffix		&& The subnode to use under the parent form's Registry key to store values for this control
		*p: cregistrylibrary		&& The library the cRegistryClass is located in
		*p: fontname		&& The font name for the TreeView
		*p: fontsize		&& The font size for the TreeView
		*p: lallowdelete		&& .T. if the user can delete a node by pressing Delete
		*p: lallowenter		&& .T. to allow pressing Enter on a node to execute some behavior
		*p: lallowinsert		&& .T. if the user can insert a node by pressing Insert
		*p: lallowrename		&& .T. if the user can rename a node
		*p: lautoloadchildren		&& .T. if child nodes are loaded when the TreeView is loaded
		*p: ldraginprogress		&& .T. if a drag operation is in progress
		*p: lexpanded		&& .T. if the selected node should be expanded or not (double-clicking on a node causes it to be expanded when it shouldn't)
		*p: lexpanding		&& .T. if we're expanding a node
		*p: lexpandondblclick		&& .T. to expand a parent node on a double-click
		*p: linitialized		&& .T. once all the tasks in Init are done
		*p: lloadtreeviewatstartup		&& .T. to load the TreeView control when the container is instantiated
		*p: lneedreload		&& .T. if LoadTree was called during a drag operation, meaning we need to call it again after the drag is complete
		*p: ltracknodeclicks		&& .T. to push node clicks onto a stack so we can provide "go back" functionality
		*p: ltreeviewlocked		&& .T. if the TreeView window is locked
		*p: lusepathaskey		&& .T. to use the path of a node as its key
		*p: nautoexpand		&& The level to which nodes are expanded when the TreeView is loaded
		*p: nnodeclick		&& The time the selected node was clicked (used for double-clicking)
		*p: ntimerinterval		&& The timer interval for tmrSync (temporary holding property)
		*p: ntreefactorx		&& The horizontal conversion factor for twips to pixels
		*p: ntreefactory		&& The vertical conversion factor for twips to pixels
		*p: oregistry		&& An object for handling the Windows Registry
		*p: oselectednode		&& A reference to the selected node in the TreeView
		*p: ostack		&& A reference to a stack object
		*a: aexpandednodes[1,0]		&& An array containing the FullPath of expanded nodes
	*</DefinedPropArrayMethod>

	PROTECTED ldraginprogress,lexpanded,nnodeclick,ntreefactorx,ntreefactory
	BackStyle = 1
	BorderColor = 255,255,255
	ccurrentnodeid = 		&& The ID of the currently selected node
	ccurrentnodekey = 		&& The key of the currently selected node
	ccurrentnodetype = 		&& The type of the currently selected node
	clastnode = 		&& The key for the node selected the last time this container was used
	cregistryclass = ProjectExplorerRegistry		&& The class to use for Registry handling
	cregistrykey = 		&& The key used to persist expanded and selected nodes
	cregistrykeysuffix = 		&& The subnode to use under the parent form's Registry key to store values for this control
	cregistrylibrary = ProjectExplorerRegistry.vcx		&& The library the cRegistryClass is located in
	fontname = Tahoma		&& The font name for the TreeView
	fontsize = 9		&& The font size for the TreeView
	Height = 200
	lallowdelete = .F.		&& .T. if the user can delete a node by pressing Delete
	lallowenter = .F.		&& .T. to allow pressing Enter on a node to execute some behavior
	lallowinsert = .F.		&& .T. if the user can insert a node by pressing Insert
	lallowrename = .F.		&& .T. if the user can rename a node
	lautoloadchildren = .F.		&& .T. if child nodes are loaded when the TreeView is loaded
	ldraginprogress = .F.		&& .T. if a drag operation is in progress
	lexpanded = .F.		&& .T. if the selected node should be expanded or not (double-clicking on a node causes it to be expanded when it shouldn't)
	lexpanding = .F.		&& .T. if we're expanding a node
	lexpandondblclick = .F.		&& .T. to expand a parent node on a double-click
	linitialized = .F.		&& .T. once all the tasks in Init are done
	lloadtreeviewatstartup = .T.		&& .T. to load the TreeView control when the container is instantiated
	lneedreload = .F.		&& .T. if LoadTree was called during a drag operation, meaning we need to call it again after the drag is complete
	lsaveanchor = .F.
	ltracknodeclicks = .T.		&& .T. to push node clicks onto a stack so we can provide "go back" functionality
	ltreeviewlocked = .F.		&& .T. if the TreeView window is locked
	lusepathaskey = .T.		&& .T. to use the path of a node as its key
	Name = "projectexplorertreeviewcontainer"
	nautoexpand = 0		&& The level to which nodes are expanded when the TreeView is loaded
	nnodeclick = 0		&& The time the selected node was clicked (used for double-clicking)
	ntimerinterval = 0		&& The timer interval for tmrSync (temporary holding property)
	ntreefactorx = 0		&& The horizontal conversion factor for twips to pixels
	ntreefactory = 0		&& The vertical conversion factor for twips to pixels
	oregistry = .NULL.		&& An object for handling the Windows Registry
	oselectednode = .NULL.		&& A reference to the selected node in the TreeView
	ostack = .NULL.		&& A reference to a stack object
	Visible = .T.
	Width = 210
	_memberdata = <VFPData>
		<memberdata name="aexpandednodes" type="property" display="aExpandedNodes"/>
		<memberdata name="calctwipsperpixel" type="method" display="CalcTwipsPerPixel"/>
		<memberdata name="candrop" type="method" display="CanDrop"/>
		<memberdata name="canstartdrag" type="method" display="CanStartDrag"/>
		<memberdata name="ccurrentnodeid" type="property" display="cCurrentNodeID"/>
		<memberdata name="ccurrentnodekey" type="property" display="cCurrentNodeKey"/>
		<memberdata name="ccurrentnodetype" type="property" display="cCurrentNodeType"/>
		<memberdata name="clastnode" type="property" display="cLastNode"/>
		<memberdata name="createnodeobject" type="method" display="CreateNodeObject"/>
		<memberdata name="getchildnodes" type="method" display="GetChildNodes"/>
		<memberdata name="getdragdropdataobject" type="method" display="GetDragDropDataObject"/>
		<memberdata name="getnodeitemfromnode" type="method" display="GetNodeItemFromNode"/>
		<memberdata name="getrootnodes" type="method" display="GetRootNodes"/>
		<memberdata name="gettypeandidfromnode" type="method" display="GetTypeAndIDFromNode"/>
		<memberdata name="handledragdrop" type="method" display="HandleDragDrop"/>
		<memberdata name="insertnode" type="method" display="InsertNode"/>
		<memberdata name="lallowdelete" type="property" display="lAllowDelete"/>
		<memberdata name="lallowinsert" type="property" display="lAllowInsert"/>
		<memberdata name="lautoloadchildren" type="property" display="lAutoLoadChildren"/>
		<memberdata name="lexpanded" type="property" display="lExpanded"/>
		<memberdata name="lloadtreeviewatstartup" type="property" display="lLoadTreeviewAtStartup"/>
		<memberdata name="loadexpandednode" type="method" display="LoadExpandedNode"/>
		<memberdata name="loadimages" type="method" display="LoadImages"/>
		<memberdata name="loadnode" type="method" display="LoadNode"/>
		<memberdata name="loadnodechildren" type="method" display="LoadNodeChildren"/>
		<memberdata name="loadtree" type="method" display="LoadTree"/>
		<memberdata name="locktreeview" type="method" display="LockTreeview"/>
		<memberdata name="lusepathaskey" type="property" display="lUsePathAsKey"/>
		<memberdata name="nautoexpand" type="property" display="nAutoExpand"/>
		<memberdata name="nnodeclick" type="property" display="nNodeClick"/>
		<memberdata name="nodeclicked" type="method" display="NodeClicked"/>
		<memberdata name="ntreefactorx" type="property" display="nTreeFactorX"/>
		<memberdata name="ntreefactory" type="property" display="nTreeFactorY"/>
		<memberdata name="oselectednode" type="property" display="oSelectedNode"/>
		<memberdata name="oselectednode_access" type="method" display="oSelectedNode_Access"/>
		<memberdata name="removenode" type="method" display="RemoveNode"/>
		<memberdata name="restoreselectednode" type="method" display="RestoreSelectedNode"/>
		<memberdata name="saveselectednode" type="method" display="SaveSelectedNode"/>
		<memberdata name="selectnode" type="method" display="SelectNode"/>
		<memberdata name="startdrag" type="method" display="StartDrag"/>
		<memberdata name="treeafterlabeledit" type="method" display="TreeAfterLabelEdit"/>
		<memberdata name="treebeforelabeledit" type="method" display="TreeBeforeLabelEdit"/>
		<memberdata name="treedblclick" type="method" display="TreeDblClick"/>
		<memberdata name="treeexpand" type="method" display="TreeExpand"/>
		<memberdata name="treekeydown" type="method" display="TreeKeyDown"/>
		<memberdata name="treemousedown" type="method" display="TreeMouseDown"/>
		<memberdata name="treemouseup" type="method" display="TreeMouseUp"/>
		<memberdata name="treenodecheck" type="method" display="TreeNodeCheck"/>
		<memberdata name="treenodeclick" type="method" display="TreeNodeClick"/>
		<memberdata name="treeolecompletedrag" type="method" display="TreeOLECompleteDrag"/>
		<memberdata name="treeoledragdrop" type="method" display="TreeOLEDragDrop"/>
		<memberdata name="treeoledragover" type="method" display="TreeOLEDragOver"/>
		<memberdata name="treeolestartdrag" type="method" display="TreeOLEStartDrag"/>
		<memberdata name="deletenode" type="method" display="DeleteNode"/>
		<memberdata name="lexpandondblclick" type="property" display="lExpandOnDblClick"/>
		<memberdata name="lallowrename" type="property" display="lAllowRename"/>
		<memberdata name="cregistrykey" type="property" display="cRegistryKey"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="method" display="lSaveAnchor_Assign"/>
		<memberdata name="cregistrykeysuffix" type="property" display="cRegistryKeySuffix"/>
		<memberdata name="linitialized" type="property" display="lInitialized"/>
		<memberdata name="goback" type="method" display="GoBack"/>
		<memberdata name="pushkey" type="method" display="PushKey"/>
		<memberdata name="ltracknodeclicks" type="property" display="lTrackNodeClicks"/>
		<memberdata name="getnodeundermouse" type="method" display="GetNodeUnderMouse"/>
		<memberdata name="ldraginprogress" type="property" display="lDragInProgress"/>
		<memberdata name="ntimerinterval" type="property" display="nTimerInterval"/>
		<memberdata name="cregistryclass" display="cRegistryClass"/>
		<memberdata name="cregistrylibrary" display="cRegistryLibrary"/>
		<memberdata name="oregistry" display="oRegistry"/>
		<memberdata name="treeolegivefeedback" display="TreeOLEGiveFeedback"/>
		<memberdata name="getregistrykey" display="GetRegistryKey"/>
		<memberdata name="lneedreload" display="lNeedReload"/>
		<memberdata name="ltreeviewlocked" display="lTreeViewLocked"/>
		<memberdata name="lexpanding" display="lExpanding"/>
		<memberdata name="fontname" display="FontName"/>
		<memberdata name="fontname_assign" display="FontName_Assign"/>
		<memberdata name="fontsize" display="FontSize"/>
		<memberdata name="fontsize_assign" display="FontSize_Assign"/>
		<memberdata name="lallowenter" display="lAllowEnter"/>
		<memberdata name="executenode" display="ExecuteNode"/>
		<memberdata name="visible" display="Visible"/>
		<memberdata name="visible_assign" display="Visible_Assign"/>
		<memberdata name="ostack" display="oStack"/>
		</VFPData>

	ADD OBJECT 'oImageList' AS olecontrol WITH ;
		Left = 160, ;
		Name = "oImageList", ;
		Top = 0, ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\syswow64\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7////+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALCHOXsf2NMBAwAAAEABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXAAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAD0AAAAAAAAABAAAAAIAAAD+/////v////7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8jfyQskYXREbFqAMDwKDYoIUM0EggAAADtAwAA7QMAAIB+4eYAAAYAIAAAABEADwDAwMAA//85AAHvzasAAAUAXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTEuAFcAZgAhAFQAPwBnACgAWgAxAHoAPwBWAFgAQgBdADIAZAABAACADAAAAEltYWdlSGVpZ2h0AAkAAABJCgAAAA8AAAALAAAASW1hZ2VXaWR0aAAJAAAASQoAAAARAAAAADEAAAAAAAYAeQD/////BQAAgJTpGQAAAAAAAAAAACcANgA2AEEAWQBQAHEANgBvAHMAKgB1AHYALgBTAFMALgBXAGYAIQBUAD8AZwAoAFoAMQB6AD8AVgBYAEIAXQAyAGQAXgBfAEUAWwBnACEAQgAyAGcAKABTAHYAeQA/AFYAWABCAF0AMgBkAE4APQBsAGQALQB5AGcAMABnACgAUABtAHkAPwBWAFgAQgBdADIAZABgAFMALgBXAGYAIQBUAD8AZwAoAFoAMQB6AD8AVgBYAEIAXQAyAGQAXQBTAC4AVwBmACEAVAA/AGcAKABaADEAegA/AFYAWABCAF0AMgBkAA==" />

	ADD OBJECT 'oTree' AS olecontrol WITH ;
		Anchor = 15, ;
		Height = 200, ;
		Name = "oTree", ;
		Width = 210, ;
		ZOrderSet = 0
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\syswow64\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7///8EAAAA/v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBgOXsf2NMBAwAAAMACAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiwAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAEQBAAAAAAAABAAAAAIAAAD+////BQAAAAoAAAAGAAAABwAAAAgAAAAJAAAA/v////7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+2kEHHiYXREbFqAMDwKDYoIUM0EggAAAC0FQAArBQAALE8wWoBAAYAIgAAAF0ANgAJAQAATABQAAEAAAAB782rXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTEAAAAAQPYAAAAAAACUAQEAAAAAAFACAQAAAAAABAMBAAAAAAABAACADgAAAEhpZGVTZWxlY3Rpb24ABQAAAEwAAAAADAAAAEluZGVudGF0aW9uABEAAABODQAAAAcAAAAAAAAAAAAFAADEyQsDKHkAAAAAAAUAAIBM6RkAAQAAAFwAH97svQEABQCV6RkAA1LjC5GPzhGd4wCqAEu4UQEAAACQAQAAJEAKAAAATGFiZWxFZGl0AAkAAABJCgAAAAAAAAAKAAAATGluZVN0eWxlAAkAAABJCgAAAAEAAAANAAAATW91c2VQb2ludGVyAAkAAABJCgAAAAAAAAAOAAAAUGF0aFNlcGFyYXRvcgAKAAAASAAAAAABAAAAXAwAAABPTEVEcmFnTW9kZQAJAAAASQoAAAABAAAADAAAAE9MRURyb3BNb2RlAAkAAABJCgAAAAEAAAALAAAAQXBwZWFyYW5jZQAJAAAASQoAAAAAAAAADAAAAEJvcmRlclN0eWxlAAkAAABJCgAAAAEAAAAMAAAASG90VHJhY2tpbmcABQAAAEwBAAAAAAAAAAAAAAAAAAAAAAAAAFgCAABQEQAA9CMAAAAAAAC8GAAAAAAAAAAAAAD/////AQBUAAQAAAABAAAAkF8BAAZUYWhvbWH/JSIbAJiVAAAAAAAA/////wMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAgAAEgAAAKgmAAAAAAAA/////wAAAAAAAAAA/////wEAAAAEAAAAUAEAAAAAAAAAAAAA/////zQiHACYlQAAQAEAANgAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAiAIAAFARAADEJgAAAAAAANwYAAAAAAAAAAAAAP////8BACgABAAAAAEAAAACAAcAAAAAAP////80Ih0ARJYAAEABAAAwAQAAAwAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAKACAABQEQAAKCcAAAAAAAAoGQAAAAAAAAAAAAD/////AQAsAAQAAAABAAAAAgAHAAAAAAD/////NCIeADSXAAAADAAAuAcAAAMAAAAAAAAAGwAAAAAAAAAAAAAAAAAAAAAAAAC4AgAAUBEAAIAnAAAAAAAAsBkAAAAAAAAAAAAA" />

	ADD OBJECT 'tmrReload' AS projectexplorertimer WITH ;
		Enabled = .F., ;
		Interval = 200, ;
		Left = 162, ;
		Name = "tmrReload", ;
		Top = 111
		*< END OBJECT: ClassLib="projectexplorerctrls.vcx" BaseClass="timer" />

	ADD OBJECT 'tmrSync' AS projectexplorertimer WITH ;
		Interval = 1500, ;
		Left = 160, ;
		Name = "tmrSync", ;
		Top = 49
		*< END OBJECT: ClassLib="projectexplorerctrls.vcx" BaseClass="timer" />
	
	PROTECTED PROCEDURE calctwipsperpixel		&& Calculate the conversion factor between VFP window units (in pixels) and TreeView window units (in twips)
		* Calculate the conversion factor between VFP window units (in pixels) and
		* TreeView window units (in twips).
		
		local liHWnd, ;
			liHDC, ;
			liPixelsPerInchX, ;
			liPixelsPerInchY
		
		* Declare some Windows API functions.
		
		declare integer GetDC         in Win32API ;
			integer iHDC
		declare integer GetDeviceCaps in Win32API ;
			integer iHDC, integer iIndex
		declare integer ReleaseDC     in Win32API ;
			integer ihWnd, integer iHDC
		
		* Get a device context for VFP.
		
		liHWnd = _vfp.hWnd
		liHDC  = GetDC(liHWnd)
		
		* Get the pixels per inch.
		
		liPixelsPerInchX = GetDeviceCaps(liHDC, cnLOG_PIXELS_X)
		liPixelsPerInchY = GetDeviceCaps(liHDC, cnLOG_PIXELS_Y)
		
		* Get the twips per pixel.
		
		with This
			.nTreeFactorX = cnTWIPS_PER_INCH/liPixelsPerInchX
			.nTreeFactorY = cnTWIPS_PER_INCH/liPixelsPerInchY
		endwith
		
		* Clean up.
		
		ReleaseDC(liHWnd, liHDC)
		
	ENDPROC

	PROCEDURE candrop		&& Returns .T. if the specified source can be dropped on the specified node
		* This method is abstract here, but would typically look at toObject.DragType
		* and toObject.DropType to see if the source has data that the node the mouse
		* is over can accept, and if so, return .T. toData is the OLE drag and drop
		* data object, toNode is a reference to the target node, toObject is an object
		* containing the type and keys of the dragged object and the target node (see
		* GetDragDropDataObject for its properties). tnEffect should also be set based
		* on the type, if any, of drop allowed.
		
		lparameters toData, ;
			toNode, ;
			toObject, ;
			tnEffect, ;
			tnButton, ;
			tnShift
		return .F.
		
	ENDPROC

	PROCEDURE canstartdrag		&& Returns .T. if the current node in the TreeView can be dragged
		* Abstract method. This should return .T. if we can start a drag from the
		* selected node.
		
		return .F.
		
	ENDPROC

	PROCEDURE createnodeobject		&& Returns an object with properties about a node in the TreeView
		local loNodeItem
		loNodeItem = createobject('Empty')
		addproperty(loNodeItem, 'Key',           sys(2015))
		addproperty(loNodeItem, 'Text',          '')
		addproperty(loNodeItem, 'Image',         '')
		addproperty(loNodeItem, 'SelectedImage', '')
		addproperty(loNodeItem, 'ExpandedImage', '')
		addproperty(loNodeItem, 'Sorted',        .F.)
		addproperty(loNodeItem, 'HasChildren',   .F.)
		addproperty(loNodeItem, 'ForeColor',     rgb(  0,   0,   0))
		addproperty(loNodeItem, 'BackColor',     rgb(255, 255, 255))
		addproperty(loNodeItem, 'Bold',          .F.)
		return loNodeItem
		
	ENDPROC

	PROCEDURE deletenode		&& Deletes the selected node
		* Abstract method: called from TreeKeyDown when Delete is pressed
		
	ENDPROC

	PROCEDURE Destroy
		* Save the last expanded and selected nodes.
		
		This.SaveSelectedNode()
		
		* Nuke member objects.
		
		This.oStack = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE enabled_assign
		lparameters tlEnabled
		dodefault(tlEnabled)
		This.oTree.Object.Enabled = tlEnabled
		
	ENDPROC

	PROCEDURE executenode		&& Called when the user presses Enter for a node if lAllowEnter is .T.
		* Abstract method: called from TreeKeyDown when Enter is pressed
		
	ENDPROC

	PROCEDURE fontname_assign
		lparameters tcValue
		This.FontName        = tcValue
		This.oTree.Font.Name = tcValue
		
	ENDPROC

	PROCEDURE fontsize_assign
		lparameters tnValue
		This.FontSize        = tnValue
		This.oTree.Font.Size = tnValue
		
	ENDPROC

	PROCEDURE getchildnodes		&& Fills the passed collection with objects containing properties about the child nodes of the specified node
		* This method is abstract here, but would typically look like this:
		* loNodeItem = This.CreateNodeObject()
		* with loNodeItem
		*	.Text          = 'whatever'
		*	.Image         = 'image name or number'
		*	.SelectedImage = 'selected image name or number; use same as Image if not different'
		*	.ExpandedImage = 'expanded image name or number; use same as Image or blank if not different'
		*	.Sorted        = .T. if it should be sorted
		*	.HasChildren   = .T. if there are any child nodes
		* endwith
		* toCollection.Add(loNodeItem)
		* repeat for other nodes
		
		lparameters tcType, ;
			tcID, ;
			toCollection
		
	ENDPROC

	PROCEDURE getdragdropdataobject		&& Returns an object with properties about a dragged object and the node it's dropped on
		* In a subclass, use DODEFAULT() to get the empty object, then make any changes
		* necessary to the property values.
		
		lparameters toNode, ;
			toData, ;
			tnButton, ;
			tnShift
		local loObject, ;
			loDataObject, ;
			lcData, ;
			lnPos, ;
			lcFile
		loObject = createobject('Empty')
		addproperty(loObject, 'Data',     '')
		addproperty(loObject, 'DropType', '')
		addproperty(loObject, 'DropKey',  '')
		addproperty(loObject, 'DragType', '')
		addproperty(loObject, 'DragKey',  '')
		addproperty(loObject, 'Button',   tnButton)
		addproperty(loObject, 'Shift',    tnShift)
		with loObject
			if vartype(toNode) = 'O'
				loDataObject = This.GetTypeAndIDFromNode(toNode)
				.DropType    = loDataObject.Type
				.DropKey     = loDataObject.ID
			endif vartype(toNode) = 'O'
			try
				do case
					case toData.GetFormat(CF_MAX)
						lcData    = toData.GetData(CF_MAX)
						lnPos     = at(':', lcData)
						.Data     = lcData
						.DragType = '' + left(lcData, lnPos - 1)
						.DragKey  = '' + substr(lcData, lnPos + 1)
					case toData.GetFormat(CF_TEXT)
						lcData    = toData.GetData(CF_TEXT)
						.Data     = lcData
						.DragType = 'Text'
					case toData.GetFormat(CF_FILES)
						addproperty(loObject, 'Files', createobject('Collection'))
						for each lcFile in toData.Files foxobject
							loObject.Files.Add(lcFile)
						next lcFile
						.DragType = 'ImportFiles'
				endcase
			catch
			endtry
		endwith
		return loObject
		
	ENDPROC

	PROCEDURE getnodeitemfromnode		&& Returns a node item object from the specified TreeView node
		* Return a node item object from the specified TreeView node.
		
		lparameters toNode
		loNodeItem = This.CreateNodeObject()
		with loNodeItem
			.Key           = toNode.Key
			.Text          = toNode.Text
			.Image         = toNode.Image
			.SelectedImage = toNode.SelectedImage
			.Sorted        = toNode.Sorted
			.HasChildren   = toNode.Children > 0
		endwith
		return loNodeItem
		
	ENDPROC

	PROCEDURE getnodeundermouse		&& Returns a reference to the node under the mouse
		* Return the node the user clicked on. Note that clicking the mouse to the
		* right of a node's caption won't select that node, so we'll check everywhere
		* starting from the leftmost edge of the TreeView to find the node, thanks to
		* code written by Sergey Berezniker.
		
		lparameters tnXCoord, ;
			tnYCoord
		local loNode
		with This
			loNode = .oTree.HitTest(tnXCoord * .nTreeFactorX, ;
				tnYCoord * .nTreeFactorY)
			if vartype(loNode) <> 'O'
				for lnI = 1 to tnXCoord
					loNode = .oTree.HitTest(lnI * .nTreeFactorX, ;
						tnYCoord * .nTreeFactorY)
					if vartype(loNode) = 'O'
						exit
					endif vartype(loNode) = 'O'
				next lnI
			endif vartype(loNode) <> 'O'
		endwith
		return loNode
		
	ENDPROC

	PROCEDURE getregistrykey		&& Gets the Registry key to use
		local lcKey
		with This
			do case
		
		* If we have a Registry key to use, do so.
		
				case not empty(.cRegistryKey)
					lcKey = .cRegistryKey
		
		* If our form has a Registry key and we're supposed to add a suffix to it, do
		* so.
		
				case pemstatus(Thisform, 'cRegistryKey', 5) and ;
					not empty(Thisform.cRegistryKey)
					lcKey = addbs(Thisform.cRegistryKey) + .cRegistryKeySuffix
		
		* We don't have a key.
		
				otherwise
					lcKey = ''
			endcase
		endwith
		return lcKey
		
	ENDPROC

	PROCEDURE getrootnodes		&& Fills the passed collection with objects containing properties about the root nodes
		* This method is abstract here, but would typically look like this:
		* loNodeItem = This.CreateNodeObject()
		* with loNodeItem
		*	.Text          = 'whatever'
		*	.Image         = 'image name or number'
		*	.SelectedImage = 'selected image name or number; use same as Image if not different'
		*	.ExpandedImage = 'expanded image name or number; use same as Image or blank if not different'
		*	.Sorted        = .T. if it should be sorted
		*	.HasChildren   = .T. if there are any child nodes
		* endwith
		* toCollection.Add(loNodeItem)
		* repeat for other nodes
		
		lparameters toCollection
		
	ENDPROC

	PROCEDURE gettypeandidfromnode		&& Returns an object containing Type and ID properties for the specified node
		* In a subclass, use DODEFAULT() to get the empty object, then fill in the Type
		* and ID properties.
		
		lparameters toNode
		local loObject
		loObject = createobject('Empty')
		addproperty(loObject, 'Type')
		addproperty(loObject, 'ID')
		return loObject
		
	ENDPROC

	PROCEDURE goback		&& Goes back to the previously selected node
		* Go back to the previously selected node by popping it off the stack. If the
		* node no longer exists, no harm done since SelectNode won't do anything in
		* that case.
		
		lparameters tcKey
		local lcKey
		lcKey = iif(empty(tcKey), This.oStack.Pop(), tcKey)
		This.SelectNode(lcKey, .T.)
		
	ENDPROC

	PROCEDURE handledragdrop		&& Handles the completion of a DragDrop operation
		* This method is abstract here, but would typically call toData.GetFormat and
		* toData.GetData to get the data from the source object and somehow apply it to
		* the node it was dropped on, toNode. toObject is an object containing the type
		* and keys of the dragged object and the target node (see GetDragDropDataObject
		* for its properties).
		
		lparameters toData, ;
			toNode, ;
			toObject
		
	ENDPROC

	PROCEDURE Init
		local lnAnchor
		with This
		
		* Do the normal behavior.
		
			dodefault()
		
		* Set AutoYield to .F. so ActiveX events aren't processed when something is
		* executing.
		
			_vfp.AutoYield = .F.
		
		* Call the LoadImages method to programmatically load images into the
		* ImageList. Images can also be loaded visually if desired.
		
			.oImageList.ImageHeight = 16
			.oImageList.ImageWidth  = 16
			.LoadImages()	
		
		* Associate the ImageList with the TreeView.
		
			.oTree.ImageList = .oImageList.Object
		
		* Create a stack object.
		
			.oStack = newobject('ProjectExplorerStack', ;
				fullpath('ProjectExplorerStack.vcx', This.ClassLibrary))
		
		* Calculate the factors for converting twips to pixels.
		
			.CalcTwipsPerPixel()
		
		* Adjust the TreeView size (although we use anchoring, it doesn't work until
		* the control is visible.
		
			lnAnchor      = .oTree.Anchor
			.oTree.Anchor = 0
			.oTree.Height = .Height
			.oTree.Width  = .Width
			.oTree.Anchor = lnAnchor
		
		* Create a Registry object.
		
			.oRegistry = newobject(This.cRegistryClass, ;
				fullpath(This.cRegistryLibrary, This.ClassLibrary))
		
		* Restore the last expanded and selected nodes.
		
			.RestoreSelectedNode()
		
		* If we're supposed to, load the TreeView.
		
			if .lLoadTreeViewAtStartup
				.LoadTree()
			endif .lLoadTreeViewAtStartup
		
		* Flag that initialization is done.
		
			.lInitialized = .T.
		endwith
		
	ENDPROC

	PROCEDURE insertnode		&& Inserts a new node
		* Abstract method: called from TreeKeyDown when Insert is pressed
		
	ENDPROC

	PROCEDURE loadexpandednode		&& Loads the children for the specified node
		lparameters toNode
		local llLocked
		with This
			llLocked = .lTreeViewLocked
			if not llLocked
				.LockTreeView(.T.)
			endif not llLocked
			if type('toNode.Child.Key') = 'C'
				.oTree.Nodes.Remove(toNode.Child.Key)
			endif type('toNode.Child.Key') = 'C'
			.LoadNodeChildren(toNode)
			if not llLocked
				.LockTreeView()
			endif not llLocked
		endwith
		
	ENDPROC

	PROCEDURE loadimages		&& Loads the ImageList control with desired images
		* Abstract method to load the images for the ImageList control. Typically, code
		* will look like this:
		*
		* with This.oImageList
		*	.ListImages.Add(1, 'Image1Key', loadpicture('SomeImageFile'))
		*	.ListImages.Add(2, 'Image2Key', loadpicture('SomeImageFile'))
		* endwith
		*
		* Set ImageHeight and ImageWidth of This.oImageList to appropriate values if
		* the images are not 16x16.
		
	ENDPROC

	PROCEDURE loadnode		&& Loads the specified node into the TreeView
		lparameters toNodeItem, ;
			tcParentKey
		local loNode, ;
			lcSeparator, ;
			llExpand
		
		* Add the node to the TreeView. If we're supposed to, set the node's Key to its
		* FullPath so we can use FullPath to locate the Key.
		
		with toNodeItem
			if empty(tcParentKey)
				loNode = This.oTree.Nodes.Add(, 1, .Key, .Text, .Image)
			else
				loNode = This.oTree.Nodes.Add(tcParentKey, 4, .Key, .Text, .Image)
			endif empty(tcParentKey)
			if not empty(.SelectedImage)
				loNode.SelectedImage = .SelectedImage
			endif not empty(.SelectedImage)
			if not empty(.ExpandedImage)
				loNode.ExpandedImage = .ExpandedImage
			endif not empty(.ExpandedImage)
			loNode.Sorted    = .Sorted
			loNode.ForeColor = .ForeColor
			loNode.BackColor = .BackColor
			loNode.Bold      = .Bold
			if This.lUsePathAsKey
				store loNode.FullPath to loNode.Key, toNodeItem.Key
			endif This.lUsePathAsKey
		endwith
		with This
		
		* Flag if we're still above the end of the auto-expand limit.
		
			lcSeparator = .oTree.PathSeparator
			llExpand    = occurs(lcSeparator, loNode.FullPath) <= .nAutoExpand - 1
			do case
		
		* If the node doesn't have any children, we don't have anything else to do.
		
				case not toNodeItem.HasChildren
		
		* If we're supposed to load all child nodes or we're not at the end of the
		* auto-expand limit, let's load the children.
		
				case .lAutoLoadChildren or llExpand
					.LoadNodeChildren(loNode)
		
		* This node has children but we're not going to load them, so we'll add a
		* "loading" node so the + appears properly.
		
				otherwise
					.oTree.Nodes.Add(loNode.Key, 4, sys(2015), ccLOADING)
			endcase
		endwith
		return loNode
		
	ENDPROC

	PROTECTED PROCEDURE loadnodechildren		&& Loads the children of the specified node
		lparameters toNode
		local loChildNodesCollection as Collection, ;
			loNodeItem, ;
			llSorted, ;
			loChildNode
		with This
			loChildNodesCollection = createobject('Collection')
			loNodeItem = .GetTypeAndIDFromNode(toNode)
			.GetChildNodes(loNodeItem.Type, loNodeItem.ID, loChildNodesCollection)
			llSorted = toNode.Sorted
			toNode.Sorted = .F.
				&& speeds up loading if Sorted set to .F. during load and .T. after
			for each loChildNode in loChildNodesCollection foxobject
				.LoadNode(loChildNode, toNode.Key)
			next loChildNode
			if llSorted
				toNode.Sorted = .T.
			endif llSorted
		endwith
		
	ENDPROC

	PROCEDURE loadtree		&& Loads the TreeView
		* Load the TreeView.
		
		lparameters tlNoSelect
		local lnExpandedNodes , ;
			lnI, ;
			laExpandedNodes[1], ;
			loNodesCollection, ;
			loNodeItem, ;
			lcKey, ;
			loNode
		
		* There's a bug in the TreeView control: adding a new node or changing the
		* parent of an existing node in a drag operation causes the node to be deleted
		* once the drag is complete. So, we'll do nothing in that case and we'll be
		* called again from tmrReload after the drag is complete.
		
		if This.lDragInProgress
			This.lNeedReload = .T.
			return
		endif This.lDragInProgress
		with This
		
		* Lock the TreeView so we don't see updates until they're done.
		
			.LockTreeView(.T.)
		
		* If we have any existing nodes, let's save the keys of the expanded ones and
		* the selected one so we can restore them later, then nuke the nodes. That way,
		* LoadTree can be called to refresh or reload the TreeView.
		
			lnExpandedNodes = iif(empty(.aExpandedNodes[1]), 0, alen(.aExpandedNodes))
			with .oTree
				if .Nodes.Count > 0
					for lnI = 1 to .Nodes.Count
						if .Nodes[lnI].Expanded
							lnExpandedNodes = lnExpandedNodes + 1
							dimension This.aExpandedNodes[lnExpandedNodes]
							This.aExpandedNodes[lnExpandedNodes] = .Nodes[lnI].Key
						endif .Nodes[lnI].Expanded
					next lnI
					do case
						case not empty(This.cLastNode)
						case vartype(.SelectedItem) = 'O'
							This.cLastNode = .SelectedItem.Key
						otherwise
							This.cLastNode = ''
					endcase
					.Nodes.Clear()
				endif .Nodes.Count > 0
			endwith
		
		* Get the root nodes and add them to the TreeView.
		
			loNodesCollection = createobject('Collection')
			.GetRootNodes(loNodesCollection)
			for each loNodeItem in loNodesCollection foxobject
				.LoadNode(loNodeItem)
			next loNodeItem
		
		* Re-expand any previously expanded nodes.
		
			with .oTree
				for lnI = 1 to alen(This.aExpandedNodes)
					lcKey = trim(This.aExpandedNodes[lnI])
					if type('.Nodes[lcKey]') = 'O'
						This.TreeExpand(.Nodes[lcKey], .T.)
					endif type('.Nodes[lcKey]') = 'O'
				next lnI
			endwith
		
		* If we're supposed to re-select the node selected last time and that node
		* still exists, select it. Otherwise, select the first node.
		
			loNode = .NULL.
			do case
				case tlNoSelect
				case not empty(.cLastNode) and type('.oTree.Nodes[.cLastNode]') = 'O'
					loNode = .oTree.Nodes[.cLastNode]
				case .oTree.Nodes.Count > 0
					loNode = .oTree.Nodes[1]
			endcase
			if not isnull(loNode)
				.SelectNode(loNode)
			endif not isnull(loNode)
		
		* Reset cLastNode and aExpandedNodes so we aren't fooled by their values when
		* LoadTree is called again.
		
			.cLastNode = ''
			dimension .aExpandedNodes[1]
			.aExpandedNodes[1] = ''
		
		* Unlock the TreeView.
		
			.LockTreeView()
		endwith
		
	ENDPROC

	PROCEDURE locktreeview		&& Locks the TreeView so updates don't appear immediately
		lparameters tlLock
		local lnHWnd
		declare integer LockWindowUpdate in Win32API ;
			integer nHandle
		if tlLock
			lnHWnd = This.oTree.hWnd
		else
			lnHWnd = 0
		endif tlLock
		This.lTreeViewLocked = tlLock
		LockWindowUpdate(lnHWnd)
		return
		
	ENDPROC

	PROCEDURE nodeclicked		&& Called when a node is clicked
		* Abstract method.
		
	ENDPROC

	PROCEDURE oselectednode_access
		return This.oTree.SelectedItem
		
	ENDPROC

	PROCEDURE pushkey		&& Pushes the specified key onto the stack
		lparameters tcKey
		This.oStack.Push(tcKey)
		
	ENDPROC

	PROCEDURE removenode		&& Removes the selected node
		* Remove the selected node and select the new node.
		
		with This
			.oTree.Nodes.Remove(.oTree.SelectedItem.Key)
			if vartype(.oTree.SelectedItem) = 'O'
				.SelectNode(.oTree.SelectedItem)
			endif vartype(.oTree.SelectedItem) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE restoreselectednode		&& Restores the selected node from whereever it was saved when this was last used
		* Restore cLastNode and aExpandedNodes so the TreeView is restored to its
		* former state.
		
		local lcKey, ;
			loRegistry, ;
			lnNode, ;
			laValues[1], ;
			lnValues, ;
			lnI, ;
			lcValue
		with This
			lcKey = .GetRegistryKey()
			if not empty(lcKey)
				.cLastNode = .oRegistry.GetKey(lcKey, 'SelectedNode')
				lnNode     = 0
				lnValues   = .oRegistry.EnumerateKeyValues(lcKey, @laValues)
				for lnI = 1 to lnValues
					lcValue = laValues[lnI, 1]
					if lcValue = 'Expanded'
						lnNode = lnNode + 1
						dimension .aExpandedNodes[lnNode]
						.aExpandedNodes[lnNode] = laValues[lnI, 2]
					endif lcValue = 'Expanded'
				next lnI
			endif not empty(lcKey)
		endwith
		
	ENDPROC

	PROCEDURE saveselectednode		&& Saves the selected node so it can be restored at restart
		* Save the selected and all expanded nodes so we can restore our former state
		* next time.
		
		local lcKey, ;
			loRegistry, ;
			lnNode, ;
			lnI, ;
			loNode, ;
			laValues[1], ;
			lnValues, ;
			lcValue
		with This.oTree
			lcKey = This.GetRegistryKey()
			if not empty(lcKey)
				if vartype(.SelectedItem) = 'O'
					This.oRegistry.SetKey(lcKey, 'SelectedNode', .SelectedItem.Key)
				endif vartype(.SelectedItem) = 'O'
				lnNode = 0
				for lnI = 1 to .Nodes.Count
					loNode = .Nodes(lnI)
					if loNode.Expanded
						lnNode = lnNode + 1
						This.oRegistry.SetKey(lcKey, 'Expanded' + transform(lnNode), ;
							loNode.Key)
					endif loNode.Expanded
				next lnI
		
		* Remove extra lines from the Registry in case there were more expanded nodes
		* the last time it was written to.
		
				lnValues = This.oRegistry.EnumerateKeyValues(lcKey, @laValues)
				for lnI = 1 to lnValues
					lcValue = laValues[lnI, 1]
					if lcValue = 'Expanded' and val(substr(lcValue, 9)) > lnNode
						This.oRegistry.DeleteKeyValue(lcKey, lcValue)
					endif lcValue = 'Expanded' ...
				next lnI
			endif not empty(lcKey)
		endwith
		
	ENDPROC

	PROCEDURE selectnode		&& Selects the specified node
		* Select the specified node.
		
		lparameters toNode, ;
			tlNoPush
		local loNode, ;
			loObject
		with This
		
		* If we were passed a key or index rather than a node, try to find the proper
		* node.
		
			do case
				case vartype(toNode) = 'O'
					loNode = toNode
				case type('.oTree.Nodes[toNode]') = 'O'
					loNode = .oTree.Nodes[toNode]
				otherwise
					loNode = .NULL.
			endcase
			if vartype(loNode) = 'O'
		
		* Push the previous node onto the stack if we're supposed to.
		
				if not tlNoPush and .lTrackNodeClicks and ;
					vartype(.oTree.SelectedItem) = 'O'
					.PushKey(.oTree.SelectedItem.Key)
				endif not tlNoPush ...
		
		* Ensure the node is visible and selected. Prevent two items from being
		* selected by nulling the currently selected item before selecting this one.
		
				loNode.EnsureVisible()
				.oTree.SelectedItem = .NULL.
				loNode.Selected     = .T.
		
		* Set cCurrentNodeType, cCurrentNodeID, and cCurrentNodeKey to the type, ID,
		* and key of the selected node.
		
				loObject          = .GetTypeAndIDFromNode(loNode)
				.cCurrentNodeType = loObject.Type
				.cCurrentNodeID   = loObject.ID
				.cCurrentNodeKey  = loNode.Key
		
		* Call the NodeClicked method for any custom behavior.
		
				.NodeClicked()
			endif vartype(loNode) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE treeafterlabeledit		&& Called after the text of a node has been edited in the TreeView
		* Abstract method. tnCancel and tcNewName are passed by reference, so set
		* Cancel to .T. to prevent the label from being saved or change tcNewName as
		* desired.
		
		lparameters tnCancel, ;
			tcNewName
		
	ENDPROC

	PROCEDURE treebeforelabeledit		&& Called before the text of a node is edited in the TreeView
		* Abstract method. tnCancel is passed by reference, so set it to .T. to prevent
		* the label from being edited.
		
		lparameters tnCancel
		tnCancel = not This.lAllowRename
		
	ENDPROC

	PROCEDURE treedblclick		&& Fired when the user double-clicks on the TreeView
		* Restore the saved expanded setting for the node so double-clicking doesn't
		* expand the node if that's what we're supposed to do.
		
		with This
			if not .lExpandOnDblClick
				.oTree.SelectedItem.Expanded = .lExpanded
			endif not .lExpandOnDblClick
		endwith
		
	ENDPROC

	PROCEDURE treeexpand		&& Called when a node is expanded in the TreeView
		* If the node has a "Loading" child, this is the first time the node has been
		* expanded, so nuke the child and add the appropriate child nodes, depending on
		* the type of node this is. The TreeView is locked while this happens so we
		* don't see the updates until they're done.
		
		lparameters toNode, ;
			tlNoSelect
		local loNode, ;
			loNodeItem
		with This
		
		* If we were passed a key rather than a node, try to find the proper node.
		
			do case
				case vartype(toNode) = 'O'
					loNode = toNode
				case type('.oTree.Nodes[toNode]') = 'O'
					loNode = .oTree.Nodes[toNode]
			endcase
		
		* If this node has a "Loading" child, remove it and add the real children.
		
			if vartype(loNode) = 'O'
				if loNode.Children > 0 and loNode.Child.Text = ccLOADING
					.LoadExpandedNode(loNode)
				endif loNode.Children > 0 ...
		
		* Ensure the node is expanded (we may have been called programmatically). Note
		* that this calls oTree.Expand which calls us, so flag not to do that.
		
				if not loNode.Expanded
					.lExpanding     = .T.
					loNode.Expanded = .T.
					.lExpanding     = .F.
				endif not loNode.Expanded
		
		* Act like the node was just clicked so it's selected.
		
				if not tlNoSelect
					.SelectNode(loNode)
				endif not tlNoSelect
			endif vartype(loNode) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE treekeydown		&& Called when a key is pressed when the TreeView has focus
		lparameters tnKeyCode, ;
			tnShift
		local lnKeyCode
		lnKeyCode = 0
		with This
			do case
		
		* Delete was pressed, so remove the selected node if we're allowed to.
		
				case tnKeyCode = 46 and .lAllowDelete
					.DeleteNode()
					lnKeyCode = 0
		
		* Insert was pressed, so add a new node if we're allowed to.
		
				case tnKeyCode = 45 and .lAllowInsert
					.InsertNode()
					lnKeyCode = 0
		
		* Enter was pressed, so execute some behavior for the node..
		
				case tnKeyCode = 13 and .lAllowEnter
					.ExecuteNode()
					lnKeyCode = 0
		
		* F1 was pressed, so bring up help.
		
				case tnKeyCode = 112
					help
					lnKeyCode = 0
		
		* Translate keypress codes from the TreeView to VFP, then call the form's
		* KeyPress method.
		
				case tnKeyCode = 33		&& Page Up
					lnKeyCode = 18
				case tnKeyCode = 34		&& Page Down
					lnKeyCode = 3
				case tnKeyCode = 121	&& Shift-F10
					lnKeyCode = 93
		
		* Pass any other keypress to the form's KeyPress method.
		
				otherwise
					lnKeyCode = tnKeyCode
			endcase
			if lnKeyCode <> 0
				Thisform.KeyPress(lnKeyCode, tnShift)
			endif lnKeyCode <> 0
		endwith
		
	ENDPROC

	PROCEDURE treemousedown		&& Called when a mouse button is pressed over the TreeView
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		local loNode
		with This
		
		* Ensure the node under the mouse is selected.
		
			loNode = .GetNodeUnderMouse(tnXCoord, tnYCoord)
			if not isnull(loNode)
				.TreeNodeClick(loNode)
			endif not isnull(loNode)
		
		* If this is the left mouse button, determine whether we can drag from the
		* selected node or not.
		
			if tnButton = BUTTON_LEFT
				.oTree.OLEDragMode = iif(.CanStartDrag(), DRAG_AUTOMATIC, DRAG_MANUAL)
		
		* If this is the right mouse button, show the shortcut menu. We would normally
		* do this is the RightClick method, except the TreeView doesn't have one, or
		* the MouseUp method, except that doesn't fire when the mouse is over the image
		* or text of a node. So, we have to do it here. Alternatively, we could store
		* which button is held down in MouseDown and check for the right button in
		* NodeClick (which doesn't receive a tnButton parameter, hence the need to
		* store it in MouseDown) and call ShowMenu from there.
		
			else
				.ShowMenu()
			endif tnButton = BUTTON_LEFT
		endwith
		
	ENDPROC

	PROCEDURE treemouseup		&& Called when a mouse button is released over the TreeView
		* Abstract method.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		
	ENDPROC

	PROCEDURE treenodecheck		&& Called when a node is checked in the TreeView
		* Abstract method
		
		lparameters toNode
		
	ENDPROC

	PROCEDURE treenodeclick		&& Called when a node is selected in the TreeView
		lparameters toNode
		local loParent, ;
			loNode, ;
			lnSeconds
		with This
		
		* If you click lightly on the + for a parent node, sometimes Expand doesn't
		* fire but the node still expands, so you see "Loading..." as the node.
		* Since that isn't a valid node, if the user clicks it, we'll expand the
		* parent node.
		
			if toNode.Text = ccLOADING
				loParent = toNode.Parent
				.TreeExpand(loParent, .T.)
				loNode = loParent.Child
			else
				loNode = toNode
			endif toNode.Text = ccLOADING
		
		* If we're on the same node as before (likely because we were called from
		* TreeMouseDown on the down-press and again from NodeClick when the mouse is
		* released), do nothing. Otherwise, select the node.
		
			if isnull(.oTree.SelectedItem) or not loNode.Key == .cCurrentNodeKey
				.SelectNode(loNode)
		
		* Save its Expanded property if this isn't the second click of a double-click.
		
				lnSeconds = seconds()
				if lnSeconds - .nNodeClick > _dblclick
					.lExpanded = loNode.Expanded
				endif lnSeconds - .nNodeClick > _dblclick
				.nNodeClick = seconds()
			endif isnull(.oTree.SelectedItem) ...
		endwith
		
	ENDPROC

	PROCEDURE treeolecompletedrag		&& Called when an OLECompleteDrag events occurs in the TreeView
		* Turn off node highlighting. This is done in both TreeOLEDragDrop and here
		* because sometimes one or the other event fires.
		
		lparameters tnEffect
		This.oTree.DropHighlight = .NULL.
		
	ENDPROC

	PROCEDURE treeoledragdrop		&& Called when an OLEDragDrop event occurs in the TreeView
		lparameters toData, ;
			tnEffect, ;
			tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		local loNode, ;
			loObject
		with This
			loNode = .GetNodeUnderMouse(tnXCoord, tnYCoord)
			.oTree.DropHighlight = .NULL.	&& do this here plus in TreeOLECompleteDrag
											&& because sometimes one or the other event
											&& fires
			loObject = .GetDragDropDataObject(loNode, toData, tnButton, tnShift)
			if .CanDrop(toData, loNode, loObject, @tnEffect, tnButton, tnShift)
		
		* Flag that a drag is in progress so calls to LoadTree do nothing; the code
		* below starts a timer that calls LoadTree after the drag operation is
		* complete.
		
				.lDragInProgress = .T.
		
		* Save the key of the selected node so we can restore it if necessary.
		
				if vartype(.oTree.SelectedItem) = 'O'
					.cLastNode = .oTree.SelectedItem.Key
				else
					.cLastNode = ''
				endif vartype(.oTree.SelectedItem) = 'O'
		
		* Handle the drop and reset lDragInProgress.
		
				.HandleDragDrop(toData, loNode, loObject)
				.lDragInProgress = .F.
		
		* There's a bug in the TreeView control: adding a new node or changing the
		* parent of an existing node in a drag operation causes the node to be deleted
		* once the drag is complete. In that case, LoadTree did nothing and we'll
		* start a timer that'll call it again after the drag is done. Note that we have
		* to disable the sync timer since it interferes with the reloading.
		
				if .lNeedReload
					.lNeedReload       = .F.
					.nTimerInterval    = .tmrSync.Interval
					.tmrSync.Interval  = 0
					.tmrSync.Enabled   = .F.
					.tmrReload.Enabled = .T.
				endif .lNeedReload
			endif .CanDrop(toData ...
		endwith
		
	ENDPROC

	PROCEDURE treeoledragover		&& Called when an OLEDragOver event occurs in the TreeView
		lparameters toData, ;
			tnEffect, ;
			tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord, ;
			tnState
		local loNode, ;
			loPrevious, ;
			loObject
		with This
		
		* Determine which node the source was dragged over and highlight it.
		
			loNode = .GetNodeUnderMouse(tnXCoord, tnYCoord)
			if vartype(loNode) = 'O'
				.oTree.DropHighlight = loNode
		
		* If we're near the top or bottom of the TreeView, auto-scroll (the INKEY()
		* ensures it doesn't scroll too fast).
		
				do case
					case tnYCoord > .oTree.Top + 15
					case type('loNode.Previous.Text') = 'C'
						loPrevious = loNode.Previous
						do while vartype(loPrevious.Parent) = 'O' and ;
							not loPrevious.Parent.Expanded
							loPrevious = loPrevious.Parent
						enddo while vartype(loPrevious.Parent) = 'O' ...
						do while loPrevious.Expanded and loPrevious.Children > 0
							loPrevious = loPrevious.Child.LastSibling
						enddo while loPrevious.Expanded ...
						inkey(0.05, 'H')
						loPrevious.EnsureVisible()
					case type('loNode.Parent.Text') = 'C'
						inkey(0.05, 'H')
						loNode.Parent.EnsureVisible()
				endcase
				do case
					case tnYCoord < .oTree.Top + .oTree.Height - 15
					case loNode.Expanded and type('loNode.Child.Text') = 'C'
						inkey(0.05, 'H')
						loNode.Child.EnsureVisible()
					case type('loNode.Next.Text') = 'C'
						inkey(0.05, 'H')
						loNode.Next.EnsureVisible()
				endcase
			endif vartype(loNode) = 'O'
		
		* If the mouse is entering or moving over the TreeView, flag whether we'll
		* allow a drop or not.
		
			if tnState = DRAG_ENTER or tnState = DRAG_OVER
				loObject = .GetDragDropDataObject(loNode, toData, tnButton, tnShift)
				.CanDrop(toData, loNode, loObject, @tnEffect, tnButton, tnShift)
			endif tnState = DRAG_ENTER ...
		endwith
		
	ENDPROC

	PROCEDURE treeolegivefeedback		&& Called when an OLEGiveFeedback event occurs in the TreeView
		* Abstract method.
		
		lparameters tnEffect, ;
			tuMouseCursor
		
	ENDPROC

	PROCEDURE treeolestartdrag		&& Called when an OLEStartDrag event occurs in the TreeView
		* Set the data for the drag object to the node type and ID. We'll use a custom
		* format that holds the node type and key so dragging and dropping to ourselves
		* can be detected. In addition, the "text" format contains the current node's
		* Text value.
		
		lparameters toData, ;
			tnAllowedEffects
		local lcValue
		with This
			lcValue = createbinary(.cCurrentNodeType + ':' + ;
				transform(.cCurrentNodeID))
			toData.SetData(lcValue, CF_MAX)
			toData.SetData(.oTree.SelectedItem.Text, CF_TEXT)
		endwith
		
	ENDPROC

	PROCEDURE visible_assign
		lparameters tlVisible
		store tlVisible to This.Visible, This.oTree.Visible
		
	ENDPROC

	PROCEDURE oTree.AfterLabelEdit
		* Pass AfterLabelEdit events to the parent.
		
		lparameter tnCancel, ;
			tcNewName
		This.Parent.TreeAfterLabelEdit(@tnCancel, @tcNewName)
		
	ENDPROC

	PROCEDURE oTree.BeforeLabelEdit
		* Pass BeforeLabelEdit events to the parent.
		
		lparameters tnCancel
		This.Parent.TreeBeforeLabelEdit(@tnCancel)
		
	ENDPROC

	PROCEDURE oTree.Collapse
		* Ensure the node in the tree that was just collapsed is selected.
		
		lparameters toNode
		This.Parent.SelectNode(toNode)
		
	ENDPROC

	PROCEDURE oTree.DblClick
		* Pass double-clicks to the parent.
		
		This.Parent.TreeDblClick()
		
	ENDPROC

	PROCEDURE oTree.Expand
		* Pass node expansion to the parent.
		
		lparameters toNode
		if not This.Parent.lExpanding
			This.Parent.TreeExpand(toNode)
		endif not This.Parent.lExpanding
		
	ENDPROC

	PROCEDURE oTree.Init
		* Change the font to Segoe UI in Vista.
		
		if os(3) >= '6'
			This.Font.Name = 'Segoe UI'
		endif os(3) >= '6'
		
	ENDPROC

	PROCEDURE oTree.KeyDown
		* Pass keypresses to the parent.
		
		lparameters tnKeyCode, ;
			tnShift
		This.Parent.TreeKeyDown(tnKeyCode, tnShift)
		
	ENDPROC

	PROCEDURE oTree.MouseDown
		* Pass MouseDown events to the parent.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.Parent.TreeMouseDown(tnButton, tnShift, tnXCoord, tnYCoord)
		
	ENDPROC

	PROCEDURE oTree.MouseUp
		* Pass MouseUp events to the parent. This doesn't fire when the mouse is over
		* the image or text of a node (NodeClick fires in that case), only when it's
		* over a "white" part of the TreeView.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.Parent.TreeMouseUp(tnButton, tnShift, tnXCoord, tnYCoord)
		
	ENDPROC

	PROCEDURE oTree.NodeCheck
		* Pass NodeCheck events to the parent.
		
		lparameters toNode
		This.Parent.TreeNodeCheck(toNode)
		
	ENDPROC

	PROCEDURE oTree.NodeClick
		* Pass NodeClick events to the parent.
		
		lparameters toNode
		This.Parent.TreeNodeClick(toNode)
		
	ENDPROC

	PROCEDURE oTree.OLECompleteDrag
		* Pass OLECompleteDrag events to the parent.
		
		lparameters tnEffect
		This.Parent.TreeOLECompleteDrag(@tnEffect)
		
	ENDPROC

	PROCEDURE oTree.OLEDragDrop
		* Pass OLEDragDrop events to the parent.
		
		lparameters toData, ;
			tnEffect, ;
			tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.Parent.TreeOLEDragDrop(@toData, @tnEffect, tnButton, tnShift, tnXCoord, ;
			tnYCoord)
		
	ENDPROC

	PROCEDURE oTree.OLEDragOver
		* Pass OLEDragOver events to the parent.
		
		lparameters toData, ;
			tnEffect, ;
			tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord, ;
			tnState
		This.Parent.TreeOLEDragOver(@toData, @tnEffect, tnButton, tnShift, tnXCoord, ;
			tnYCoord, tnState)
		
	ENDPROC

	PROCEDURE oTree.OLEGiveFeedback
		lparameters tnEffect, ;
			tuMouseCursor
		This.Parent.TreeOLEGiveFeedback(@tnEffect, @tuMouseCursor)
		
	ENDPROC

	PROCEDURE oTree.OLEStartDrag
		* Pass OLEStartDrag events to the parent.
		
		lparameters toData, ;
			tnAllowedEffects
		This.Parent.TreeOLEStartDrag(@toData, @tnAllowedEffects)
		
	ENDPROC

	PROCEDURE tmrReload.Timer
		with This.Parent
			This.Enabled = .F.
			.LoadTree()
			.tmrSync.Enabled  = .T.
			.tmrSync.Interval = .nTimerInterval
		endwith
		
	ENDPROC

	PROCEDURE tmrSync.Timer
		* It appears that sometimes clicking on a node in the TreeView doesn't fire
		* NodeClick. So, we'll periodically check whether the node we think is selected
		* matches the actual selection, and if not, fire NodeClick. Note that we
		* specifically ensure Interval isn't 0 since sometimes this event fires one
		* more time even after we disabled it.
		
		with This.Parent
			if wvisible('Trace')
				This.Enabled = .F.
			endif wvisible('Trace')
			if This.Interval > 0 and not isnull(.oTree.SelectedItem) and ;
				not .oTree.SelectedItem.Key == .cCurrentNodeKey
				.TreeNodeClick(.oTree.SelectedItem)
			endif This.Interval > 0 ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorertreeviewcursor AS projectexplorertreeviewcontainer OF "projectexplorertreeview.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorertreeview.h"
	*<DefinedPropArrayMethod>
		*m: addnodetocollection		&& Adds a node to the collection
		*m: addrecordtotreeviewcursor		&& Adds a record to the TreeView cursor
		*m: createtreeviewcursor		&& Creates the cursor driving the TreeView
		*m: displayrecord		&& Called when a node is clicked to display the current record
		*m: filltreeviewcursor		&& Fills the cursor driving the TreeView with the records to display
		*m: getnodekey		&& Gets the key for the current node
		*p: ccursoralias		&& The alias of the cursor driving the TreeView
		*p: ccursorstructure		&& The structure of the cursor driving the TreeView as it would go into a CREATE CURSOR statement
		*p: lsortrootnodes		&& .T. to sort the root nodes; .F. to use the order they appear in the TreeView cursor
	*</DefinedPropArrayMethod>

	ccursoralias = 		&& The alias of the cursor driving the TreeView
	ccursorstructure = ID C(60), TYPE C(60), PARENTID C(60), PARENTTYPE C(60), TEXT C(60), IMAGE C(20), SELIMAGE C(20), EXPIMAGE C(20), SORTED L, FORECOLOR I, BACKCOLOR I, BOLD L, NODEKEY C(60)		&& The structure of the cursor driving the TreeView as it would go into a CREATE CURSOR statement
	lsortrootnodes = .T.		&& .T. to sort the root nodes; .F. to use the order they appear in the TreeView cursor
	lusepathaskey = .F.
	Name = "projectexplorertreeviewcursor"
	_memberdata = <VFPData>
		<memberdata name="ccursorstructure" type="property" display="cCursorStructure"/>
		<memberdata name="ccursoralias" type="property" display="cCursorAlias"/>
		<memberdata name="createtreeviewcursor" type="method" display="CreateTreeViewCursor"/>
		<memberdata name="filltreeviewcursors" type="method" display="FillTreeViewCursors"/>
		<memberdata name="filltreeviewcursor" type="method" display="FillTreeViewCursor"/>
		<memberdata name="displayrecord" type="method" display="DisplayRecord"/>
		<memberdata name="addnodetocollection" type="method" display="AddNodeToCollection"/>
		<memberdata name="lsortrootnodes" type="property" display="lSortRootNodes"/>
		<memberdata name="getnodekey" type="method" display="GetNodeKey"/>
		<memberdata name="addrecordtotreeviewcursor" display="AddRecordToTreeViewCursor"/>
		</VFPData>
	oImageList.Left = 160
	oImageList.Name = "oImageList"
	oImageList.Top = 0
	oTree.Height = 200
	oTree.Name = "oTree"
	oTree.Width = 210
	tmrReload.Name = "tmrReload"
	tmrSync.Name = "tmrSync"
	
	PROCEDURE about
		* Subclassing this control:
		*
		* - Fill in the LoadImages, FillTreeViewCursor, and DisplayRecord methods. See
		*   the comments in those methods for sample code.
		*
		* - Set lSortRootNodes as desired.
		*
		* - Set lAllowRename to .T. to always allow renaming the selected node (the
		*   default is .F.). You could also put code into DisplayRecord that sets
		*   lAllowRename to .T. if the selected node can be renamed. You'll need to add
		*   code to TreeAfterLabelEdit to rename the record in the source data.
		*
		* - Set lAllowDelete to .T. to always allow deleting the selected node (the
		*   default is .F.). You could also put code into DisplayRecord that sets
		*   lAllowDelete to .T. if the selected node can be deleted. (In that case,
		*   you could have a menu item or command button to delete the selected node
		*   with it conditionally being enabled based on lAllowDelete.) You'll need to
		*   add code to DeleteNode to remove the record from the source data and have
		*   it call RemoveNode to remove the node from the TreeView. You can also call
		*   This.oTree.Nodes.Remove(KeyValue) to remove other nodes (not child nodes,
		*   since those are automatically removed) if necessary.
		*
		* - Set lAllowInsert as .T. to allow the user to add nodes (the default is
		*   .F.). In that case, fill in InsertNode with the necessary code.
		*
		* - To persist expanded and selected nodes, set either cRegistryKey or, if the
		*   form has a cRegistryKey property and you want to use a subnode of that, set
		*   cRegistryKeySuffix.
		
	ENDPROC

	PROTECTED PROCEDURE addnodetocollection		&& Adds a node to the collection
		lparameters toCollection
		local lnRecno, ;
			lcID, ;
			lcType, ;
			llHasChildren, ;
			lcKey, ;
			loNodeItem
		with This
		
		* See if the current record has any children.
		
			lnRecno = recno()
			lcID    = ID
			lcType  = TYPE
			locate for PARENTID = lcID and PARENTTYPE = lcType
			llHasChildren = found()
			go lnRecno
		
		* If we don't have a key, create one and put it into NODEKEY.
		
			if empty(NODEKEY)
				lcKey = .GetNodeKey(TYPE, ID)
				replace NODEKEY with lcKey
			else
				lcKey = trim(NODEKEY)
			endif empty(NODEKEY)
		
		* Create a node item object and fill its properties from fields in the cursor
		* for the current record, then add it to the collection
		
			loNodeItem = .CreateNodeObject()
			with loNodeItem
				.Key           = lcKey
				.Text          = alltrim(TEXT)
				.Image         = alltrim(IMAGE)
				.SelectedImage = alltrim(SELIMAGE)
				.ExpandedImage = alltrim(EXPIMAGE)
				.Sorted        = SORTED
				.ForeColor     = FORECOLOR
				.BackColor     = iif(BACKCOLOR = 0 and FORECOLOR = 0, ;
					rgb(255, 255, 255), BACKCOLOR)
					&& use white if no values were inserted into the cursor
				.Bold          = BOLD
				.HasChildren   = llHasChildren
			endwith
			toCollection.Add(loNodeItem)
		endwith
		
	ENDPROC

	PROCEDURE addrecordtotreeviewcursor		&& Adds a record to the TreeView cursor
		* Abstract method
		
	ENDPROC

	PROCEDURE createtreeviewcursor		&& Creates the cursor driving the TreeView
		* Creates the cursor from cCursorStructure.
		
		local lcStructure
		lcStructure = This.cCursorStructure
		
		* Ensure we have parens around the structure string.
		
		if left(lcStructure, 1) <> '('
			lcStructure = '(' + lcStructure + ')'
		endif left(lcStructure, 1) <> '('
		
		* Create and index the cursor.
		
		create cursor (This.cCursorAlias) &lcStructure
		index on ID         tag ID
		index on PARENTID   tag PARENTID
		index on PARENTTYPE tag PARENTTYPE
		index on NODEKEY    tag NODEKEY
		index on TYPE       tag TYPE
		if This.lSortRootNodes
			index on upper(TEXT) tag TEXT
		endif This.lSortRootNodes
		set order to
		
	ENDPROC

	PROCEDURE Destroy
		* Close the TreeView cursor.
		
		use in select(This.cCursorAlias)
		dodefault()
		
	ENDPROC

	PROCEDURE displayrecord		&& Called when a node is clicked to display the current record
		* Abstract method. The TreeView cursor (alias in This.cCursorAlias) is
		* positioned to the record for the node and This.cCurrentNodeID and
		* cCurrentNodeType contain the ID and type of the node, so typically you'll
		* find the record in the desired table and refresh the form to display
		* information about that record.
		
	ENDPROC

	PROCEDURE filltreeviewcursor		&& Fills the cursor driving the TreeView with the records to display
		* Abstract method. Typically, you'll add parent and child records to the
		* TreeView cursor using code like this:
		*
		* select ParentTable
		* scan
		*	insert into (This.cCursorAlias)
		*			(ID, ;
		*			TYPE, ;
		*			TEXT, ;
		*			IMAGE, ;
		*			SORTED, ;
		*			FORECOLOR, ;
		*			BOLD) ;
		*		values ;
		*			(ParentTable.ID, ;
		*			'ParentType', ;
		*			ParentTable.SomeDescriptiveField, ;
		*			'ImageForParent', ;
		*			.T. for sorted children, .F. to display in order in cursor, ;
		*			color to use, ;
		*			.T. for bold)
		* endscan
		* select ChildTable
		* scan
		*	insert into (This.cCursorAlias) ;
		*			(ID, ;
		*			PARENTID, ;
		*			TYPE, ;
		*			TEXT, ;
		*			IMAGE, ;
		*			SORTED, ;
		*			FORECOLOR, ;
		*			BOLD) ;
		*		values ;
		*			(ChildTable.ID, ;
		*			ChildTable.ParentID, ;
		*			'ChildType', ;
		*			ChildTable.SomeDescriptiveField, ;
		*			'ImageForChild')
		*			.T. for sorted children (if there are children), .F. to display in order in cursor, ;
		*			color to use, ;
		*			.T. for bold)
		* endscan
		*
		* Note:
		* - By default, ID and PARENTID are character fields (although you can change
		*   that in the cCursorStructure property), so use TRANSFORM() if the ID values
		*   are another data type.
		* - TYPE defines the type of record, so it can be things like "Parent" and
		*   "Child" or more descriptive like "Customer" and "Order"
		* - If you want different images when a node is selected or expanded, store the
		*   image key in SELIMAGE or EXPIMAGE.
		
	ENDPROC

	PROCEDURE getchildnodes
		* Get the child nodes for the specified parent.
		
		lparameters tcType, ;
			tcID, ;
			toCollection
		local lnSelect
		with This
			lnSelect = select()
			select (.cCursorAlias)
			scan for PARENTID = tcID and PARENTTYPE = tcType
				.AddNodeToCollection(toCollection)
			endscan for PARENTID = tcID ...
			select (lnSelect)
		endwith
		
	ENDPROC

	PROCEDURE getnodekey		&& Gets the key for the current node
		lparameters tcType, ;
			tuID
		local lcKey
		lcKey = trim(tcType) + ccKEY_SEPARATOR + trim(transform(tuID))
		return lckey
		
	ENDPROC

	PROCEDURE getrootnodes
		* Fill the root node collection with all parent records (ie. where PARENTID is empty).
		
		lparameters toCollection
		local lnSelect, ;
			lcOrder
		with This
			lnSelect = select()
			select (.cCursorAlias)
			lcOrder = set('ORDER')
			if .lSortRootNodes
				set order to TEXT
			endif .lSortRootNodes
			scan for empty(PARENTID)
				.AddNodeToCollection(toCollection)
			endscan for empty(PARENTID)
			set order to &lcOrder
			select (lnSelect)
		endwith
		
	ENDPROC

	PROCEDURE gettypeandidfromnode
		lparameters toNode
		local loObject, ;
			lcAlias, ;
			lnRecno
		loObject = dodefault()
		lcAlias  = This.cCursorAlias
		lnRecno  = recno(lcAlias)
		if seek(toNode.Key, lcAlias, 'NODEKEY')
			loObject.ID   = trim(evaluate(lcAlias + '.ID'))
			loObject.Type = trim(evaluate(lcAlias + '.TYPE'))
		endif seek(toNode.Key, lcAlias, 'NODEKEY')
		if between(lnRecno, 1, reccount(lcAlias))
			go lnRecno in (lcAlias)
		endif between(lnRecno, 1, reccount(lcAlias))
		return loObject
		
	ENDPROC

	PROCEDURE Init
		* Create an alias for the TreeView cursor if we don't already have one.
		
		if empty(This.cCursorAlias)
			This.cCursorAlias = sys(2015)
		endif empty(This.cCursorAlias)
		dodefault()
		
	ENDPROC

	PROCEDURE loadtree
		lparameters tlNoSelect
		with This
		
		* Close the cursor driving the TreeView if necessary.
		
			use in select(.cCursorAlias)
		
		* Create and fill the cursor.
		
			.CreateTreeViewCursor()
			.FillTreeViewCursor()
		endwith
		
		* Do the usual behavior.
		
		return dodefault(tlNoSelect)
		
	ENDPROC

	PROCEDURE nodeclicked
		* Find the record for the selected node in the TreeView cursor.
		
		local lnSelect
		with This
			lnSelect = select()
			select (This.cCursorAlias)
			locate for ID = .cCurrentNodeID and TYPE = .cCurrentNodeType
			select (lnSelect)
			.DisplayRecord()
		endwith
		
	ENDPROC

ENDDEFINE
