*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.20" SourceFile="projectexplorerbutton.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS projectexplorercancelbutton AS projectexplorercommandbutton OF "projectexplorerctrls.vcx" 		&& A CommandButton that closes the form it's on
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Cancel = .T.
		Caption = "Cancel"
		lcancel = .T.
		Name = "projectexplorercancelbutton"
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerCancelButton
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Provides a Cancel button that closes its form
		* Author:						Doug Hennig
		* Last revision:				12/07/2005
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	Cancel:						.T.
		*	Caption:					Cancel
		*	Default:					.T.
		*	lCancel:					.T.
		*
		* Changes in "Based On" class methods:
		*	Click:						release its form
		*	Init:						set Caption
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		Thisform.Release()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercolorbutton AS projectexplorercommandbutton OF "projectexplorerctrls.vcx" 		&& A CommandButton that displays a GETCOLOR() dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ncolor		&& The value for the color this button will hold.
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = "Color..."
		Name = "projectexplorercolorbutton"
		ncolor = 0
		_memberdata = <VFPData>
			<memberdata name="ncolor" type="property" display="nColor"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerColorButon
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Display a GETCOLOR() dialog
		* Author:						Doug Hennig
		* Last revision:				01/26/2005
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	Caption:					Color...
		*
		* Changes in "Based On" class methods:
		*	Click:						display a GETCOLOR() dialog
		*	Init:						set Caption
		*	Refresh:					set This.ForeColor to the nColor property
		*
		* Custom public properties added:
		*	nColor:						the value for the color this button will hold
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		local lnColor
		lnColor = getcolor(This.nColor)
		if lnColor >= 0
			This.nColor    = lnColor
			This.ForeColor = lnColor
		endif lnColor >= 0
		
	ENDPROC

	PROCEDURE Refresh
		This.ForeColor = This.nColor
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercolorselector AS projectexplorershape OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ccontrolsource		&& The control source for the color
	*</DefinedPropArrayMethod>

	*<PropValue>
		BorderColor = 0,0,0
		ccontrolsource = 
		FillStyle = 0
		Height = 16
		Name = "projectexplorercolorselector"
		SpecialEffect = 1
		StatusBarText = "Click to select the desired color"
		ToolTipText = "Click to select the desired color"
		Width = 16
		_memberdata = <VFPData>
			<memberdata name="ccontrolsource" display="cControlSource"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Click
		local lnColor, ;
			lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnColor = getcolor(.FillColor)
			if lnColor >= 0
				.FillColor = lnColor
				if not empty(.cControlSource)
					lnPos = at('.', .cControlSource)
					if lnPos > 0 and not lnColor == evaluate(.cControlSource)
						lcAlias = left(.cControlSource, lnPos - 1)
						lcField = substr(.cControlSource, lnPos + 1)
						if used(lcAlias)
							replace (lcField) with lnColor in (lcAlias)
						else
							store lnColor to (.cControlSource)
						endif used(lcAlias)
					endif lnPos > 0 ...
				endif not empty(.cControlSource)
			endif lnColor >= 0
		endwith
		
	ENDPROC

	PROCEDURE Refresh
		if not empty(This.cControlSource)
			This.FillColor = evaluate(This.cControlSource)
		endif not empty(This.cControlSource)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerdropdownmenubutton AS projectexplorercontainer OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: buttonclicked		&& Called when the button is clicked
		*m: luseformshortcutmenu_assign
		*m: turnoffvisualeffects		&& Turns off visual effects
		*m: turnonvisualeffects		&& Turns on visual effects
		*p: lmenuactive		&& .T. when the menu is active
	*</DefinedPropArrayMethod>

	*<PropValue>
		Anchor = 0
		Height = 22
		lmenuactive = .F.
		Name = "projectexplorerdropdownmenubutton"
		Width = 37
		_memberdata = <VFPData>
			<memberdata name="buttonclicked" type="method" display="ButtonClicked"/>
			<memberdata name="lmenuactive" type="property" display="lMenuActive"/>
			<memberdata name="luseformshortcutmenu_assign" type="method" display="lUseFormShortcutMenu_Assign"/>
			<memberdata name="turnoffvisualeffects" type="method" display="TurnOffVisualEffects"/>
			<memberdata name="turnonvisualeffects" type="method" display="TurnOnVisualEffects"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE buttonclicked		&& Called when the button is clicked
	ENDPROC

	PROCEDURE Init
		* Set the tooltip of the components to ours.
		
		dodefault()
		with This
			store .ToolTipText   to .cmdMain.ToolTipText,   .cmdMenu.ToolTipText
			store .StatusBarText to .cmdMain.StatusBarText, .cmdMenu.StatusBarText
		endwith
		
	ENDPROC

	PROCEDURE luseformshortcutmenu_assign
		lparameters tlValue
		
	ENDPROC

	PROCEDURE shortcutmenu
		* Set the row and column for the menu.
		
		lparameters toMenu, ;
			tcObject
		local lnScaleMode, ;
			lnFoxelHeight, ;
			lnPixelHeight, ;
			lnScreenHeight, ;
			lnScreenWidth, ;
			lnScreenTop, ;
			lnScreenLeft, ;
			lnVFPTop, ;
			lnVFPLeft, ;
			lnTopRowDockOffset, ;
			lnLeftColDockOffset, ;
			lnVPosition, ;
			lnHPosition, ;
			lnRow, ;
			lnCol, ;
			lcForm, ;
			lnPixelWidth, ;
			lnFoxelWidth
		with This
		
		* Determine some scaling factors.
		
			lnScaleMode = _screen.ScaleMode
			if lnScaleMode = 0
				lnFoxelHeight     = _screen.Height
				_screen.ScaleMode = 3
			endif lnScaleMode = 0
			lnPixelHeight  = _screen.Height
			lnScreenHeight = _screen.Height
			lnScreenWidth  = _screen.Width
			lnScreenTop    = _screen.Top
			lnScreenLeft   = _screen.Left
			lnVFPTop       = _VFP.Top
			lnVFPLeft      = _VFP.Left
			if lnScaleMode = 3
				_screen.ScaleMode = 0
				lnFoxelHeight     = _screen.Height
			endif lnScaleMode = 3
			_screen.ScaleMode = lnScaleMode
		
		* Calculate some offset positions. The row offset is the based on the heights
		* of the menu bar, the title bar, and the window frame. The column offset is
		* based on the window frame width. The vertical and horizontal offsets combine
		* the form position with that of the cmdMain button.
		
			lnTopRowDockOffset  = lnScreenTop - lnVFPTop - sysmetric(9) - ;
				iif(version(2) = 2, sysmetric(20) + 2 * sysmetric(4), 0)
			lnLeftColDockOffset = lnScreenLeft - lnVFPLeft - sysmetric(4)
			lnVPosition         = objtoclient(.cmdMain, 1) + .Height
			lnHPosition         = objtoclient(.cmdMain, 2)
		
		* Get the row for the menu.
		
			do case
		
		* We're not in a toolbar, so we don't have any adjustments.
		
				case upper(Thisform.BaseClass) <> 'TOOLBAR'
					lnRow = lnVPosition
		
		* The toolbar isn't docked so handle the height of the toolbar title bar and
		* window borders.
		
		*** The menu is too far above the mouse pointer
				case not Thisform.Docked 
					lnRow = lnVPosition + sysmetric(34) + sysmetric(4) - 1
		
		* The toolbar is docked at the top.
		
				case Thisform.DockPosition = 0
					lnRow = max(lnVPosition - lnTopRowDockOffset - 1, 0)
		
		* The toolbar is docked at the bottom.
		
				case Thisform.DockPosition = 3
					lnRow = lnScreenHeight + lnVPosition - 1
		
		* The toolbar is docked at one of the sides.
		
		*** The menu is too far above or below the mouse pointer, depending on where the toolbar is docked.
				otherwise
					lnRow = lnVPosition
			endcase
		
		* Get the column for the menu.
		
			do case
		
		* We're not in a toolbar, so we don't have any adjustments.
		
				case upper(Thisform.BaseClass) <> 'TOOLBAR'
					lnCol = lnHPosition
		
		* The toolbar isn't docked, so handle the width of the toolbar window borders.
		
		*** The menu is too far to the left of the mouse pointer
				case not Thisform.Docked 
					lnCol = lnHPosition + sysmetric(3)
		
		* The toolbar is docked at the left.
		
		*** The menu is too far to the right of the mouse pointer
				case Thisform.DockPosition = 1
					lnCol = lnHPosition - lnLeftColDockOffset
		
		* The toolbar is docked at the right.
		
				case Thisform.DockPosition = 2
					lnCol = lnScreenWidth + Thisform.Left
		
		* The toolbar is docked at the top or bottom.
		
				otherwise
					lnCol = lnHPosition + Thisform.Left
			endcase
		
		* Because menu coordinates are in foxels, we need to get the conversion factors.
		
			if upper(Thisform.BaseClass) <> 'TOOLBAR'
				lcForm        = Thisform.Name
				lnPixelHeight = mrow(lcForm, 3)
				lnFoxelHeight = mrow(lcForm, 0)
			else
				lcForm = _screen.ActiveForm.Name
			endif upper(Thisform.BaseClass) <> 'TOOLBAR'
			lnPixelWidth  = mcol(lcForm, 3)
			lnFoxelWidth  = mcol(lcForm, 0)
		
		* Convert the menu position from pixels to foxels.
		
		*** this works for a toolbar at runtime but not in the IDE.
			toMenu.nRow = lnRow * lnFoxelHeight/lnPixelHeight
			toMenu.nCol = lnCol * lnFoxelWidth /lnPixelWidth
		endwith
		return
		
	ENDPROC

	PROCEDURE showmenu
		* Ensure the menu is refreshed every time because the drop down list may
		* change.
		
		if vartype(This.oMenu) = 'O'
			This.oMenu.ClearMenu()
		endif vartype(This.oMenu) = 'O'
		dodefault()
		
		* Turn off visual effects after the menu has closed. If we're in a form rather
		* than a toolbar, we can get focus, so set focus to something else.
		
		This.TurnOffVisualEffects()
		if upper(Thisform.BaseClass) = 'FORM'
			Thisform.SetFocusToFirstObject(Thisform, .T.)
		endif upper(Thisform.BaseClass) = 'FORM'
		
	ENDPROC

	PROCEDURE turnoffvisualeffects		&& Turns off visual effects
		with This
			.cmdMenu.VisualEffect = 0
			.cmdMain.VisualEffect = 0
		endwith
		
	ENDPROC

	PROCEDURE turnonvisualeffects		&& Turns on visual effects
		with This
			.cmdMenu.VisualEffect = 1
			.cmdMain.VisualEffect = 1
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerdropdownmenutrigger AS projectexplorertoolbarbutton OF "projectexplorerbutton.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: fontname_assign
		*m: fontsize_assign
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = "6"
		FontName = "Webdings"
		FontSize = 6
		Name = "projectexplorerdropdownmenutrigger"
		Width = 14
		_memberdata = <VFPData>
			<memberdata name="fontname_assign" type="method" display="FontName_Assign"/>
			<memberdata name="fontsize_assign" type="method" display="FontSize_Assign"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE fontname_assign
		* This prevents the font name from being changed since we need the font set in
		* the Property Window for this control to appear correctly.
		
		lparameters tcValue
		
	ENDPROC

	PROCEDURE fontsize_assign
		* This prevents the font size from being changed since we need the size set in
		* the Property Window for this control to appear correctly.
		
		lparameters tnValue
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorergetdir AS projectexplorerpicturebutton OF "projectexplorerbutton.vcx" 		&& A CommandButton that displays a GETDIR() dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cafterdone		&& The name of a method or function to execute after GETDIR() has finished
		*p: ccaption		&& The caption for the GETDIR() dialog
		*p: cdefaultdir		&& The default directory to use
		*p: cresult		&& The location where to put the return value of GETDIR() (such as a control's Value property)
		*p: ctext		&& The text for the GETDIR() dialog
		*p: leditbox		&& .T. if an editbox should be displayed (only in VFP 7 and later)
		*p: lincludefiles		&& .T. to display files as well as folders (only in VFP 7 or later)
		*p: lusenewui		&& .T. if the Windows 2000 interface should be used (only in VFP 7 and later)
	*</DefinedPropArrayMethod>

	*<PropValue>
		cafterdone = 
		Caption = "..."
		ccaption = 
		cdefaultdir = 
		cresult = 
		ctext = 
		leditbox = .F.
		lincludefiles = .F.
		lusenewui = .T.
		Name = "projectexplorergetdir"
		StatusBarText = "Select a folder"
		ToolTipText = "Select a folder"
		_memberdata = <VFPData>
			<memberdata name="cafterdone" type="property" display="cAfterDone" favorites="True"/>
			<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
			<memberdata name="cdefaultdir" type="property" display="cDefaultDir" favorites="True"/>
			<memberdata name="cresult" type="property" display="cResult" favorites="True"/>
			<memberdata name="ctext" type="property" display="cText" favorites="True"/>
			<memberdata name="leditbox" type="property" display="lEditbox" favorites="True"/>
			<memberdata name="lincludefiles" type="property" display="lIncludeFiles" favorites="True"/>
			<memberdata name="lusenewui" type="property" display="lUseNewUI" favorites="True"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerGetDir
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Displays a GETDIR() dialog
		* Author:						Doug Hennig
		* Last revision:				06/26/2018
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	StatusBarText:				Select a folder
		*	ToolTipText:				Select a folder
		*
		* Changes in "Based On" class methods:
		*	Click:						displays the GETDIR() dialog, puts the result
		*								into the control defined in cResult, and
		*								performs any processing defined in the
		*								cAfterDone expression
		*
		* Custom public properties added:
		*	cAfterDone:					an expression to evaluate after the directory
		*								has been selected
		*	cCaption:					the caption for GETDIR()
		*	cDefaultDir:				the default directory for GETDIR()
		*	cResult:					the name of the control to put the return value
		*								from GETDIR() into
		*	lEditBox:					.T. if an editbox should be displayed
		*	lIncludeFiles:				.T. to display files as well as folders
		*	lUseNewUI:					.T. if the Windows 2000 interface should be used
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* Display a GETDIR() dialog, using parameters determined from the properties
		* of this object.
		
		local lcResult, ;
			lcOptions, ;
			lnFlags, ;
			lcDir
		with This
			assert not empty(.cResult) ;
				message 'SFGetDir: the result container was not defined.'
		
		* Build a string of parameters from the properties of this object.
		
			lcResult = .cResult
			do case
				case empty(.cDefaultDir)
					lcOptions = evaluate(lcResult)
				case left(.cDefaultDir, 1) = '='
					lcOptions = '[' + ;
						evaluate(alltrim(substr(.cDefaultDir, 2))) + ']'
				otherwise
					lcOptions = alltrim(.cDefaultDir)
			endcase
			lcOptions = iif(empty(.cText), lcOptions, lcOptions + ;
				iif(empty(lcOptions), '[]', '') + ',[' + .cText + ']')
			do case
				case empty(.cCaption)
				case empty(lcOptions)
					lcOptions = '[],[],[' + .cCaption + ']'
				case not ',' $ lcOptions
					lcOptions = lcOptions + ',[],[' + .cCaption + ']'
				otherwise
					lcOptions = lcOptions + ',[' + .cCaption + ']'
			endcase
		
		* Support new options.
		
			#define BIF_RETURNONLYFSDIRS       1
			#define BIF_EDITBOX               16
			#define BIF_VALIDATE              32
			#define BIF_USENEWUI              64
			#define BIF_BROWSEINCLUDEFILES 16384
			lnFlags = 0
			if .lEditBox
				lnFlags = lnFlags + BIF_EDITBOX + BIF_VALIDATE
			endif .lEditBox
			if .lIncludeFiles
				lnFlags = lnFlags + BIF_BROWSEINCLUDEFILES
			endif .lIncludeFiles
			if .lUseNewUI
				lnFlags = lnFlags + BIF_USENEWUI
			endif .lUseNewUI
			if lnFlags > 0
				lnFlags = lnFlags + BIF_RETURNONLYFSDIRS
			endif lnFlags > 0
			do case
				case lnFlags = 0
				case empty(lcOptions)
					lcOptions = '[],[],[],' + transform(lnFlags)
				case not ',' $ lcOptions
					lcOptions = lcOptions + ',[],[],' + transform(lnFlags)
				case occurs(',', lcOptions) = 1
					lcOptions = lcOptions + ',[],' + transform(lnFlags)
				otherwise
					lcOptions = lcOptions + ',' + transform(lnFlags)
			endcase
		
		* Use the GETDIR() function, and if a directory was selected, store the result
		* in the specified location. Convert to the proper case.
		
			lcDir = getdir(&lcOptions)
			if not empty(lcDir)
				lcDir = GetProperFileCase(lcDir, .T.)
				store lcDir to (lcResult)
			endif not empty(lcDir)
		
		* If a method or function was specified to execute after GETDIR(), do it.
		
			if not empty(.cAfterDone)
				evaluate(.cAfterDone)
			endif not empty(.cAfterDone)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorergetexpression AS projectexplorerpicturebutton OF "projectexplorerbutton.vcx" 		&& A CommandButton that displays an Expression Builder dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cafterdone		&& The name of a method or function to execute after GETEXPR has finished.
		*p: calias		&& An alias to select before GETEXPR is used.
		*p: ccaptiontext		&& The caption for the GETEXPR dialog.
		*p: cdefaultexpression		&& The default parameter for GETEXPR.
		*p: cerrormessage		&& The error message GETEXPR displays if the expression isn't valid.
		*p: cexpressiontype		&& The type parameter for GETEXPR.
		*p: cresult		&& The location where to put the result of GETEXPR (such as a control's Value property).
		*p: lliteral		&& .T. if the expression should be treated as a literal; in that case, an "=" is added to the start of non-literal expressions.
	*</DefinedPropArrayMethod>

	*<PropValue>
		cafterdone = 
		calias = 
		Caption = "..."
		ccaptiontext = 
		cdefaultexpression = 
		cerrormessage = 
		cexpressiontype = L
		cresult = 
		Height = 23
		Name = "projectexplorergetexpression"
		StatusBarText = "Display Expression Builder"
		ToolTipText = "Display Expression Builder"
		Width = 23
		_memberdata = <VFPData>
			<memberdata name="cafterdone" type="property" display="cAfterDone" favorites="True"/>
			<memberdata name="calias" type="property" display="cAlias" favorites="True"/>
			<memberdata name="ccaptiontext" type="property" display="cCaptionText" favorites="True"/>
			<memberdata name="cdefaultexpression" type="property" display="cDefaultExpression" favorites="True"/>
			<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
			<memberdata name="cexpressiontype" type="property" display="cExpressionType" favorites="True"/>
			<memberdata name="cresult" type="property" display="cResult" favorites="True"/>
			<memberdata name="lliteral" type="property" display="lLiteral" favorites="True"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerGetExpression
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Displays the Expression Builder
		* Author:						Doug Hennig
		* Last revision:				02/06/2008
		*
		* Changes in "Based On" class properties:
		*	Height:						23 so it's the same height as an SFTextBox
		*	StatusBarText:				Display Expression Builder
		*	ToolTipText:				Display Expression Builder
		*	Width:						23 so it's a square
		*
		* Changes in "Based On" class methods:
		*	Click:						displays the Expression Builder dialog, puts
		*								the result into the control defined in cResult,
		*								and performs any processing defined in the
		*								cAfterDone expression
		*
		* Custom public properties added:
		*	cAfterDone:					an expression to evaluate after the expression
		*								has been entered
		*	cAlias:						the alias to select before displaying the
		*								Expression Builder
		*	cCaptionText:				the caption for GETEXPR
		*	cDefaultExpression:			the default expression for GETEXPR
		*	cErrorMessage:				the message to display if the expression is
		*								invalid
		*	cExpressionType:			the data type of a valid expression (default =
		*								L)
		*	cResult:					the name of the control to put the return value
		*								from GETEXPR into
		*	lLiteral:					.T. if the expression is to be treated as a
		*								literal (that is, quotes should be added around
		*								it)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* Display a GETEXPR dialog, using parameters determined from the properties
		* of this object.
		
		local lcDataType, ;
			lnCurrSelect, ;
			lcAlias, ;
			lcDefault, ;
			lcQuote, ;
			lcResult
		
		* If the location to store the result wasn't defined, display an error.
		
		with This
			if empty(.cResult)
				messagebox('The result container was not defined.', 0, _screen.Caption)
		
		* Build a string of parameters from the properties of this object. If an alias
		* was specified and it's open, select it.
		
			else
				lcDataType = iif(empty(.cExpressionType), '', 'type "' + ;
					.cExpressionType) + iif(empty(.cErrorMessage), '', ';' + ;
					.cErrorMessage)
				lcDataType = iif(empty(lcDataType), '', lcDataType + '"')
				lnCurrSelect = select()
				if not empty(.cAlias)
					lcAlias = evaluate(.cAlias)
					if used(lcAlias)
						select (lcAlias)
					endif used(lcAlias)
				endif not empty(.cAlias) ...
		
		* If the default expression starts with "=", strip it off. If not, put quotes
		* around it.
		
				lcDefault = alltrim(evaluate(.cDefaultExpression))
				do case
					case not .lLiteral or empty(lcDefault)
					case left(lcDefault, 1) = '='
						lcDefault = substr(lcDefault, 2)
					case left(lcDefault, 1) <> '"' and left(lcDefault, 1) <> "'"
						lcQuote   = iif('"' $ lcDefault, "'", '"')
						lcDefault = lcQuote + lcDefault + lcQuote
				endcase
		
		* Use the GETEXPR command.
		
				getexpr .cCaptionText to lcResult &lcDataType default lcDefault
		
		* Remove the quotes or add an "=" to the expression.
		
				do case
					case not .lLiteral or empty(lcResult)
					case left(lcResult, 1) = '"' or left(lcResult, 1) = "'"
						lcResult = substr(lcResult, 2, len(lcResult) - 2)
					otherwise
						lcResult = '=' + lcResult
				endcase
		
		* Store the result in the specified location.
		
				store lcResult to (.cResult)
		 
		* If a method or function was specified to execute after GETEXPR, do it.
		* Reselect the former work area.
		
				if not empty(.cAfterDone)
					= evaluate(.cAfterDone)
				endif not empty(.cAfterDone)
				select (lnCurrSelect)
			endif empty(.cResult)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorergetfile AS projectexplorerpicturebutton OF "projectexplorerbutton.vcx" 		&& A CommandButton that displays a GETFILE() dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: filechanged		&& Fired when the filename is changed interactively
		*p: cafterdone		&& An expression to evaluate after the file has been selected
		*p: ccaption		&& The caption for the dialog
		*p: cdefault		&& The expression for the default filename for the dialog (ignored if lUseCommonDialog is .F.; surround literal string with quotes)
		*p: cextensions		&& The extensions parameter for GETFILE() or if lUseCommonDialog, extensions in the format "Descrip,*.EXT;Descrip,*.EXT" (surround literal strings in quotes)
		*p: cinitialdirectory		&& The initial directory for the file dialog
		*p: copenbutton		&& The text to use for the Open button (ignored if lUseCommonDialog is .T.)
		*p: cresult		&& The location where to put the return value into
		*p: ctext		&& The text to appear beside the filename in the dialog (ignored if lUseCommonDialog is .T.)
		*p: lsavedialog		&& .T. to use a Save dialog, .F. to use an Open dialog
		*p: lusecommondialog		&& .T. to use the CommonDialog control (requires SFCommonDialog in SFUtility.vcx)
		*p: nbuttontype		&& The button type parameter for GETFILE()
	*</DefinedPropArrayMethod>

	*<PropValue>
		cafterdone = 
		Caption = "..."
		ccaption = 
		cdefault = 
		cextensions = 
		cinitialdirectory = 
		copenbutton = 
		cresult = 
		ctext = 
		lsavedialog = .F.
		lusecommondialog = .T.
		Name = "projectexplorergetfile"
		nbuttontype = 0
		StatusBarText = "Select a file and path"
		ToolTipText = "Select a file and path"
		_memberdata = <VFPData>
			<memberdata name="cafterdone" type="property" display="cAfterDone" favorites="True"/>
			<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
			<memberdata name="cdefault" type="property" display="cDefault" favorites="True"/>
			<memberdata name="cextensions" type="property" display="cExtensions" favorites="True"/>
			<memberdata name="copenbutton" type="property" display="cOpenButton" favorites="True"/>
			<memberdata name="cresult" type="property" display="cResult" favorites="True"/>
			<memberdata name="ctext" type="property" display="cText" favorites="True"/>
			<memberdata name="lusecommondialog" type="property" display="lUseCommonDialog" favorites="True"/>
			<memberdata name="nbuttontype" type="property" display="nButtonType" favorites="True"/>
			<memberdata name="lsavedialog" type="property" display="lSaveDialog"/>
			<memberdata name="cinitialdirectory" type="property" display="cInitialDirectory"/>
			<memberdata name="filechanged" display="FileChanged"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerGetFile
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Displays an Open File dialog
		* Author:						Doug Hennig
		* Last revision:				06/26/2018
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	StatusBarText:				Select a file and path
		*	ToolTipText:				Select a file and path
		*
		* Changes in "Based On" class methods:
		*	Click:						displays the dialog, puts the result into the
		*								control defined in cResult, and performs any
		*								processing defined in the cAfterDone expression
		*	Init:						set StatusBarText and ToolTipText
		*
		* Custom public properties added:
		*	cAfterDone:					an expression to evaluate after the file has
		*								been selected
		*	cCaption:					the caption for the dialog
		*	cDefault:					the expression for the default filename for the
		*								dialog (ignored if lUseCommonDialog is .F.;
		*								surround literal string with quotes)
		*	cExtensions:				the extensions parameter for GETFILE() or if
		*								lUseCommonDialog, extensions in the format
		*								"Descrip,*.,EXT;Descrip,*.EXT" (surround
		*								literal strings in quotes)
		*	cOpenButton:				the text to use for the Open button (ignored if
		*								lUseCommonDialog is .T.)
		*	cResult:					the name of the control to put the return value
		*								into
		*	cText:						the text to appear beside the filename in the
		*								dialog (ignored if lUseCommonDialog is .T.)
		*	lSaveDialog:				.T. to use a Save dialog, .F. to use an Open
		*								dialog
		*	lUseCommonDialog:			.T. to use the CommonDialog control (requires
		*								ProjectExplorerCommonDialog in
		*								ProjectExplorerCommonDialog.vcx)
		*	nButtonType:				the button type parameter for GETFILE()
		*								(default = 0)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	FileChanged:				Fired when the filename is changed
		*								interactively
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* Display an Open File dialog, using parameters determined from the properties
		* of this object.
		
		local lcResult, ;
			lcLibrary, ;
			loDialog, ;
			laTypes[1], ;
			lnTypes, ;
			lnI, ;
			lcExt, ;
			lnPos, ;
			lcDescrip, ;
			lcExten, ;
			laExt[1], ;
			lnExt, ;
			lnJ, ;
			lcFile, ;
			lcOptions
		with This
			assert not empty(.cResult) ;
				message 'ProjectExplorerGetFile: the result container was not defined.'
			lcResult = .cResult
		
		* If we're using the CommonDialog control, instantiate the
		* ProjectExplorerCommonDialog class, set its properties, and call the
		* ShowDialog method.
		
			lcLibrary = fullpath('ProjectExplorerCommonDialog.vcx', This.ClassLibrary)
			if .lUseCommonDialog and file(lcLibrary)
				loDialog = newobject('ProjectExplorerCommonDialog', lcLibrary)
				if not empty(.cDefault)
					loDialog.cFileName = alltrim(evaluate(.cDefault))
				endif not empty(.cDefault)
				if empty(loDialog.cFileName)
					loDialog.cInitialDirectory = .cInitialDirectory
				endif empty(loDialog.cFileName)
		
		* Extensions are formatted as Description (*.ext), ext; Description (*.ext), ext
		* If there are multiple extensions for a given type, format it as:
		* Description (*.ext1 | *.ext2), ext1|ext2; Description (*.ext), ext
		* The "|" in the description will be replaced with a ;.
		
				if not empty(.cExtensions)
					lnTypes = alines(laTypes, evaluate(.cExtensions), .T., ';')
					loDialog.ClearFilters(.T.)
					for lnI = 1 to lnTypes
						lcExt = laTypes[lnI]
						if ',' $ lcExt
							lnPos     = at(',', lcExt)
							lcDescrip = alltrim(left(lcExt, lnPos - 1))
							lcExten   = alltrim(substr(lcExt, lnPos + 1))
						else
							lcDescrip = alltrim(lcExt)
							lcExten   = '*.' + lcExt
						endif ',' $ lcExt
		
		* There may be multiple extensions for this filter type, so handle that.
		
						lnExt   = alines(laExt, lcExten, .T., '|')
						lcExten = ''
						for lnJ = 1 to lnExt
							lcExten = lcExten + iif(empty(lcExten), '', ';') + laExt[lnJ]
						next lnJ
						if upper(justext(loDialog.cFileName)) $ upper(lcExten)
							loDialog.nFilterIndex = lnI
						endif upper(justext(loDialog.cFileName)) $ upper(lcExten)
						lcDescrip = strtran(lcDescrip, '|', ';')
						loDialog.AddFilter(lcDescrip, lcExten)
					next lnI
				endif not empty(.cExtensions)
				loDialog.cTitleBarText = .cCaption
				loDialog.lSaveDialog   = .lSaveDialog
				loDialog.ShowDialog()
				lcFile = addbs(loDialog.cFilePath) + loDialog.cFileTitle
			else
		
		* We're using GETFILE(), so build a string of parameters from the properties
		* of this object and call GETFILE().
		
				lcOptions = iif(empty(.cExtensions), "''", .cExtensions) + ',' + ;
					iif(empty(.cText), "''", "'" + .cText + "'") + ',' + ;
					iif(empty(.cOpenButton), "''", "'" + .cOpenButton + "'") + ',' + ;
					iif(empty(.nButtonType), '0', transform(.nButtonType)) + ;
					iif(empty(.cCaption), '', ",'" + .cCaption + "'")
				lcFile = getfile(&lcOptions)
			endif .lUseCommonDialog ...
		
		* If the user chose a file, store the result in the specified location.
		
			if not empty(lcFile)
				store lcFile to (lcResult)
		
		* If a method or function was specified to execute after file selection, do it.
		
				if not empty(.cAfterDone)
					evaluate(.cAfterDone)
				endif not empty(.cAfterDone)
			endif not empty(lcFile)
		
		* Call FileChanged so any custom code can be executed.
		
			.FileChanged()
		endwith
		
	ENDPROC

	PROCEDURE filechanged		&& Fired when the filename is changed interactively
		* Abstract method.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorergetfiletext AS projectexplorergetfile OF "projectexplorerbutton.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Caption = "Browse..."
		Height = 27
		Name = "projectexplorergetfiletext"
		Width = 84
	*</PropValue>

ENDDEFINE

DEFINE CLASS projectexplorergetfont AS projectexplorercommandbutton OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: getfont		&& Displays a dialog so the user can select the font
		*p: cfontname		&& The font name
		*p: lfontbold		&& .T. if the font is bold
		*p: lfontitalic		&& .T. if the font is italic
		*p: nfontcharset		&& The font charset chosen by the user
		*p: nfontsize		&& The font size
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = "Font..."
		cfontname = Arial
		lfontbold = .F.
		lfontitalic = .F.
		Name = "projectexplorergetfont"
		nfontcharset = 1
		nfontsize = 8
		_memberdata = <VFPData>
			<memberdata name="cfontname" type="property" display="cFontName"/>
			<memberdata name="lfontbold" type="property" display="lFontBold"/>
			<memberdata name="lfontitalic" type="property" display="lFontItalic"/>
			<memberdata name="nfontsize" type="property" display="nFontSize"/>
			<memberdata name="getfont" type="method" display="GetFont"/>
			<memberdata name="nfontcharset" display="nFontCharSet"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Click
		This.GetFont()
		
	ENDPROC

	PROCEDURE getfont		&& Displays a dialog so the user can select the font
		local lcFontName, ;
			lnFontSize, ;
			lcStyle, ;
			lnFontCharSet, ;
			lcFont, ;
			lnPos1, ;
			lnPos2, ;
			lnPos3, ;
			llReturn
		with This
			lcFontName    = evl(.cFontName, 'Arial')
			lnFontSize    = evl(.nFontSize, 10)
			lcStyle       = iif(.lFontBold, 'B', '') + iif(.lFontItalic, 'I', '')
			lnFontCharSet = iif(.nFontCharSet < 0, 1, .nFontCharSet)
			try
				lcFont  = getfont(lcFontName, lnFontSize, lcStyle, lnFontCharSet)
			catch
			endtry
			if not empty(lcFont)
				lnPos1        = at(',', lcFont)
				lnPos2        = at(',', lcFont, 2)
				lnPos3        = at(',', lcFont, 3)
				.cFontName    = left(lcFont, lnPos1 - 1)
				.nFontSize    = val(substr(lcFont, lnPos1 + 1, lnPos2 - lnPos1 - 1))
				lcStyle       = substr(lcFont, lnPos2 + 1, lnPos3 - lnPos2 - 1)
				.lFontBold    = 'B' $ lcStyle
				.lFontItalic  = 'I' $ lcStyle
				.nFontCharSet = val(substr(lcFont, lnPos3 + 1))
				llReturn      = .T.
			endif not empty(lcFont)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorergetpicture AS projectexplorercommandbutton OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Caption = ""
		Height = 40
		Name = "projectexplorergetpicture"
		Width = 40
	*</PropValue>
	
	PROCEDURE Click
		local lcPicture
		lcPicture = getpict('BMP|ICO')
		if not empty(lcPicture)
			This.Picture = lcPicture
		endif not empty(lcPicture)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerhelpbutton AS projectexplorercommandbutton OF "projectexplorerctrls.vcx" 		&& A CommandButton that brings up help
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Caption = "Help"
		Name = "projectexplorerhelpbutton"
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerHelpButton
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Brings up the Windows Help
		* Author:						Doug Hennig
		* Last revision:				05/25/2009
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	Caption:					Help
		*
		* Changes in "Based On" class methods:
		*	Click:						issues a HELP command
		*	Init:						set Caption
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		if Thisform.HelpContextID = 0
			help
		else
			help id Thisform.HelpContextID
		endif Thisform.HelpContextID = 0
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerokbutton AS projectexplorercommandbutton OF "projectexplorerctrls.vcx" 		&& A CommandButton that displays OK
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Caption = "OK"
		Default = .T.
		Name = "projectexplorerokbutton"
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerOKButton
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Provides an OK button
		* Author:						Doug Hennig
		* Last revision:				01/14/2015
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	Caption:					OK
		*	Default:					.T.
		*
		* Changes in "Based On" class methods:
		*	Click:						hides the form
		*	Init:						set Caption
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		Thisform.Hide()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerpicturebutton AS projectexplorercommandbutton OF "projectexplorerctrls.vcx" 		&& The base class for CommandButtons with a picture
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Caption = ""
		Height = 23
		Name = "projectexplorerpicturebutton"
		Width = 23
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerPictureButton
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Base class for all CommandButton objects with
		*								pictures
		* Author:						Doug Hennig
		* Last revision:				01/26/2005
		* Include file:					none
		*
		* Changes in base class properties:
		*	Caption:					None so only a picture will be used
		*	Height:						23
		*	Width:						23
		*
		* Changes in base class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerputfile AS projectexplorerpicturebutton OF "projectexplorerbutton.vcx" 		&& A CommandButton that displays a PUTFILE() dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cafterdone		&& An expression to evaluate after the file has been selected
		*p: ccaption		&& The caption for the dialog (ignored if lUseCommonDialog is .F.)
		*p: cdefault		&& The default filename for the dialog (surround literal string with quotes)
		*p: cextensions		&& The extensions parameter for PUTFILE() or if lUseCommonDialog, extensions in the format "Descrip,*.EXT;Descrip,*.EXT" (surround literal strings in quotes)
		*p: cresult		&& The location where to put the return value into
		*p: ctext		&& The text to appear beside the filename in the dialog (ignored if lUseCommonDialog is .T.)
		*p: lusecommondialog		&& .T. to use the CommonDialog control (requires SFCommonDialog in SFUtility.vcx)
	*</DefinedPropArrayMethod>

	*<PropValue>
		cafterdone = 
		Caption = "..."
		ccaption = 
		cdefault = 
		cextensions = 
		cresult = 
		ctext = 
		lusecommondialog = .T.
		Name = "projectexplorerputfile"
		StatusBarText = "Select a file and path"
		ToolTipText = "Select a file and path"
		_memberdata = <VFPData>
			<memberdata name="cafterdone" type="property" display="cAfterDone" favorites="True"/>
			<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
			<memberdata name="cdefault" type="property" display="cDefault" favorites="True"/>
			<memberdata name="cextensions" type="property" display="cExtensions" favorites="True"/>
			<memberdata name="cresult" type="property" display="cResult" favorites="True"/>
			<memberdata name="ctext" type="property" display="cText" favorites="True"/>
			<memberdata name="lusecommondialog" type="property" display="lUseCommonDialog" favorites="True"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerPutFile
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Displays a Save File dialog
		* Author:						Doug Hennig
		* Last revision:				06/26/2018
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	StatusBarText:				Select a file and path
		*	ToolTipText:				Select a file and path
		*
		* Changes in "Based On" class methods:
		*	Click:						displays the dialog, puts the result into the
		*								control defined in cResult, and performs any
		*								processing defined in the cAfterDone expression
		*	Init:						set StatusBarText and ToolTipText
		*
		* Custom public properties added:
		*	cAfterDone:					an expression to evaluate after the file has
		*								been selected
		*	cCaption:					the caption for the dialog (ignored if
		*								lUseCommonDialog is .F.)
		*	cDefault:					the default filename for the dialog (surround
		*								literal string with quotes)
		*	cExtensions:				the extensions parameter for PUTFILE() or if
		*								lUseCommonDialog, extensions in the format
		*								"Descrip,*.,EXT;Descrip,*.EXT" (surround
		*								literal strings in quotes)
		*	cResult:					the name of the control to put the return value
		*								into
		*	cText:						the text to appear beside the filename in the
		*								dialog (ignored if lUseCommonDialog is .T.)
		*	lUseCommonDialog:			.T. to use the CommonDialog control (requires
		*								ProjectExplorerCommonDialog in
		*								ProjectExplorerCommonDialog.vcx)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* Display a Save File dialog, using parameters determined from the properties
		* of this object.
		
		local lcResult, ;
			lcLibrary, ;
			loDialog, ;
			laTypes[1], ;
			lnTypes, ;
			lnI, ;
			lcExt, ;
			lnPos, ;
			lcDescrip, ;
			lcExten, ;
			laExt[1], ;
			lnExt, ;
			lnJ, ;
			lcExt1, ;
			lcFile, ;
			lcOptions
		with This
			assert not empty(.cResult) ;
				message 'SFGetFile: the result container was not defined.'
			lcResult = .cResult
		
		* If we're using the CommonDialog control, instantiate the SFCommonDialog
		* class, set its properties, and call the ShowDialog method.
		
			lcLibrary = fullpath('ProjectExplorerCommonDialog.vcx', This.ClassLibrary)
			if .lUseCommonDialog and file(lcLibrary)
				loDialog = newobject('ProjectExplorerCommonDialog', lcLibrary)
				if not empty(.cDefault)
					loDialog.cFileName = alltrim(evaluate(.cDefault))
				endif not empty(.cDefault)
		
		* Extensions are formatted as Description (*.ext), ext; Description (*.ext), ext
		* If there are multiple extensions for a given type, format it as:
		* Description (*.ext1 | *.ext2), ext1|ext2; Description (*.ext), ext
		* The "|" in the description will be replaced with a ;.
		
				if not empty(.cExtensions)
					lnTypes = alines(laTypes, evaluate(.cExtensions), .T., ';')
					loDialog.ClearFilters(.T.)
					for lnI = 1 to lnTypes
						lcExt = laTypes[lnI]
						if ',' $ lcExt
							lnPos     = at(',', lcExt)
							lcDescrip = alltrim(left(lcExt, lnPos - 1))
							lcExten   = alltrim(substr(lcExt, lnPos + 1))
						else
							lcDescrip = alltrim(lcExt)
							lcExten   = '*.' + lcExt
						endif ',' $ lcExt
		
		* There may be multiple extensions for this filter type, so handle that.
		
						lnExt   = alines(laExt, lcExten, .T., '|')
						lcExten = ''
						for lnJ = 1 to lnExt
							lcExten = lcExten + iif(empty(lcExten), '', ';') + laExt[lnJ]
						next lnJ
						if upper(justext(loDialog.cFileName)) $ upper(justext(lcExten))
							loDialog.nFilterIndex = lnI
						endif upper(justext(loDialog.cFileName)) $ upper(justext(lcExten))
						lcExt1 = strtran(lcDescrip, '|', ';')
						loDialog.AddFilter(lcExt1, lcExten)
					next lnI
				endif not empty(.cExtensions)
				loDialog.cTitleBarText = .cCaption
				loDialog.lSaveDialog   = .T.
				loDialog.ShowDialog()
				lcFile = addbs(loDialog.cFilePath) + loDialog.cFileTitle
			else
		
		* We're using PUTFILE(), so build a string of parameters from the properties
		* of this object and call PUTFILE().
		
				lcOptions = iif(empty(.cText), "''", "'" + .cText+ "'") + ',' + ;
					iif(empty(.cDefault), '', .cDefault) + ',' + ;
					iif(empty(.cExtensions), '', .cExtensions)
				lcFile = putfile(&lcOptions)
			endif .lUseCommonDialog
		
		* If the user chose a file, store the result in the specified location.
		
			if not empty(lcFile)
				store lcFile to (lcResult)
		
		* If a method or function was specified to execute after file selection, do it.
		
				if not empty(.cAfterDone)
					evaluate(.cAfterDone)
				endif not empty(.cAfterDone)
			endif not empty(lcFile)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorertoolbarbutton AS projectexplorercommandbutton OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Caption = ""
		Height = 22
		Name = "projectexplorertoolbarbutton"
		SpecialEffect = 2
		Width = 22
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerToolbarButton
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Base class for all buttons used in toolbars
		* Author:						Doug Hennig
		* Last revision:				06/27/2016
		* Include file:					none
		*
		* Changes in base class properties:
		*	Caption:					None so only a picture will be used
		*	Height:						22
		*	SpecialEffect:				2-Hot Tracking
		*	Width:						22
		*
		* Changes in base class methods:
		*	Click:						set focus to something else if we're in a form
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* If we're in a form rather than a toolbar, we can get focus, so set focus to
		* something else.
		
		if upper(Thisform.BaseClass) = 'FORM'
			This.VisualEffect = 0
			if pemstatus(Thisform, 'SetFocusToFirstObject', 5)
				Thisform.SetFocusToFirstObject(Thisform, .T.)
			endif pemstatus(Thisform, 'SetFocusToFirstObject', 5)
		endif upper(Thisform.BaseClass) = 'FORM'
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorertoolbarbuttontext AS projectexplorercommandbutton OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Height = 42
		Name = "projectexplorertoolbarbuttontext"
		SpecialEffect = 2
		Width = 62
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerToolbarButtonText
		* Based On:						ProjectExplorerCommandButton (ProjectExplorerCtrls.VCX)
		* Purpose:						Base class for buttons with text used in
		*								toolbars
		* Author:						Doug Hennig
		* Last revision:				11/25/2005
		* Include file:					none
		*
		* Changes in base class properties:
		*	Height:						42
		*	SpecialEffect:				2-Hot Tracking
		*	Width:						62
		*
		* Changes in base class methods:
		*	Click:						set focus to something else if we're in a form
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* If we're in a form rather than a toolbar, we can get focus, so set focus to
		* something else.
		
		if upper(Thisform.BaseClass) = 'FORM'
			This.VisualEffect = 0
			Thisform.SetFocusToFirstObject(Thisform, .T.)
		endif upper(Thisform.BaseClass) = 'FORM'
		
	ENDPROC

ENDDEFINE
