*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="projectexplorerctrls.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS projectexplorercheckbox AS checkbox 		&& Base class for CheckBox objects
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*m: validation		&& Abstract method for custom validation code
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: lskipvalidonformclose		&& .T. if we can skip validating this control when the form is closed
		*p: lupdatecontrolsource		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	Alignment = 0
	AutoSize = .T.
	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	Caption = "Check1"
	FontName = "Tahoma"
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	lskipvalidonformclose = .T.		&& .T. if we can skip validating this control when the form is closed
	lupdatecontrolsource = .T.		&& .T. if UpdateControlSource should be called from InteractiveChange
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorercheckbox"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	Value = .F.
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About" favorites="True"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource" favorites="True"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
		<memberdata name="lsaveanchor" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" display="lSaveAnchor_Assign"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerCheckBox
		* Based On:						CheckBox
		* Purpose:						Base class for all CheckBox objects
		* Author:						Doug Hennig
		* Last revision:				12/02/2008
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	AutoSize:					.T.
		*	BackStyle:					0 (Transparent)
		*	FontName:					Tahoma
		*	Value:						.F. since checkboxes usually are used for
		*								logical values
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						ensure the object is wide enough to display the
		*								caption by resetting AutoSize. Bind
		*								InteractiveChangeto the form's AnyChange method
		*								and bind OnFormChange to the form's lChanged
		*								property if necessary. Change FontName to
		*								Segoe UI in Vista
		*	InteractiveChange:			raises the AnyChange event
		*	KeyPress:					ignore Ctrl-0
		*	ProgrammaticChange:			raises the AnyChange event
		*	RightClick:					call This.ShowMenu
		*	Valid:						prevent validation code from executing if the
		*								user is cancelling, retain focus if a field
		*								rule failed, and call the custom Validation
		*								method
		*	When:						prevent the control from receiving focus in a
		*								read-only column
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
		*								its form's AnyChange method
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
		*								the form is closed
		*	lUpdateControlSource:		.T. if UpdateControlSource should be called
		*								from InteractiveChange
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AnyChange:					called from the InteractiveChange and
		*								ProgrammaticChange events to consolidate
		*								change code in one place
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateControlSource:		updates the ControlSource with the new value
		*	Validation:					abstract method for custom validation code
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		* Abstract method.
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
			if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'AnyChange', 5)
				bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
			endif .lBindToFormAnyChange ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Update the control source in case something binding to our AnyChange event
		* looks at it.
		
		if This.lUpdateControlSource
			This.UpdateControlSource()
		endif This.lUpdateControlSource
		
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Public
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Last revision:	01/24/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Last revision:	08/20/2002
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(This.lSkipValidOnFormClose and ;
			type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& Abstract method for custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE When
		* Prevent the checkbox from receiving focus in a read-only column.
		
		return (upper(This.Parent.BaseClass) <> 'COLUMN' or not This.Parent.ReadOnly)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercheckboxgraphical AS projectexplorercheckbox OF "projectexplorerctrls.vcx" 		&& Graphical CheckBox
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Alignment = 0
	AutoSize = .F.
	Caption = ""
	Height = 23
	Name = "projectexplorercheckboxgraphical"
	Style = 1
	Width = 23
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerCheckBoxGraphical
		* Based On:						ProjectExplorerCheckBox
		* Purpose:						Graphical CheckBox
		* Author:						Doug Hennig
		* Last revision:				03/12/2010
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	AutoSize:					.F.
		*	Caption:					None
		*	Height:						23
		*	Style:						1 (Graphical)
		*	Width:						23
		*
		* Changes in "Based On" class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercollection AS collection 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: additem		&& Adds an item (backward compatibility)
		*m: calledfromthisclass		&& Determines if the method that called this method was called from a method of this class or an ancestor
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: clear		&& Clears the collection
		*m: fillarrayrow		&& Fills the specified row in the passed array with information about the current item
		*m: fillcollection		&& Loads the collection from persistent storage
		*m: getarray		&& Fills the passed array with information about objects in the collection
		*m: release		&& Releases the object
		*m: releasemembers		&& Abstract method to nuke member references
		*m: removeitem		&& Removes an item (backward compatibility)
		*m: savecollection		&& Saves the collection to persistent storage
		*m: saveitem		&& Saves the specified item to persistent storage
		*p: cerrormessage		&& The text of an error message
		*p: lerroroccurred		&& .T. if an error occurred
		*p: lfilloninit		&& .T. if we're supposed to fill the collection when it's instantiated
		*p: lrelease		&& .T. as the object is being released
		*p: oexception		&& A reference to an Exception object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	cerrormessage = 		&& The text of an error message
	Height = 23
	lerroroccurred = .F.		&& .T. if an error occurred
	lrelease = .F.		&& .T. as the object is being released
	Name = "projectexplorercollection"
	oexception = .NULL.		&& A reference to an Exception object
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="clear" type="method" display="Clear"/>
		<memberdata name="fillarrayrow" type="method" display="FillArrayRow" favorites="True"/>
		<memberdata name="fillcollection" type="method" display="FillCollection"/>
		<memberdata name="getarray" type="method" display="GetArray"/>
		<memberdata name="lfilloninit" type="property" display="lFillOnInit" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="savecollection" type="method" display="SaveCollection"/>
		<memberdata name="saveitem" type="method" display="SaveItem" favorites="True"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
		<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="additem" type="method" display="AddItem"/>
		<memberdata name="removeitem" type="method" display="RemoveItem"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerCollection
		* Based On:						Collection
		* Purpose:						Base class for all Collection objects
		* Author:						Doug Hennig
		* Last revision:				10/06/2008
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Add:						store upper-cased key so case-insensitive and
		*									ignore duplicate keys
		*	Destroy:					cleanup as the object is destroyed
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	GetKey:						handle case-insensitivity
		*	Init:						calls FillCollection if lFillOnInit is .T.
		*	Item:						return .NULL. if the item isn't found and
		*								handle case-insensitivity
		*	Remove:						handle case-insensitivity
		*
		* Custom public properties added:
		*	cErrorMessage:				the message of an error
		*	lErrorOccurred:				.T. if an error occurred
		*	lFillOnInit:				.T. if we're supposed to fill the collection
		*								when it's instantiated
		*	oException:					a reference to an Exception object
		*
		* Custom protected properties added:
		*	lRelease:					.T. as the object is being released
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AddItem:					adds an item (backward compatibility)
		*	Clear:						clears the collection
		*	GetArray:					fills the passed array with information about
		*								objects in the collection
		*	FillCollection:				loads the collection from persistent storage
		*	Release:					releases the object
		*	ReleaseMembers:				abstract method to nuke member references
		*	RemoveItem:					removes an item (backward compatibility)
		*	SaveCollection:				saves the collection to persistent storage
		*	SaveItem:					saves the specified item to persistent storage
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*	FillArrayRow:				fills the specified row in the passed array
		*								with information about the current item
		*==============================================================================
		
	ENDPROC

	PROCEDURE Add
		lparameters tuItem, ;
			tcKey, ;
			tuBefore, ;
			tuAfter
		local lcKey
		do case
			case pcount() = 1
				dodefault(tuItem)
			case vartype(tcKey) = 'C'
				lcKey = upper(alltrim(tcKey))
				do case
					case This.GetKey(lcKey) > 0
					case pcount() = 2
						dodefault(tuItem, lcKey)
					case pcount() = 3
						dodefault(tuItem, lcKey, tuBefore)
					case pcount() = 4
						dodefault(tuItem, lcKey, tuBefore, tuAfter)
				endcase
			case pcount() = 3
				dodefault(tuItem, tcKey, tuBefore)
			case pcount() = 4
				dodefault(tuItem, tcKey, tuBefore, tuAfter)
		endcase
		nodefault
		
	ENDPROC

	PROCEDURE additem		&& Adds an item (backward compatibility)
		lparameters tuItem, ;
			tcKey, ;
			tuBefore, ;
			tuAfter
		local luReturn
		do case
			case pcount() = 1
				luReturn = This.Add(tuItem)
			case pcount() = 2
				luReturn = This.Add(tuItem, tcKey)
			case pcount() = 3
				luReturn = This.Add(tuItem, tcKey, tuBefore)
			case pcount() = 4
				luReturn = This.Add(tuItem, tcKey, tuBefore, tuAfter)
		endcase
		return luReturn
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Determines if the method that called this method was called from a method of this class or an ancestor
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Last Revision:	01/29/2005
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Last Revision:	01/29/2005
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE clear		&& Clears the collection
		This.Remove(-1)
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROTECTED PROCEDURE fillarrayrow		&& Fills the specified row in the passed array with information about the current item
		lparameters taArray, ;
			tnItem, ;
			toItem
		taArray[tnItem] = toItem
		
	ENDPROC

	PROCEDURE fillcollection		&& Loads the collection from persistent storage
		* Abstract method
		
	ENDPROC

	PROCEDURE getarray		&& Fills the passed array with information about objects in the collection
		lparameters taArray
		local lnItem, ;
			loItem
		if This.Count > 0
			dimension taArray[This.Count]
		else
			dimension taArray[1]
		endif This.Count > 0
		lnItem = 0
		for each loItem in This foxobject
			lnItem = lnItem + 1
			This.FillArrayRow(@taArray, lnItem, loItem)
		next loItem
		return This.Count
		
	ENDPROC

	PROCEDURE GetKey
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex  = upper(alltrim(tuIndex))
			luReturn = dodefault(lcIndex)
		else
			luReturn = dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE Init
		* Fill the collection if we're supposed to.
		
		with This
			if .lFillOnInit
				.FillCollection()
			endif .lFillOnInit
		endwith
		
	ENDPROC

	PROCEDURE Item
		lparameters tuIndex
		local luReturn, ;
			lcIndex
		luReturn = .NULL.
		if vartype(tuIndex) = 'C'
			lcIndex = upper(alltrim(tuIndex))
			if This.GetKey(lcIndex) > 0
				luReturn = dodefault(lcIndex)
			endif This.GetKey(lcIndex) > 0
		else
			try
				luReturn = dodefault(tuIndex)
			catch
			endtry
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method
		
	ENDPROC

	PROCEDURE Remove
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex = upper(alltrim(tuIndex))
			if This.GetKey(lcIndex) > 0
				dodefault(lcIndex)
			endif This.GetKey(lcIndex) > 0
		else
			dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		
	ENDPROC

	PROCEDURE removeitem		&& Removes an item (backward compatibility)
		lparameters tuIndex
		return This.Remove(tuIndex)
		
	ENDPROC

	PROCEDURE savecollection		&& Saves the collection to persistent storage
		local loItem
		for each loItem in This foxobject
			This.SaveItem(loItem)
		next loItem
		
	ENDPROC

	PROCEDURE saveitem		&& Saves the specified item to persistent storage
		* Abstract method
		
		lparameters toItem
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercollectiononeclass AS projectexplorercollection OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: isvalidname		&& Returns .T. if the name of a new item is valid
		*p: citemclass		&& The class to create items from
		*p: citemlibrary		&& The library containing the class specified in cItemClass
	*</DefinedPropArrayMethod>

	citemclass = 		&& The class to create items from
	citemlibrary = 		&& The library containing the class specified in cItemClass
	Name = "projectexplorercollectiononeclass"
	_memberdata = <VFPData>
		<memberdata name="citemclass" type="property" display="cItemClass" favorites="True"/>
		<memberdata name="citemlibrary" type="property" display="cItemLibrary" favorites="True"/>
		<memberdata name="isvalidname" type="method" display="IsValidName"/>
		</VFPData>
	
	PROCEDURE Add
		lparameters tuItem, ;
			tcKey, ;
			tuBefore, ;
			tuAfter
		local loItem, ;
			lcName
		with This
		
		* If an object was specified for the first parameter, use it and get the name
		* from the second parameter.
		
			if vartype(tuItem) = 'O'
				loItem = tuItem
				lcName = tcKey
		
		* No object was specified, so create one and get the name from the first
		* parameter.
		
			else
				loItem = newobject(.cItemClass, .cItemLibrary)
				lcName = tuItem
			endif vartype(tuItem) = 'O'
		
		* Set the cName property if there is one.
		
			if not empty(lcName) and pemstatus(loItem, 'cName', 5)
				loItem.cName = lcName
			endif not empty(lcName) ...
		
		* Set the Name property is there is one and we have a valid name (assuming we
		* don't have any Empty object, in which case we don't care if the name is
		* valid).
		
			do case
				case not pemstatus(loItem, 'Name', 5)
				case not empty(lcName) and (not pemstatus(loItem, 'Class', 5) or ;
					.IsValidName(lcName))
					loItem.Name = lcName
				otherwise
					loItem.Name = sys(2015)
			endcase
		
		* Add the item to the collection and return a reference to it.
		
			if empty(lcName)
				dodefault(loItem)
			else
				dodefault(loItem, lcName)
				loItem = .Item(lcName)
			endif empty(lcName)
			nodefault
		endwith
		return loItem
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcReturn
		
		* Ignore "key must be specified" or "not an array" errors.
		
		if tnError = cnERR_KEY_MUST_BE_SPECIFIED or tnError = cnERR_NOT_AN_ARRAY
		
		* Use the normal error handling mechanism for all other types of errors. Note
		* that we add a period to the method name passed. This tells our parent class
		* to return the error resolution string back to us, which is required for RETRY
		* to work.
		
		else
			lcReturn = dodefault(tnError, '.' + tcMethod, tnLine)
			lcReturn = iif(vartype(lcReturn) <> 'C', ccMSG_CONTINUE, lcReturn)
			do case
		
		* It wasn't our error, so pass it back to the calling method.
		
				case '.' $ tcMethod
					return lcReturn
		
		* Handle the error choices.
		
				case lcReturn = ccMSG_RETRY
					retry
				case lcReturn = ccMSG_DEBUG
					debug
					if wexist('Visual FoxPro Debugger')
						keyboard '{SHIFT+F7}' plain
					endif wexist('Visual FoxPro Debugger')
					suspend
				case lcReturn = ccMSG_CANCEL
					cancel
				otherwise
					return
			endcase
		endif tnError = cnERR_KEY_MUST_BE_SPECIFIED ...
		
	ENDPROC

	PROCEDURE fillarrayrow
		lparameters taArray, ;
			tnItem, ;
			toItem
		taArray[tnItem] = toItem.Name
		
	ENDPROC

	PROTECTED PROCEDURE isvalidname		&& Returns .T. if the name of a new item is valid
		*==============================================================================
		* Method:			IsValidName
		* Status:			Protected
		* Purpose:			Returns .T. if the name of a new item is valid
		* Author:			Doug Hennig
		* Last revision:	02/02/2004
		* Parameters:		tcName - the name to assign to the item
		* Returns:			.T. if the name is valid
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcName
		local llReturn, ;
			lnI, ;
			lcChar
		llReturn = .T.
		for lnI = 1 to len(tcName)
			lcChar = substr(tcName, lnI, 1)
			if not isalpha(lcChar) and not (lnI > 1 and isdigit(lcChar))
				llReturn = .F.
				exit
			endif not isalpha(lcChar) ...
		next lnI
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercombobox AS combobox 		&& Base class for ComboBox objects
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the control source
		*m: validation		&& An abstract method for custom validation code
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: ccollectionobjectproperty		&& The property of objects in the collection specified by oRowSourceCollection used to fill the combobox
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lrequeryoninit		&& .T. to call Requery from Init
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: lskipvalidonformclose		&& .T. if we can skip validating this control when the form is closed
		*p: lupdatecontrolsource		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: orowsourcecollection		&& A reference to a Collection object that provides the row source elements
		*a: aitems[1,0]		&& An array that can hold the values used for the ComboBox when RowSourceType is 5
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	BoundTo = .T.
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	ccollectionobjectproperty = 		&& The property of objects in the collection specified by oRowSourceCollection used to fill the combobox
	FontName = "Tahoma"
	ItemTips = .T.
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lrequeryoninit = .T.		&& .T. to call Requery from Init
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	lskipvalidonformclose = .T.		&& .T. if we can skip validating this control when the form is closed
	lupdatecontrolsource = .F.		&& .T. if UpdateControlSource should be called from InteractiveChange
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorercombobox"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	orowsourcecollection = .NULL.		&& A reference to a Collection object that provides the row source elements
	RowSource = "This.aItems"
	RowSourceType = 5
	SelectOnEntry = .T.
	Style = 2
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="aitems" type="property" display="aItems"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="ccollectionobjectproperty" type="property" display="cCollectionObjectProperty" favorites="True"/>
		<memberdata name="lrequeryoninit" type="property" display="lRequeryOnInit" favorites="True"/>
		<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="orowsourcecollection" type="property" display="oRowSourceCollection" favorites="True"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
		<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerComboBox
		* Based On:						ComboBox
		* Purpose:						Base class for all ComboBox objects
		* Author:						Doug Hennig
		* Last revision:				05/25/2017
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	BoundTo:					.T.
		*	FontName:					Tahoma
		*	ItemTips:					.T.
		*	RowSource:					This.aItems (see below)
		*	RowSourceType:				5 (Array)
		*	SelectOnEntry:				.T.
		*	Style:						2 (Dropdown List) because this is what we
		*								usually use
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						initialize This.aItems to blanks and call
		*								This.Requery if This.lRequeryOnInit is .T. Bind
		*								InteractiveChange to the form's AnyChange
		*								method and bind OnFormChange to the form's
		*								lChanged property if necessary. Change FontName
		*								to Segoe UI in Vista
		*	InteractiveChange:			calls UpdateControlSource and raises the
		*								AnyChange event
		*	KeyPress:					ignore Ctrl-0 and backspace at the start of the
		*								control
		*	ProgrammaticChange:			raises the AnyChange event
		*	Requery:					handle RowSourceType = 0-None or 1-Value when
		*								RowSource references an array containing the
		*								values or oRowSourceCollection references a
		*								collection with the values
		*	RightClick:					call This.ShowMenu
		*	Valid:						prevent validation code from executing if the
		*								user is cancelling, retain focus if a field
		*								rule failed, and call the custom Validation
		*								method
		*
		* Custom public properties added:
		*	aItems[1]:					an array that can hold the values used for the
		*								ComboBox when RowSourceType is 5
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	cCollectionObjectProperty:	the property of objects in the collection
		*								specified by oRowSourceCollection used to fill
		*								the combobox
		*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
		*								its form's AnyChange method
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lRequeryOnInit:				.T. to call Requery from Init
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
		*								the form is closed
		*	lUpdateControlSource:		.T. if UpdateControlSource should be called
		*								from InteractiveChange
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*	oRowSourceCollection:		a reference to a Collection object that
		*								provides the row source elements
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AnyChange:					called from the InteractiveChange and
		*								ProgrammaticChange events to consolidate
		*								change code in one place
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateControlSource:		updates the control source
		*	Validation:					abstract method for custom validation code
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		* Abstract method
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		This.oRowSourceCollection = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* Initialize aItems to a blank string if it's empty.
		
			if vartype(.aItems[1]) = 'L'
				.aItems = ''
			endif vartype(.aItems[1]) = 'L'
		
		* Call Requery() if we're supposed to.
		
			if .lRequeryOnInit
				.Requery()
			endif .lRequeryOnInit
		
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
			if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'AnyChange', 5)
				bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
			endif .lBindToFormAnyChange ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Update the control source in case something binding to our AnyChange event
		* looks at it.
		
		if This.lUpdateControlSource
			This.UpdateControlSource()
		endif This.lUpdateControlSource
		
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
		* Prevent backspace from leaving the control.
		
		if tnKeyCode = 127 and This.SelStart = 0 and This.SelLength = 0
		   nodefault
		endif tnKeyCode = 127 ...
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE Requery
		* If RowSource is 0-None or 1-Value but an array specified in RowSource
		* contains values or oRowSourceCollection contains a collection, use AddItem
		* (in the case of 0-None) or set RowSource to a comma-delimited list of values
		* (in the case of 1-Value) from the array or the collection. This allows
		* disabled lines using a prompt of "\-".
		
		lparameters tlNoAction
		local lcRowSource, ;
			llArray, ;
			llColumn, ;
			lnRows, ;
			lnI, ;
			lcItem, ;
			lnJ, ;
			luItem
		with This
			lcRowSource = .RowSource
			if empty(lcRowSource)
				lcRowSource = 'This.aItems'
			endif empty(lcRowSource)
			if not empty(lcRowSource)
				try
					llArray = type(lcRowSource, 1) = 'A'
				catch
				endtry
			endif not empty(lcRowSource)
			do case
		
		* If we're not supposed to do anything or we're not using 0-None or 1-Value, do
		* nothing.
		
				case tlNoAction or not inlist(.RowSourceType, 0, 1)
		
		* Handle items in an array referenced in RowSource. Note that we can't combine
		* the CASE and IF statements or we'll get an error.
		
				case not empty(lcRowSource) and llArray
					if type(lcRowSource + '[1]') = 'C' and ;
						(not empty(&lcRowSource.[1]) or alen(&lcRowSource., 1) > 1)
						if .RowSourceType <> 0
							.RowSource = ''
						endif .RowSourceType <> 0
						.Clear()
						llColumn = alen(&lcRowSource, 2) > 0
						lnRows   = alen(&lcRowSource, 1)
						for lnI = 1 to lnRows
							lcItem = iif(llColumn, &lcRowSource[lnI, 1], ;
								&lcRowSource[lnI])
							if .RowSourceType = 0
								.AddItem(lcItem)
								for lnJ = 2 to .BoundColumn
									.List[.NewIndex, lnJ] = &lcRowSource[lnI, lnJ]
								next lnJ
							else
								.RowSource = .RowSource + iif(lnI = 1, '', ',') + ;
									lcItem
							endif .RowSourceType = 0
						next lnI
					endif type(lcRowSource + '[1]') = 'C' ...
		
		* Handle items in oRowSourceCollection.
		
				case vartype(.oRowSourceCollection) = 'O' and ;
					upper(.oRowSourceCollection.BaseClass) = 'COLLECTION' and ;
					.oRowSourceCollection.Count > 0
					if .RowSourceType <> 0
						.RowSource = ''
					endif .RowSourceType <> 0
					.Clear()
					for each luItem in .oRowSourceCollection foxobject
						if vartype(luItem) = 'O'
							lcItem = evaluate('luItem.' + .cCollectionObjectProperty)
						else
							lcItem = luItem
						endif vartype(luItem) = 'O'
						if .RowSourceType = 0
							.AddItem(lcItem)
						else
							.RowSource = .RowSource + ;
								iif(empty(.RowSource), '', ',') + lcItem
						endif .RowSourceType = 0
					next luItem
			endcase
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	05/25/2017
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		* Abstract method.
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the control source
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Public
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Last revision:	02/27/2006
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Last revision:	08/20/2002
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(This.lSkipValidOnFormClose and ;
			type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercombolistbox AS projectexplorercombobox OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: putintolist		&& Adds the specified value to the list
	*</DefinedPropArrayMethod>

	Name = "projectexplorercombolistbox"
	RowSourceType = 0
	Style = 0
	_memberdata = <VFPData>
		<memberdata name="putintolist" display="PutIntoList"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectExplorerComboListBox
		* Based On:						ProjectExplorerComboBox
		* Purpose:						A dropdown combobox
		* Author:						Doug Hennig
		* Last revision:				01/13/2016
		* Include file:					None
		*
		* Changes in "Based On" class properties:
		*	Style:						0 (Dropdown Combo)
		*
		* Changes in "Based On" class methods:
		*	Validation:					adds an entered item into the list
		*
		* Custom public properties added:
		*	none
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	PutIntoList:				adds the specified value to the list
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE putintolist		&& Adds the specified value to the list
		* Inserts an item into the dropdown list.
		
		lparameters tcValue
		local lcValue, ;
			lnI
		with This
			lcValue = iif(empty(tcValue), ' ', alltrim(tcValue))
			.AddItem(lcValue)
			for lnI = 2 to .BoundColumn
				.List[.NewIndex, lnI] = lcValue
			next lnI
		endwith
		return lcValue
		
	ENDPROC

	PROCEDURE validation
		* If the value just entered is not in the list, add it to the list now.
		
		with This
			if .ListIndex = 0
				.Value = .PutIntoList(.DisplayValue)
			endif .ListIndex = 0
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercommandbutton AS commandbutton 		&& Base class for CommandButton objects
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lcancel		&& .T. if this is used as a "cancel" button (this allows the Valid of a control to not bother doing validation if the user clicked a "cancel" button)
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	Caption = "Command1"
	FontName = "Tahoma"
	Height = 27
	lcancel = .F.		&& .T. if this is used as a "cancel" button (this allows the Valid of a control to not bother doing validation if the user clicked a "cancel" button)
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorercommandbutton"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	Width = 84
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="lcancel" type="property" display="lCancel" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerCommandButton
		* Based On:						CommandButton
		* Purpose:						Base class for all CommandButton objects
		* Author:						Doug Hennig
		* Last revision:				04/27/2007
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	FontName:					Tahoma
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						bind OnFormChange to Thisform.lChanged if
		*								lNotifyOnFormChange is .T. Change FontName to
		*								Segoe UI in Vista
		*	RightClick:					call This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lCancel:					.T. if this button is used as a "cancel" button
		*								(this allows the Valid of a control to not
		*								bother doing validation if the user clicked a
		*								"cancel" button)
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercontainer AS container 		&& Base class for Container objects
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: buildercode		&& Code for a self-contained builder; see notes in the method for instructions
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: enabled_assign
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class) or double-click to call code in BuilderCode *** .BuilderCode(loObject)
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	Anchor = 15
	BackStyle = 0
	BorderWidth = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class) or double-click to call code in BuilderCode *** .BuilderCode(loObject)
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorercontainer"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="buildercode" display="BuilderCode"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerContainer
		* Based On:						Container
		* Purpose:						Base class for all Container objects
		* Author:						Doug Hennig
		* Last revision:				02/02/2010
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	Anchor:						15 (resize height and width)
		*	BackStyle:					0 (Transparent)
		*	BorderWidth:				0
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						set lUseFormShortcutMenu for all contained
		*								objects to the same as ours and bind
		*								OnFormChange to the form's lChanged property if
		*								necessary
		*	RightClick:					call This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	BuilderCode:				code for a self-contained builder
		*	Enabled_Assign:				sets the Enabled property of the object and all
		*								member objects to the specified value so all
		*								objects appear to be enabled or disabled
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*==============================================================================
		
	ENDPROC

	PROCEDURE buildercode		&& Code for a self-contained builder; see notes in the method for instructions
		* This method can hold self-contained builder code. To use it, fill in this
		* method with code that accepts a parameter (a reference to this object) and
		* uses that parameter to reference to the object (you can't use "This" because
		* the code will actually be copied to a script PRG and executed there). Then
		* simply double-click the Builder property in PEM Editor to invoke the builder.
		
		lparameters toThis
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Last Revision:	09/27/2001
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE enabled_assign
		* Enable or disable member objects.
		
		lparameters tlEnabled
		This.SetAll('Enabled', tlEnabled)
		This.Enabled = tlEnabled
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		local loException as Exception, ;
			loParent
		with This
		
		* Set lUseFormShortcutMenu for all contained objects to the same as ours.
		
			try
				.SetAll('lUseFormShortcutMenu', .lUseFormShortcutMenu)
			catch to loException
			endtry
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorercustom AS custom 		&& Base class for Custom objects
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: releasemembers		&& Abstract method to nuke member references
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: cerrormessage		&& The message of an error
		*p: lerroroccurred		&& .T. if an error occurred
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lrelease		&& .T. as the object is being released
		*p: oexception		&& A reference to an Exception object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	cerrormessage = 		&& The message of an error
	lerroroccurred = .F.		&& .T. if an error occurred
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lrelease = .F.		&& .T. as the object is being released
	Name = "projectexplorercustom"
	oexception = .NULL.		&& A reference to an Exception object
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerCustom
		* Based On:						Custom
		* Purpose:						Base class for all Custom objects
		* Author:						Doug Hennig
		* Last revision:				02/17/2017
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	Width:						17 so the object is small when dropped on a
		*								form
		*
		* Changes in "Based On" class methods:
		*	Destroy:					cleanup as the object is destroyed
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						bind OnFormChange to Thisform.lChanged if
		*								lNotifyOnFormChange is .T.
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	cErrorMessage:				the message of an error
		*	lErrorOccurred:				.T. if an error occurred
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	oException:					a reference to an Exception object
		*
		* Custom protected properties added:
		*	lRelease:					.T. as the object is being released
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ReleaseMembers:				abstract method to nuke member references
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Last Revision:	09/27/2001
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Last Revision:	03/24/99
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	04/26/2006
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			llCOMMode, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		llCOMMode = inlist(_VFP.StartMode, 2, 3, 5)
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* If we're not running in a COM server, display a generic dialog box with an
		* option to display the debugger (this should only occur in a test
		* environment).
		
			case not llCOMMode
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Use COMRETURNERROR() if we're running in a COM server.
		
			case llCOMMode
				comreturnerror('', 'Error ' + lnError + ' occurred in line ' + ;
					transform(lnLine) + ' of ' + lcMethod)
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		* If we're supposed to bind to the lChanged property of the form, do so.
		
		if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
			pemstatus(Thisform, 'lChanged', 5)
			bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
		endif This.lNotifyOnFormChange ...
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Abstract method.
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorereditbox AS editbox 		&& Base class for EditBox objects
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: selectfont		&& Selects the font for the control
		*m: setzoomformproperties		&& Sets properties of the zoom form before it's displayed
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*m: validation		&& An abstract method for custom validation code
		*m: zoom		&& Displays a form with a zoomed edit box in it
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: czoomclass		&& The class to use for the "zoom" form
		*p: czoomformcaption		&& The caption for the "zoom" form
		*p: czoomlibrary		&& The library containing the class specified in cZoomClass
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lcanchangefont		&& .T. if the user can change the font
		*p: lcanfind		&& .T. if the user can bring up the Find dialog
		*p: lcanzoom		&& .T. if the user can zoom this control
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: lskipvalidonformclose		&& .T. if we can skip validating this control when the form is closed
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	Anchor = 15
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	czoomclass = ProjectExplorerEditBoxZoomForm		&& The class to use for the "zoom" form
	czoomformcaption = 		&& The caption for the "zoom" form
	czoomlibrary = ProjectExplorerCtrls.vcx		&& The library containing the class specified in cZoomClass
	FontName = "Tahoma"
	IntegralHeight = .T.
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lcanchangefont = .F.		&& .T. if the user can change the font
	lcanfind = .F.		&& .T. if the user can bring up the Find dialog
	lcanzoom = .F.		&& .T. if the user can zoom this control
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	lskipvalidonformclose = .T.		&& .T. if we can skip validating this control when the form is closed
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorereditbox"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="czoomclass" type="property" display="cZoomClass" favorites="True"/>
		<memberdata name="czoomformcaption" type="property" display="cZoomFormCaption" favorites="True"/>
		<memberdata name="czoomlibrary" type="property" display="cZoomLibrary" favorites="True"/>
		<memberdata name="lcanchangefont" type="property" display="lCanChangeFont" favorites="True"/>
		<memberdata name="lcanfind" type="property" display="lCanFind" favorites="True"/>
		<memberdata name="lcanzoom" type="property" display="lCanZoom" favorites="True"/>
		<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="selectfont" type="method" display="SelectFont"/>
		<memberdata name="setzoomformproperties" type="method" display="SetZoomFormProperties" favorites="True"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="zoom" type="method" display="Zoom"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerEditBox
		* Based On:						EditBox
		* Purpose:						Base class for all EditBox objects
		* Author:						Doug Hennig
		* Last revision:				05/25/2017
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	Anchor:						15 (resize height and width)
		*	FontName:					Tahoma
		*	IntegralHeight:				.T.
		*	SelectOnEntry:				.T.
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						bind InteractiveChange to the form's AnyChange
		*								method and bind OnFormChange to the form's
		*								lChanged property if necessary. Change FontName
		*								to Segoe UI in Vista
		*	InteractiveChange:			raises the AnyChange event
		*	KeyPress:					ignore Ctrl-0 and backspace at the start of the
		*								control
		*	ProgrammaticChange:			raises the AnyChange event
		*	RightClick:					call This.ShowMenu
		*	Valid:						prevent validation code from executing if the
		*								user is cancelling, retain focus if a field
		*								rule failed, and call the custom Validation
		*								method
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	cZoomClass:					the class to use for the "zoom" form
		*	cZoomFormCaption:			the caption for the "zoom" form
		*	cZoomLibrary:				the library containing the class specified in
		*								cZoomClass
		*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
		*								its form's AnyChange method
		*	lCanChangeFont:				.T. if the user can change the font
		*	lCanFind:					.T. if the user can bring up the Find dialog
		*	lCanZoom:					.T. if the user can zoom this control
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
		*								the form is closed
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AnyChange:					called from the InteractiveChange and
		*								ProgrammaticChange events to consolidate
		*								change code in one place
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	SelectFont:					selects the font for the control
		*	SetZoomFormProperties:		sets properties of the zoom form before it's
		*								displayed
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateControlSource:		updates the ControlSource with the new value
		*	Validation:					abstract method for custom validation code
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		* Abstract method
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
			if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'AnyChange', 5)
				bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
			endif .lBindToFormAnyChange ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
		* Prevent backspace from leaving the control.
		
		if tnKeyCode = 127 and This.SelStart = 0 and This.SelLength = 0
		   nodefault
		endif tnKeyCode = 127 ...
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE selectfont		&& Selects the font for the control
		local lcStyle, ;
			lcFont, ;
			lnPos1, ;
			lnPos2
		with This
			lcStyle = iif(.FontBold, 'B', '') + iif(.FontItalic, 'I', '')
			lcFont  = getfont(.FontName, .FontSize, lcStyle)
			if not empty(lcFont)
				lnPos1      = at(',', lcFont, 1)
				lnPos2      = at(',', lcFont, 2)
				.FontName   = left(lcFont, lnPos1 - 1)
				.FontSize   = val(substr(lcFont, lnPos1 + 1, lnPos2 - lnPos1 - 1))
				lcFont      = substr(lcFont, lnPos2 + 1)
				.FontBold   = 'B' $ lcFont
				.FontItalic = 'I' $ lcFont
			endif not empty(lcFont)
		endwith
		
	ENDPROC

	PROCEDURE setzoomformproperties		&& Sets properties of the zoom form before it's displayed
		* Abstract method.
		
		lparameters toForm
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	11/19/2017
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		with toMenu
			.AddMenuBar('\<Undo',   "sys(1500, '_MED_UNDO',  '_MEDIT')", ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', ;
				'_med_undo', , , , , '_med_undo')
			.AddMenuBar('Re\<do',   "sys(1500, '_MED_REDO',  '_MEDIT')", ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', ;
				'_med_redo', , , , , '_med_redo')
			.AddMenuSeparator()
			.AddMenuBar('Cu\<t',    "sys(1500, '_MED_CUT',   '_MEDIT')", ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', ;
				'_med_cut', , , , , '_med_cut')
			.AddMenuBar('\<Copy',   "sys(1500, '_MED_COPY',  '_MEDIT')", , ;
				'_med_copy', , , , , '_med_copy')
			.AddMenuBar('\<Paste',  "sys(1500, '_MED_PASTE', '_MEDIT')", ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', ;
				'_med_paste', , , , , '_med_paste')
			.AddMenuBar('Cle\<ar',  "sys(1500, '_MED_CLEAR', '_MEDIT')", ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', ;
				'_med_clear', , , , , '_med_clear')
			.AddMenuSeparator()
			.AddMenuBar('Se\<lect All', "sys(1500, '_MED_SLCTA', '_MEDIT')", , ;
				'_med_slcta', '_med_slcta')
			if This.lCanChangeFont or This.lCanFind or This.lCanZoom
				.AddMenuSeparator()
			endif This.lCanChangeFont ...
			if This.lCanChangeFont
				.AddMenuBar('F\<ont...', tcObject + '.SelectFont()')
			endif This.lCanChangeFont
			if This.lCanFind
				.AddMenuBar('\<Find...', "sys(1500, '_MED_FIND', '_MEDIT')", , ;
					'_med_find', , , , , '_med_find')
			endif This.lCanFind
			if This.lCanZoom
		*** zoom.bmp
				.AddMenuBar('\<Zoom...', tcObject + '.Zoom()')
			endif This.lCanZoom
		endwith
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Public
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Last revision:	02/27/2006
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Last revision:	08/20/2002
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(This.lSkipValidOnFormClose and ;
			type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE zoom		&& Displays a form with a zoomed edit box in it
		local loForm
		loForm = newobject(This.cZoomClass, ;
			fullpath(This.cZoomLibrary, This.ClassLibrary))
		with loForm
			.cValue  = This.Value
			.Caption = This.cZoomFormCaption
			.Icon    = Thisform.Icon
			with .edtZoom
				.FontName   = This.FontName
				.FontSize   = This.FontSize
				.FontBold   = This.FontBold
				.FontItalic = This.FontItalic
			endwith
			This.SetZoomFormProperties(loForm)
		endwith
		loForm.Show()
		do case
			case vartype(loForm) <> 'O'
			case not empty(This.ControlSource)
				store loForm.cValue to (This.ControlSource), This.Value
			otherwise
				This.Value = loForm.cValue
		endcase
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorereditboxzoomform AS projectexplorermodaldialog OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="edtZoom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFont" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: cregistrykey		&& The Registry key to use for settings
		*p: cvalue		&& The value for the editbox
		*p: oregistry		&& A reference to a Registry object
	*</DefinedPropArrayMethod>

	Caption = ""
	cregistrykey = 		&& The Registry key to use for settings
	cvalue = 		&& The value for the editbox
	Desktop = .T.
	DoCreate = .T.
	Height = 290
	KeyPreview = .T.
	MaxButton = .T.
	Name = "projectexplorereditboxzoomform"
	nborderstyle = 3
	oregistry = .NULL.		&& A reference to a Registry object
	Width = 375
	_memberdata = <VFPData>
		<memberdata name="cregistrykey" display="cRegistryKey"/>
		<memberdata name="oregistry" display="oRegistry"/>
		<memberdata name="cvalue" display="cValue"/>
		</VFPData>

	ADD OBJECT 'cmdCancel' AS projectexplorercancelbutton WITH ;
		Anchor = 36, ;
		Left = 188, ;
		Name = "cmdCancel", ;
		Top = 255
		*< END OBJECT: ClassLib="projectexplorerbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdFont' AS projectexplorercommandbutton WITH ;
		Caption = "Font...", ;
		Name = "cmdFont"
		*< END OBJECT: ClassLib="projectexplorerctrls.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS projectexplorerokbutton WITH ;
		Anchor = 132, ;
		Left = 103, ;
		Name = "cmdOK", ;
		Top = 255
		*< END OBJECT: ClassLib="projectexplorerbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'edtZoom' AS projectexplorereditbox WITH ;
		AllowTabs = .T., ;
		ControlSource = "Thisform.cValue", ;
		Height = 218, ;
		lcanchangefont = .T., ;
		lcanfind = .T., ;
		lcanzoom = .F., ;
		Name = "edtZoom", ;
		Top = 30, ;
		Width = 375
		*< END OBJECT: ClassLib="projectexplorerctrls.vcx" BaseClass="editbox" />
	
	PROCEDURE Init
		* If we have a Registry key, instantiate a Registry object.
		
		local lcLibrary
		with This
			lcLibrary = 'ProjectExplorerRegistry.vcx'
			if not empty(.cRegistryKey) and file(lcLibrary)
				.oRegistry = newobject('ProjectExplorerRegistry', lcLibrary)
			endif not empty(.cRegistryKey) ...
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE releasemembers
		* Save our settings in the Registry.
		
		with This
			if not empty(.cRegistryKey)
				.oRegistry.SetKey(.cRegistryKey, 'ZoomHeight', transform(.Height))
				.oRegistry.SetKey(.cRegistryKey, 'ZoomWidth',  transform(.Width))
				.oRegistry.SetKey(.cRegistryKey, 'ZoomTop',    transform(.Top))
				.oRegistry.SetKey(.cRegistryKey, 'ZoomLeft',   transform(.Left))
				.oRegistry.SetKey(.cRegistryKey, 'ZoomFont',   .edtZoom.FontName)
				.oRegistry.SetKey(.cRegistryKey, 'ZoomFontSize', ;
					transform(.edtZoom.FontSize))
				.oRegistry.SetKey(.cRegistryKey, 'ZoomBold', ;
					transform(.edtZoom.FontBold, 'Y'))
				.oRegistry.GetKey(.cRegistryKey, 'ZoomItalic', ;
					transform(.edtZoom.FontItalic, 'Y'))
			endif not empty(.cRegistryKey)
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE Show
		* Restore our size, position, and font from the Registry.
		
		lparameters tnStyle
		with This
			if not empty(.cRegistryKey)
				.Height = val(.oRegistry.GetKey(.cRegistryKey, 'ZoomHeight', ;
					transform(.Height)))
				.Width  = val(.oRegistry.GetKey(.cRegistryKey, 'ZoomWidth', ;
					transform(.Width)))
				.Top    = val(.oRegistry.GetKey(.cRegistryKey, 'ZoomTop', ;
					transform(.Top)))
				.Left   = val(.oRegistry.GetKey(.cRegistryKey, 'ZoomLeft', ;
					transform(.Left)))
				.edtZoom.FontName   = .oRegistry.GetKey(.cRegistryKey, 'ZoomFont', ;
					.edtZoom.FontName)
				.edtZoom.FontSize   = val(.oRegistry.GetKey(.cRegistryKey, ;
					'ZoomFontSize', transform(.edtZoom.FontSize)))
				.edtZoom.FontBold   = .oRegistry.GetKey(.cRegistryKey, 'ZoomBold', ;
					transform(.edtZoom.FontBold, 'Y')) = 'Y'
				.edtZoom.FontItalic = .oRegistry.GetKey(.cRegistryKey, 'ZoomItalic', ;
					transform(.edtZoom.FontItalic, 'Y')) = 'Y'
			endif not empty(.cRegistryKey)
		endwith
		dodefault(tnStyle)
		
	ENDPROC

	PROCEDURE cmdFont.Click
		local lcStyle, ;
			lcFont, ;
			lnPos1, ;
			lnPos2
		with This
			lcStyle = iif(.Parent.edtZoom.FontBold, 'B', '') + ;
				iif(.Parent.edtZoom.FontItalic, 'I', '')
			lcFont  = getfont(.Parent.edtZoom.FontName, .Parent.edtZoom.FontSize, ;
				lcStyle)
			if not empty(lcFont)
				lnPos1  = at(',', lcFont)
				lnPos2  = at(',', lcFont, 2)
				lcStyle = substr(lcFont, lnPos2 + 1)
				.Parent.edtZoom.FontName   = left(lcFont, lnPos1 - 1)
				.Parent.edtZoom.FontSize   = val(substr(lcFont, lnPos1 + 1, ;
					lnPos2 - lnPos1 - 1))
				.Parent.edtZoom.FontBold   = 'B' $ lcStyle
				.Parent.edtZoom.FontItalic = 'I' $ lcStyle
			endif not empty(lcFont)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerform AS form 		&& The base class for Form objects
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: activateobjectpage		&& Ensures any page the specified object is sitting on is the active page
		*m: afterrefresh		&& An abstract method of code to execute after a form is refreshed
		*m: anychange		&& This method can be called when anything in the form changes
		*m: beforerefresh		&& An abstract method of code to execute before a form is refreshed
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: canreleaseform		&& Returns .T. if we can release the form
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: findactivecontrol		&& Returns a reference to the active control (which may be in a container)
		*m: finderrorhandler		&& Find the first parent for a specified object that has code in its Error method
		*m: handleerror		&& Handles an error
		*m: refreshform		&& Refreshes the form
		*m: releasemembers		&& Abstract method to nuke member references
		*m: resetchangedstate		&& Resets the changed state
		*m: reseterror		&& Resets lErrorOccurred and aErrorInfo
		*m: seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error
		*m: setfocustofirstobject		&& Sets focus to the first object in the specified container
		*m: setfocustolastobject		&& Sets focus to the last object in the specified container
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lchanged		&& .T. if something in the form has changed
		*p: lerrorinfosaved		&& .T. if the error information has been saved in aErrorInfo
		*p: lerroroccurred		&& .T. if an error occurred (set in SetError)
		*p: lrelease		&& .T. as the object is being released
		*p: lsetfocustofirstobject		&& .T. to set focus to the first object in Show
		*p: nborderstyle		&& The value to put into the BorderStyle property at runtime *** 0=No border,1=Fixed single,2=Fixed dialog,3=Sizable
		*p: ninitialheight		&& The initial height of the form
		*p: ninitialwidth		&& The initial width of the form
		*p: nlasterror		&& The index to the last error that occurred in aErrorInfo
		*p: oerror		&& A reference to an error handling object
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: oshortcutmenu		&& An object reference to a shortcut menu object
		*a: aerrorinfo[1,0]		&& An array of error information
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lerrorinfosaved
	AllowOutput = .F.
	AutoCenter = .T.
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	Caption = "Form"
	Desktop = .T.
	DoCreate = .T.
	FontName = "Tahoma"
	KeyPreview = .T.
	lchanged = .F.		&& .T. if something in the form has changed
	lerrorinfosaved = .F.		&& .T. if the error information has been saved in aErrorInfo
	lerroroccurred = .F.		&& .T. if an error occurred (set in SetError)
	lrelease = .F.		&& .T. as the object is being released
	lsetfocustofirstobject = .T.		&& .T. to set focus to the first object in Show
	Name = "projectexplorerform"
	nborderstyle = 2		&& The value to put into the BorderStyle property at runtime *** 0=No border,1=Fixed single,2=Fixed dialog,3=Sizable
	ninitialheight = 0		&& The initial height of the form
	ninitialwidth = 0		&& The initial width of the form
	nlasterror = 0		&& The index to the last error that occurred in aErrorInfo
	oerror = .NULL.		&& A reference to an error handling object
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	oshortcutmenu = .NULL.		&& An object reference to a shortcut menu object
	ShowTips = .T.
	ShowWindow = 1
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="activateobjectpage" type="method" display="ActivateObjectPage"/>
		<memberdata name="aerrorinfo" type="property" display="aErrorInfo"/>
		<memberdata name="afterrefresh" type="method" display="AfterRefresh" favorites="True"/>
		<memberdata name="beforerefresh" type="method" display="BeforeRefresh" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="findactivecontrol" type="method" display="FindActiveControl"/>
		<memberdata name="finderrorhandler" type="method" display="FindErrorHandler"/>
		<memberdata name="handleerror" type="method" display="HandleError"/>
		<memberdata name="lerrorinfosaved" type="property" display="lErrorInfoSaved"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="nborderstyle" type="property" display="nBorderStyle" favorites="True"/>
		<memberdata name="nlasterror" type="property" display="nLastError"/>
		<memberdata name="oerror" type="property" display="oError"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="refreshform" type="method" display="RefreshForm"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
		<memberdata name="reseterror" type="method" display="ResetError"/>
		<memberdata name="seterror" type="method" display="SetError"/>
		<memberdata name="setfocustofirstobject" type="method" display="SetFocusToFirstObject"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="ninitialwidth" type="property" display="nInitialWidth"/>
		<memberdata name="ninitialheight" type="property" display="nInitialHeight"/>
		<memberdata name="lchanged" type="property" display="lChanged"/>
		<memberdata name="anychange" type="method" display="AnyChange"/>
		<memberdata name="resetchangedstate" type="method" display="ResetChangedState"/>
		<memberdata name="setfocustolastobject" type="method" display="SetFocusToLastObject"/>
		<memberdata name="lsetfocustofirstobject" type="property" display="lSetFocusToFirstObject"/>
		<memberdata name="canreleaseform" type="method" display="CanReleaseForm"/>
		<memberdata name="oshortcutmenu" display="oShortcutMenu"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerForm
		* Based On:						Form
		* Purpose:						Base class for all Form objects
		* Author:						Doug Hennig
		* Last revision:				11/21/2017
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	AllowOutput:				.F.
		*	AutoCenter:					.T.
		*	Desktop:					.T. so windows use Aero Glass in Vista
		*	FontName:					Tahoma
		*	KeyPress:					.T.
		*	ShowTips:					.T.
		*	ShowWindow:					1 - In Top-level Form
		*
		* Changes in "Based On" class methods:
		*	Destroy:					hides the form so it disappears faster, and
		*								clean up other things
		*	Error:						calls This.SetError and This.HandleError
		*	GotFocus:					calls This.RefreshForm
		*	Init:						puts the value of the custom nBorderStyle
		*								property into the BorderStyle property.
		*								Change FontName to Segoe UI in Vista
		*	KeyPress:					call This.ShowMenu if Shift-F10 is pressed
		*	Load:						set up the environment the way we want
		*	QueryUnload:				call CanReleaseForm to see if the form can be
		*								released
		*	Release:					call This.Cleanup
		*	RightClick:					call This.ShowMenu
		*	Show:						call This.SetFocusToFirstObject so focus goes
		*								to the first object in the form
		*
		* Custom public properties added:
		*	aErrorInfo:					an array of error information
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lChanged:					.T. if something in the form has changed
		*	lErrorOccurred:				.T. if an error occurred (set in SetError)
		*	lRelease:					.T. as the object is being released
		*	lSetFocusToFirstObject   	.T. to set focus to the first object in Show
		*	nBorderStyle:				the value (default = 2, Fixed dialog) to put
		*								into the BorderStyle property at runtime
		*	nInitialHeight:				the initial height of the form
		*	nInitialWidth:				the initial width of the form
		*	nLastError:					the index to the last error that occurred in
		*								aErrorInfo
		*	oError:						a reference to an error handling object
		*	oHook:						a reference to a hooked object
		*	oShortcutMenu:				a reference to an SFShortcutMenu object
		*
		* Custom protected properties added:
		*	lErrorInfoSaved:			.T. if the error information has been saved in
		*								aErrorInfo
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	ActivateObjectPage:			ensures any page the specified object is
		*								sitting on is the active page
		*	AfterRefresh:				an abstract method of code to execute after a
		*								form is refreshed
		*	AnyChange:					this method can be called when anything in the
		*								form changes
		*	BeforeRefresh:				an abstract method of code to execute before a
		*								form is refreshed
		*	CanReleaseForm:				returns .T. if we can release the form
		*	FindActiveControl:			returns a reference to the active control
		*								(which may be in a container)
		*	FindErrorHandler:			called by the Error method of contained objects
		*								to find a parent that has code in its Error
		*								method
		*	HandleError:				handles an error
		*	RefreshForm:				refreshes the form
		*	ReleaseMembers:				abstract method to nuke member references
		*	ResetChangedState:			resets the changed state
		*	ResetError:					resets lErrorOccurred, aErrorInfo, and
		*								nLastError
		*	SetError:					sets lErrorOccurred and aErrorInfo to
		*								information about the most recent error
		*	SetFocusToFirstObject:		sets focus to the first object in the specified
		*								container
		*	SetFocusToLastObject:		sets focus to the last object in the specified
		*								container
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*==============================================================================
		
	ENDPROC

	PROCEDURE activateobjectpage		&& Ensures any page the specified object is sitting on is the active page
		*==============================================================================
		* Method:			ActivateObjectPage
		* Status:			Public
		* Purpose:			Ensures any page the specified object is sitting on is the
		*						active page
		* Author:			Doug Hennig
		* Last revision:	12/04/98
		* Parameters:		toObject - an object reference to the desired object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	any page (even if the object is in a container on a
		*						pageframe on a pageframe) the specified object is
		*						sitting on is the active page
		*==============================================================================
		
		lparameters toObject
		local loParent, ;
			lnPage
		
		* Ensure the passed parameter is a contained object.
		
		if vartype(toObject) <> 'O' or type('toObject.Parent') <> 'O'
			error 'Parameter is not a contained object.'
			return .F.
		endif vartype(toObject) <> 'O' ...
		loParent = toObject.Parent
		lnPage   = 0
		
		* Drill up until we hit the form, activating pages as necessary.
		
		do while upper(loParent.BaseClass) <> 'FORM'
			do case
				case upper(loParent.BaseClass) == 'PAGE'
					lnPage = loParent.PageOrder
				case upper(loParent.BaseClass) == 'PAGEFRAME' and ;
					loParent.ActivePage <> lnPage
					loParent.ActivePage = lnPage
			endcase
			loParent = loParent.Parent
		enddo while upper(loParent.BaseClass) <> 'FORM'
		
	ENDPROC

	PROCEDURE afterrefresh		&& An abstract method of code to execute after a form is refreshed
		* Abstract method
		
	ENDPROC

	PROCEDURE anychange		&& This method can be called when anything in the form changes
		* Flag that something changed.
		
		This.lChanged = .T.
		
	ENDPROC

	PROCEDURE beforerefresh		&& An abstract method of code to execute before a form is refreshed
		* Abstract method
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Last Revision:	08/22/2000
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn
		
		* Get the name of the program that called us, and get the object name from it.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		return llReturn
		
	ENDPROC

	PROCEDURE canreleaseform		&& Returns .T. if we can release the form
		* Abstract method
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Last Revision:	02/10/2017
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.oHook, oError, and oShortcutMenu are .NULL.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		This.oHook         = .NULL.
		This.oError        = .NULL.
		This.oShortcutMenu = .NULL.
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Called when the object is being destroyed
		* Author:			Doug Hennig
		* Last revision:	11/21/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form and any member objects are destroyed
		*==============================================================================
		
		* Hide the form so it appears to go away faster (if we're not dockable; if we
		* are, we won't do this because calling Hide sets Left to 0) and cleanup as the
		* object is destroyed.
		
		if This.Dockable = 0
			This.Hide()
		endif This.Dockable = 0
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Called when an error occurs in this object or a member
		*						object
		* Author:			Doug Hennig
		* Last revision:	02/16/2003
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number where the error occurred
		* Returns:			varies
		* Environment in:	an error has occurred
		*					This.oException may contain an Exception object
		* Environment out:	control may be returned to the object/method that caused
		*						the error (either as RETURN or RETRY) or to the routine
		*						containing the READ EVENTS for the application
		*					the form may be released
		*					see This.SetError() and This.HandleError() for other
		*						environmental changes
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcReturn, ;
			lcReturnToOnCancel, ;
			lnPos, ;
			lcObject
		with This
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
			lcMethod = tcMethod
			lnLine   = tnLine
			lcSource = message(1)
			aerror(laError)
			if vartype(.oException) = 'O'
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		
		* Use SetError() and HandleError() to gather error information and handle it.
		
			.SetError(lcMethod, lnLine, lcSource, @laError)
			.lErrorInfoSaved = .F.
			lcReturn = .HandleError()
		
		* Figure out where to go if the user chooses "Cancel".
		
			do case
				case left(sys(16, 1), at('.', sys(16, 1)) - 1) = 'PROCEDURE ' + ;
					upper(.Name)
					lcReturnToOnCancel = ''
				case type('.oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = .oError.cReturnToOnCancel
				case type('oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = oError.cReturnToOnCancel
				otherwise
					lcReturnToOnCancel = 'MASTER'
			endcase
		endwith
		
		* Handle the return value, depending on whether the error was "ours" or came
		* from a member.
		
		lnPos    = at('.', lcMethod)
		lcObject = iif(lnPos = 0, '', upper(left(lcMethod, lnPos - 1)))
		do case
		
		* We're supposed to close the form, so do so and return to the master program
		* (we'll just cancel if we *are* the master program).
		
			case lcReturn = ccMSG_CLOSEFORM
				This.Release()
				if empty(lcReturnToOnCancel)
					cancel
				else
					return to &lcReturnToOnCancel
				endif empty(lcReturnToOnCancel)
		
		* This wasn't our error, so return the error resolution string.
		
			case lnPos > 0 and not (lcObject == upper(This.Name) or ;
				'DATAENVIRONMENT' $ upper(lcMethod))
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* If Cancel was chosen but the master program is this form, we'll just cancel.
		
			case lcReturn = ccMSG_CANCEL and empty(lcReturnToOnCancel)
				cancel
		
		* Cancel was chosen, so return to the master program.
		
			case lcReturn = ccMSG_CANCEL
				return to &lcReturnToOnCancel
		
		* Return to the routine in error to continue on.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE findactivecontrol		&& Returns a reference to the active control (which may be in a container)
		*==============================================================================
		* Method:			FindActiveControl
		* Status:			Public
		* Purpose:			Returns a reference to the active control (which may be in
		*						a container)
		* Author:			Doug Hennig
		* Last revision:	05/22/2008
		* Parameters:		toContainer - the container to check (optional: if it isn't
		*						passed, the form is used)
		* Returns:			a reference to the active control if there is one or .NULL.
		*						if not
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters toContainer
		local loContainer, ;
			loObject, ;
			loControl
		
		* If the container wasn't specified, let's use the form.
		
		loContainer = iif(vartype(toContainer) = 'O', toContainer, This)
		
		* If we've found the active control, get a reference to it.
		
		loObject = .NULL.
		if type('loContainer.ActiveControl.Name') = 'C'
			loObject = loContainer.ActiveControl
		
		* We didn't find the active control, so check every member container by calling
		* ourselves recursively.
		
		else
			for each loControl in loContainer.Objects foxobject
				if pemstatus(loControl, 'ActiveControl', 5) or ;
					pemstatus(loControl, 'Objects', 5)
					This.FindActiveControl(loControl)
				endif pemstatus(loControl, 'ActiveControl', 5) ...
			next loControl
		endif type('loContainer.ActiveControl.Name') = 'C'
		return loObject
		
	ENDPROC

	PROCEDURE finderrorhandler		&& Find the first parent for a specified object that has code in its Error method
		*==============================================================================
		* Method:			FindErrorHandler
		* Status:			Public
		* Purpose:			Travel up the containership hierarchy until we find a
		*						parent for the specified object that has code in its
		*						Error method
		* Author:			Doug Hennig
		* Last revision:	04/02/2002
		* Parameters:		toObject - an object reference to the desired object
		* Returns:			an object reference to the first parent of the specified
		*						object that has code in its Error method if one could
		*						be found, or .NULL. if not
		* Environment in:	none
		* Environment out:	none
		* Note:				This method prevents a problem with controls sitting on
		*						base class Page or Column objects -- no error trapping
		*						gets done if no custom code is directly entered into
		*						these objects
		*
		*					This mechanism only works in the VFP development
		*						environment or in an APP/EXE with debug info turned on
		*==============================================================================
		
		lparameters toObject
		local loParent
		loParent = toObject.Parent
		do while vartype(loParent) = 'O'
			do case
				case pemstatus(loParent, 'Error', 0)
					exit
				case type('loParent.Parent') = 'O'
					loParent = loParent.Parent
				otherwise
					loParent = .NULL.
			endcase
		enddo while vartype('loParent') = 'O'
		
		* If we couldn't find a valid parent object (likely because we're running in an
		* EXE with debug info turned off, let's return ourselves.
		
		if isnull(loParent)
			loParent = This
		endif isnull(loParent)
		return loParent
		
	ENDPROC

	PROCEDURE GotFocus
		*==============================================================================
		* Method:			GotFocus
		* Status:			Public
		* Purpose:			Called when the window receives focus
		* Author:			Doug Hennig
		* Last revision:	03/29/2010
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	if we're not being released, This.RefreshForm() is called
		*						to ensure any BeforeRefresh and AfterRefresh behaviors
		*						are triggered
		*==============================================================================
		
		if not This.lRelease
			This.RefreshForm()
		endif not This.lRelease
		
	ENDPROC

	PROCEDURE handleerror		&& Handles an error
		*==============================================================================
		* Method:			HandleError
		* Status:			Public
		* Purpose:			Handles an error
		* Author:			Doug Hennig
		* Last revision:	12/14/2005
		* Parameters:		none
		* Returns:			a string indicating the error resolution; see SFERRORS.H
		*						for the possible values
		* Environment in:	This.nLastError points to the row in This.aErrorInfo that
		*						has information about the current error
		* Environment out:	an error message may have been displayed, or some other
		*						error resolution may have been taken
		* Notes:			if This.oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if a global oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if an ON ERROR routine is in effect, it's called
		*					if none of these is true, a generic error message is
		*						displayed
		*==============================================================================
		
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcErrorMessage, ;
			lcErrorInfo, ;
			lcSource, ;
			loError, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		with This
			lnError        = .aErrorInfo[.nLastError, cnAERR_NUMBER]
			lcMethod       = .Name + '.' + .aErrorInfo[.nLastError, cnAERR_METHOD]
			lnLine         = .aErrorInfo[.nLastError, cnAERR_LINE]
			lcErrorMessage = .aErrorInfo[.nLastError, cnAERR_MESSAGE]
			lcErrorInfo    = .aErrorInfo[.nLastError, cnAERR_OBJECT]
			lcSource       = .aErrorInfo[.nLastError, cnAERR_SOURCE]
		
		* Get a reference to our error handling object if there is one. It could either
		* be a member of the form or a global object.
		
			do case
				case vartype(.oError) = 'O'
					loError = .oError
				case type('oError.Name') = 'C'
					loError = oError
				otherwise
					loError = .NULL.
			endcase
			do case
		
		* If the error is "cannot set focus during valid" or "DataEnvironment already
		* unloaded", we'll let it go.
		
				case lnError = cnERR_CANT_SET_FOCUS or lnError = cnERR_DE_UNLOADED
					lcReturn = ccMSG_CONTINUE
		
		* We have an error handling object, so call its ErrorHandler() method.
		
				case not isnull(loError)
					lcReturn = loError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
				case not empty(on('ERROR'))
					lcError = upper(on('ERROR'))
					lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
					lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
					lcError = strtran(lcError, ',ERROR()',  ',lnError')
					lcError = strtran(lcError, ' ERROR()',  ' lnError')
					lcError = strtran(lcError, 'LINENO()',  'lnLine')
					lcError = strtran(lcError, 'MESSAGE()', 'lcErrorMessage')
					lcError = strtran(lcError, 'SYS(2018)', 'lcErrorInfo')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
					if left(lcError, 3) = 'DO ' or '=' $ lcError
						&lcError
						lcReturn = ccMSG_CONTINUE
					else
						lcReturn = &lcError
					endif left(lcError, 3) = 'DO ' ...
		
		* We don't have an error handling object, so display a dialog box.
		
				otherwise
					lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
						ccMSG_MESSAGE + ' ' + lcErrorMessage + ccCR + ;
						iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
						ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
						transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
					if version(2) = 0
						lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
							'Choose OK to continue or Cancel to cancel execution', ;
							MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
					else
						lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
							'Choose Yes to display the debugger, No to continue ' + ;
							'without the debugger, or Cancel to cancel execution', ;
							MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
					endif version(2) = 0
					lcReturn = ccMSG_CONTINUE
					do case
						case lnChoice = IDYES
							lcReturn = ccMSG_DEBUG
						case lnChoice = IDCANCEL
							lcReturn = ccMSG_CANCEL
					endcase
			endcase
		endwith
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not upper(lcReturn) $ upper(ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ;
			ccMSG_CLOSEFORM + ccMSG_DEBUG), ccMSG_CONTINUE, lcReturn)
		return lcReturn
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Initializes the object
		* Author:			Doug Hennig
		* Last revision:	02/17/2017
		* Parameters:		none
		* Returns:			.T. if everything succeeded, or .F. if an error occurred
		* Environment in:	none
		* Environment out:	if This.Icon is empty, it's set to _screen.Icon
		*					This.BorderStyle is set to This.nBorderStyle
		*==============================================================================
		
		local lcLibrary
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* If the Icon property is blank, grab the screen's or active form's.
		
			do case
				case not empty(.Icon)
				case type('_screen.ActiveForm.Name') = 'C' and ;
					pemstatus(_screen.ActiveForm, 'Icon', 5) and ;
					not empty(nvl(_screen.ActiveForm.Icon, ''))
					.Icon = _screen.ActiveForm.Icon
				case _screen.Visible
					.Icon = _screen.Icon
			endcase
		
		* If the icon is still empty, _screen may have been invisible, so we'll use its
		* icon anyway.
		
			if empty(.Icon)
				.Icon = _screen.Icon
			endif empty(.Icon)
		
		* Set the BorderStyle property as desired. Note that we don't do this if a
		* variable named __NOBORDER exists; this allows screen shots to show the window
		* as it actually appears.
		
			if .BorderStyle <> .nBorderStyle and type('__NOBORDER') = 'U'
				.BorderStyle = .nBorderStyle
			endif .BorderStyle <> .nBorderStyle ...
		endwith
		return not This.lErrorOccurred
		
	ENDPROC

	PROCEDURE KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		do case
		
		* Display the shortcut menu if Shift-F10 is pressed.
		
			case tnKeyCode = 93 and tnShiftAltCtrl = 1
				This.ShowMenu()
		
		* Prevent Ctrl-0 from inserting a null value.
		
			case tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
				nodefault
		endcase
		
	ENDPROC

	PROCEDURE Load
		*==============================================================================
		* Method:			Load
		* Status:			Public
		* Purpose:			Sets up environmental things before the form instantiates
		* Author:			Doug Hennig
		* Last revision:	02/10/2017
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the environment is set up the way we want
		*==============================================================================
		
		with This
		
		* Set some environmental things the way we want if we're in a private
		* datasession. These are in alphabetical order. Not all are datasession-
		* specific, but we'll set 'em anyway.
		
			if .DataSession = 2
				set ansi       off
				set bell       off			&& not datasession-specific
				set compatible off			&& not datasession-specific
				set cpdialog   off			&& not datasession-specific
				set deleted    on
				set exact      off
				set exclusive  off
				set fullpath   on			&& not datasession-specific
				set multilocks on
				set near       off
				set notify     off			&& not datasession-specific
				set nulldisplay to ''		&& not datasession-specific
				set safety     off
				set talk       off
				set unique     off
		
		* Set CENTURY after SYSFORMATS, since SYSFORMATS changes CENTURY.
		
				set sysformats on
				set century    on
			endif .DataSession = 2
		
		* Save the initial width and height values; we may need them later for resizing
		* purposes.
		
			.nInitialWidth  = .Width
			.nInitialHeight = .Height
		endwith
		
	ENDPROC

	PROCEDURE QueryUnload
		*==============================================================================
		* Method:			QueryUnload
		* Status:			Public
		* Purpose:			See if we can close the form and if not, use NODEFAULT to
		*						prevent it
		* Author:			Doug Hennig
		* Last revision:	04/07/2008
		* Parameters:		none
		* Returns:			.T. if the form can be closed
		* Environment in:	none
		* Environment out:	see This.CanReleaseForm
		*==============================================================================
		
		local llReturn
		llReturn = This.CanReleaseForm()
		if not llReturn
			nodefault
		endif not llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form
		*==============================================================================
		* Method:			RefreshForm
		* Status:			Public
		* Purpose:			Refreshes the form
		* Author:			Doug Hennig
		* Last revision:	05/08/2014
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form has been refreshed and any code in the
		*						BeforeRefresh and AfterRefresh methods has executed
		* Notes:			LockWindowUpdate was formerly used instead of
		*						This.LockScreen as a workaround for the problem of
		*						labels becoming bolder and bolder when this method is
		*						called (caused by a bug in how VFP works with ClearType
		*						displays) but that causes too much Windows Desktop
		*						refreshing, so we've reverted to LockScreen.
		*==============================================================================
		
		with This
			.LockScreen = .T.
			.BeforeRefresh()
			.Refresh()
			.AfterRefresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE Release
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		* Do nothing if we're already in the process of releasing or CanReleaseForm
		* says we can't release.
		
		if This.lRelease or not This.CanReleaseForm()
			nodefault
			return .F.
		endif This.lRelease ...
		
		* Do cleanup tasks.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method
		
	ENDPROC

	PROCEDURE resetchangedstate		&& Resets the changed state
		* Reset the changed state.
		
		This.lChanged = .F.
		
	ENDPROC

	PROCEDURE reseterror		&& Resets lErrorOccurred and aErrorInfo
		*==============================================================================
		* Method:			ResetError
		* Status:			Public
		* Purpose:			Reset lErrorOccurred and aErrorInfo
		* Author:			Doug Hennig
		* Last revision:	01/26/2003
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.lErrorOccurred is .F.
		*					This.nLastError is 1
		*					This.aErrorInfo is dimensioned to a single blank row
		*					This.oException is null
		*==============================================================================
		
		with This
			.lErrorOccurred = .F.
			dimension .aErrorInfo[1, cnAERR_MAX]
			.aErrorInfo = ''
			.nLastError = 1
			.oException = .NULL.
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		*==============================================================================
		* Method:			RightClick
		* Status:			Public
		* Purpose:			Display a right-click menu
		* Author:			Doug Hennig
		* Last revision:	03/16/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	a menu may have been displayed and action taken from the
		*						choice the user made
		*==============================================================================
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error
		*==============================================================================
		* Method:			SetError
		* Status:			Public
		* Purpose:			Handle errors
		* Author:			Doug Hennig
		* Last revision:	04/26/2006
		* Parameters:		tcMethod - the method or function the error occurred in
		*					tnLine   - the line number within tcMethod
		*					tcSource - the code causing the error
		*					taError  - an array of error information
		* Returns:			.T.
		* Environment in:	This.aErrorInfo is dimensioned appropriately
		*					This.lErrorSet is .T. if this method has already been called
		*						for this error
		* Environment out:	This.lErrorOccurred is .T.
		*					This.lErrorSet is .T.
		*					This.nLastError points to the current row in This.aErrorInfo
		*					This.aErrorInfo is filled with error information as
		*						follows:
		*
		*					Column	Information
		*					------	-----------
		*					1 - 7	same as AERROR()
		*					8		method error occurred in
		*					9		line error occurred on
		*					10		code causing error
		*					11		date/time error occurred
		*					12		not used
		*					13		XML string of properties and their values for the
		*							object that caused the error (may be blank)
		*==============================================================================
		
		lparameters tcMethod, ;
			tnLine, ;
			tcSource, ;
			taError
		local lnRows, ;
			lnCols, ;
			lnLast, ;
			lnError, ;
			lnRow, ;
			lnI
		external array taError
		with This
		
		* If we've already been called, just update the method information.
		
			if .lErrorInfoSaved
				.aErrorInfo[.nLastError, cnAERR_METHOD] = tcMethod
			else
		
		* Flag that an error occurred.
		
				.lErrorOccurred  = .T.
				.lErrorInfoSaved = .T.
				lnRows = alen(taError, 1)
				lnCols = alen(taError, 2)
				lnLast = iif(empty(.aErrorInfo[1, 1]), 0, alen(.aErrorInfo, 1))
				dimension .aErrorInfo[lnLast + lnRows, cnAERR_MAX]
		
		* For each row in the error array, put each column into our array.
		
				for lnError = 1 to lnRows
					lnRow = lnLast + lnError
					for lnI = 1 to lnCols
						.aErrorInfo[lnRow, lnI] = taError[lnError, lnI]
					next lnI
		
		* Add some additional information to the current row in our array.
		
					.aErrorInfo[lnRow, cnAERR_METHOD]   = tcMethod
					.aErrorInfo[lnRow, cnAERR_LINE]     = tnLine
					.aErrorInfo[lnRow, cnAERR_SOURCE]   = ;
						iif(tcSource = .aErrorInfo[lnRow, cnAERR_MESSAGE], '', ;
						tcSource)
					.aErrorInfo[lnRow, cnAERR_DATETIME] = datetime()
				next lnError
				.nLastError = alen(.aErrorInfo, 1)
			endif not .lErrorInfoSaved
		endwith
		
	ENDPROC

	PROCEDURE setfocustofirstobject		&& Sets focus to the first object in the specified container
		*==============================================================================
		* Method:			SetFocusToFirstObject
		* Status:			Public
		* Purpose:			Sets focus to the first object in the specified container
		* Author:			Doug Hennig
		* Last revision:	09/24/2010
		* Parameters:		toContainer       - the container to check (optional: if it
		*						isn't passed, the form is used)
		*					tlKeepCurrentPage - .T. to keep the current page in any
		*						PageFrame active
		* Returns:			.T. if it set focus to an object
		* Environment in:	none
		* Environment out:	if this method returns .T., focus has been set to an object
		*==============================================================================
		
		lparameters toContainer, ;
			tlKeepCurrentPage
		local loContainer, ;
			laObjects[1], ;
			lnObjects, ;
			lnIndex, ;
			loControl, ;
			llReturn, ;
			lnI, ;
			loObject, ;
			lcClass, ;
			lnPage, ;
			loPage
		
		* If the container wasn't specified, let's use the form.
		
		loContainer = iif(vartype(toContainer) = 'O', toContainer, This)
		
		* Get an array of all member objects of the specified container. Initialize
		* some variables.
		
		lnObjects = amembers(laObjects, loContainer, 2)
		lnIndex   = 99999
		loControl = .NULL.
		llReturn  = .F.
		
		* Check each of the member objects until we come across the one lowest in the
		* tab order.
		
		for lnI = 1 to lnObjects
			loObject = evaluate('loContainer.' + laObjects[lnI])
			lcClass  = upper(loObject.BaseClass)
			do case
		
		* If the object doesn't have a TabIndex property, is a label, is disabled, is
		* read-only, or isn't visible, ignore it.
		
				case type('loObject.TabIndex') = 'U' or lcClass = 'LABEL' or ;
					(type('loObject.TabStop') = 'L' and not loObject.TabStop and ;
						upper(loObject.BaseClass) <> 'PAGEFRAME') or ;
					(type('loObject.Enabled') = 'L' and not loObject.Enabled) or ;
					(type('loObject.ReadOnly') = 'L' and loObject.ReadOnly) or ;
					(type('loObject.Visible') = 'L' and not loObject.Visible)
		
		* If this object is lower in tab order than any we've already seen, grab a
		* reference to it.
		
				case loObject.TabIndex < lnIndex
					loControl = loObject
					lnIndex   = loObject.TabIndex
			endcase
		next lnI
		
		* If we found an object, set focus to it. We may need to drill down into it if
		* it's a container.
		
		if vartype(loControl) = 'O'
			lcClass = upper(loControl.BaseClass)
			do case
		
		* If this is a pageframe, choose the first page, then call ourselves
		* recursively to find the first object inside it and set focus to it.
		
				case lcClass = 'PAGEFRAME'
					if tlKeepCurrentPage
						lnPage = loControl.ActivePage
					else
						lnIndex = 99999
						lnPage  = 0
						for lnI = 1 to loControl.PageCount
							try
								loPage = loControl.Pages[lnI]
								if loPage.PageOrder < lnIndex
									lnPage  = lnI
									lnIndex = loPage.PageOrder
								endif loPage.PageOrder < lnIndex
							catch
							endtry
						next lnI
					endif tlKeepCurrentPage
					if lnPage > 0
						if loControl.ActivePage <> lnPage
							loControl.ActivePage = lnPage
						endif loControl.ActivePage <> lnPage
						llReturn = This.SetFocusToFirstObject(loControl.Pages[lnPage])
					endif lnPage > 0
		
		* If this is another type of container, call ourselves recursively to find the
		* first object inside it and set focus to it.
		
				case lcClass $ 'COMMANDGROUP,OPTIONGROUP,CONTAINER'
					llReturn = This.SetFocusToFirstObject(loControl)
		
		* Set focus to the object.
		
				case pemstatus(loControl, 'SetFocus', 5)
					loControl.SetFocus()
					llReturn = .T.
			endcase
		endif vartype(loControl) = 'O' ...
		return llReturn
		
	ENDPROC

	PROCEDURE setfocustolastobject		&& Sets focus to the last object in the specified container
		*==============================================================================
		* Method:			SetFocusToLastObject
		* Status:			Public
		* Purpose:			Sets focus to the last object in the specified container
		* Author:			Doug Hennig
		* Last revision:	09/24/2010
		* Parameters:		toContainer       - the container to check (optional: if it
		*						isn't passed, the form is used)
		*					tlKeepCurrentPage - .T. to keep the current page in any
		*						PageFrame active
		* Returns:			.T. if it set focus to an object
		* Environment in:	none
		* Environment out:	if this method returns .T., focus has been set to an object
		*==============================================================================
		
		lparameters toContainer, ;
			tlKeepCurrentPage
		local loContainer, ;
			laObjects[1], ;
			lnObjects, ;
			lnIndex, ;
			loControl, ;
			llReturn, ;
			lnI, ;
			loObject, ;
			lcClass, ;
			lnPage, ;
			loPage
		
		* If the container wasn't specified, let's use the form.
		
		loContainer = iif(vartype(toContainer) = 'O', toContainer, This)
		
		* Get an array of all member objects of the specified container. Initialize
		* some variables.
		
		lnObjects = amembers(laObjects, loContainer, 2)
		lnIndex   = 0
		loControl = .NULL.
		llReturn  = .F.
		
		* Check each of the member objects until we come across the one lowest in the
		* tab order.
		
		for lnI = 1 to lnObjects
			loObject = evaluate('loContainer.' + laObjects[lnI])
			lcClass  = upper(loObject.BaseClass)
			do case
		
		* If the object doesn't have a TabIndex property, is a label, is disabled, is
		* read-only, or isn't visible, ignore it.
		
				case type('loObject.TabIndex') = 'U' or lcClass = 'LABEL' or ;
					(type('loObject.TabStop') = 'L' and not loObject.TabStop and ;
						upper(loObject.BaseClass) <> 'PAGEFRAME') or ;
					(type('loObject.Enabled') = 'L' and not loObject.Enabled) or ;
					(type('loObject.ReadOnly') = 'L' and loObject.ReadOnly) or ;
					(type('loObject.Visible') = 'L' and not loObject.Visible)
		
		* If this object is greater in tab order than any we've already seen, grab a
		* reference to it.
		
				case loObject.TabIndex > lnIndex
					loControl = loObject
					lnIndex   = loObject.TabIndex
			endcase
		next lnI
		
		* If we found an object, set focus to it. We may need to drill down into it if
		* it's a container.
		
		if vartype(loControl) = 'O'
			lcClass = upper(loControl.BaseClass)
			do case
		
		* If this is a pageframe, choose the first page, then call ourselves
		* recursively to find the first object inside it and set focus to it.
		
				case lcClass = 'PAGEFRAME'
					if tlKeepCurrentPage
						lnPage = loControl.ActivePage
					else
						lnIndex = 99999
						lnPage  = 0
						for lnI = 1 to loControl.PageCount
							try
								loPage = loControl.Pages[lnI]
								if loPage.PageOrder < lnIndex
									lnPage  = lnI
									lnIndex = loPage.PageOrder
								endif loPage.PageOrder < lnIndex
							catch
							endtry
						next lnI
					endif tlKeepCurrentPage
					if lnPage > 0
						if loControl.ActivePage <> lnPage
							loControl.ActivePage = lnPage
						endif loControl.ActivePage <> lnPage
						llReturn = This.SetFocusToLastObject(loControl.Pages[lnPage])
					endif lnPage > 0
		
		* If this is another type of container, call ourselves recursively to find the
		* last object inside it and set focus to it.
		
				case lcClass $ 'COMMANDGROUP,OPTIONGROUP,CONTAINER'
					llReturn = This.SetFocusToLastObject(loControl)
		
		* Set focus to the object.
		
				case pemstatus(loControl, 'SetFocus', 5)
					loControl.SetFocus()
					llReturn = .T.
			endcase
		endif vartype(loControl) = 'O' ...
		return llReturn
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object (abstract in this
		*						class)
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items may have been added to the menu in a
		*						subclass of this class
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE Show
		*==============================================================================
		* Method:			Show
		* Status:			Public
		* Purpose:			Display the form
		* Author:			Doug Hennig
		* Last revision:	09/14/2009
		* Parameters:		tnStyle - the style for the window
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	focus is set to the first object in the form
		*==============================================================================
		
		lparameters tnStyle
		local lcDataType
		lcDataType = vartype(tnStyle)
		if (pcount() = 0 or lcDataType = 'L' or (lcDataType = 'N' and tnStyle = ;
			This.WindowType)) and This.lSetFocusToFirstObject
			This.SetFocusToFirstObject(This)
		endif pcount() = 0 ...
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oShortcutMenu) <> 'O' and file(lcLibrary)
				.oShortcutMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oShortcutMenu) <> 'O' ...
			if vartype(.oShortcutMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oShortcutMenu.nBarCount = 0
					.ShortcutMenu(.oShortcutMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oShortcutMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
				endif .oShortcutMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oShortcutMenu.nBarCount > 0
					.oShortcutMenu.ShowMenu()
				endif .oShortcutMenu.nBarCount > 0
			endif vartype(.oShortcutMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerformtlf AS projectexplorerform OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	DoCreate = .T.
	Name = "projectexplorerformtlf"
	ShowWindow = 2

ENDDEFINE

DEFINE CLASS projectexplorergrid AS grid 		&& The base class for Grid objects
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: enabled_assign		&& Makes the grid appear enabled or disabled
		*m: getcaption		&& Gets the caption for the specified field
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: setupcolumns		&& Sets up things we need about columns
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lautofit		&& .T. to auto-fit the columns automatically
		*p: lautosetcolor		&& .T. to automatically use system colors
		*p: lautosetup		&& .T. to automatically call SetupColumns from Init
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nbackcolor		&& Our original BackColor
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nbackcolor,nsavedanchor
	AllowHeaderSizing = .F.
	AllowRowSizing = .F.
	Anchor = 15
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	FontName = "Tahoma"
	lautofit = .F.		&& .T. to auto-fit the columns automatically
	lautosetcolor = .T.		&& .T. to automatically use system colors
	lautosetup = .T.		&& .T. to automatically call SetupColumns from Init
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorergrid"
	nbackcolor = 0		&& Our original BackColor
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	SplitBar = .F.
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		<memberdata name="getcaption" type="method" display="GetCaption"/>
		<memberdata name="lautofit" type="property" display="lAutoFit" favorites="True"/>
		<memberdata name="lautosetup" type="property" display="lAutoSetup" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
		<memberdata name="nbackcolor" type="property" display="nBackColor"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="setupcolumns" type="method" display="SetupColumns"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lautosetcolor" display="lAutoSetColor"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerGrid
		* Based On:						Grid
		* Purpose:						Base class for all Grid objects
		* Author:						Doug Hennig
		* Last revision:				06/25/2009
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	AllowHeaderSizing:			.F.
		*	AllowRowSizing:				.F.
		*	Anchor:						15 (resize height and width)
		*	FontName:					Tahoma
		*	SplitBar:					.F.
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						call This.SetupColumns and bind OnFormChange to
		*								the form's lChanged property if necessary.
		*								Change FontName to Segoe UI in Vista.
		*	Refresh:					refresh contained controls
		*	RightClick:					call This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lAutoFit:					.T. to auto-fit the columns automatically
		*	lAutoSetColor:				.T. to automatically use system colors
		*	lAutoSetup:					.T. to automatically call SetupColumns from
		*								Init
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nBackColor:					our original BackColor
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	Enabled_Assign:				makes the grid appear enabled or disabled
		*	GetCaption:					gets the caption for the specified field
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	SetupColumns:				sets up things we need about columns
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE enabled_assign		&& Makes the grid appear enabled or disabled
		* Make the grid appear to be disabled if necessary.
		
		lparameters tlEnabled
		with This
			do case
				case .Enabled = tlEnabled
				case tlEnabled
					.BackColor = iif(.nBackColor = 0, .BackColor, .nBackColor)
				otherwise
					.nBackColor = .BackColor
					.BackColor  = .Parent.BackColor
			endcase
			.Enabled = tlEnabled
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE getcaption		&& Gets the caption for the specified field
		*==============================================================================
		* Method:			GetCaption
		* Status:			Public
		* Purpose:			Get the caption for the specified field
		* Author:			Doug Hennig
		* Last revision:	12/04/98
		* Parameters:		tcField - the field to get the caption for
		* Returns:			the caption for the field
		* Environment in:	if the field's table is in a DBC, that DBC is the current
		*						one
		*					oMeta may contain an object reference to DBCXMgr
		* Environment out:	none
		*==============================================================================
		
		lparameters tcField
		local lcField, ;
			lcCaption
		lcField = substr(tcField, at('.', tcField) + 1)
		do case
			case not empty(dbc()) and indbc(tcField, 'Field')
				lcCaption = dbgetprop(tcField, 'Field', 'Caption')
			case vartype('oMeta') = 'O'
				lcCaption = nvl(oMeta.DBCXGetProp(tcField, 'Field', 'Caption'), '')
			otherwise
				lcCaption = ''
		endcase
		lcCaption = iif(empty(lcCaption), proper(strtran(lcField, '_', ' ')), ;
			lcCaption)
		return lcCaption
		
	ENDPROC

	PROCEDURE Init
		local loParent
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* Use system colors if we're supposed to.
		
			if .lAutoSetColor
				#define COLOR_HIGHLIGHT     13
				#define COLOR_HIGHLIGHTTEXT 14
				declare integer GetSysColor in 'user32' integer nIndex
				.HighlightBackColor = GetSysColor(COLOR_HIGHLIGHT)
				.HighlightForeColor = GetSysColor(COLOR_HIGHLIGHTTEXT)
			endif .lAutoSetColor
		
		* Call the SetupColumns method so we can handle highlighting the entire row if
		* necessary.
		
			if .lAutoSetup
				.SetupColumns()
			endif .lAutoSetup
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE Refresh
		* Ensure all contained controls are refreshed.
		
		local loColumn, ;
			loControl
		with This
			for each loColumn in .Columns foxobject
				for each loControl in loColumn.Controls foxobject
					if pemstatus(loControl, 'Refresh', 5)
						loControl.Refresh()
					endif pemstatus(loControl, 'Refresh', 5)
				next loControl
			next loColumn
		endwith
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE setupcolumns		&& Sets up things we need about columns
		*==============================================================================
		* Method:			SetupColumns
		* Status:			Public
		* Purpose:			Sets up the columns
		* Author:			Doug Hennig
		* Last revision:	05/22/2008
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	if the table belongs to a database, that database is the
		*						current one
		*					headers with a default caption are changed to the caption
		*						for the field their column displays
		*					the FontName and FontSize for all headers is set to that of
		*						the grid
		*==============================================================================
		
		local lcDatabase, ;
			loColumn, ;
			lcCaption
		with This
		
		* If the grid is read-only, make all member objects read-only.
		
			if .ReadOnly
				.SetAll('ReadOnly', .T.)
			endif .ReadOnly
		
		* Ensure the database for the RecordSource (if there is one) is selected. This
		* is needed for the GetCaption method.
		
			if not empty(.RecordSource)
				lcDatabase = cursorgetprop('DATABASE', .RecordSource)
				if not set('DATABASE') == lcDatabase and not empty(lcDatabase)
					set database to (lcDatabase)
				endif not set('DATABASE') == lcDatabase ...
			endif not empty(.RecordSource)
		
		* Ensure each column has a valid header caption.
		
			for each loColumn in .Columns foxobject
				for each loObject in loColumn.Controls foxobject
					if upper(loObject.BaseClass) = 'HEADER'
						if loObject.Caption = 'Header1' and ;
							not empty(loColumn.ControlSource)
							lcCaption = .GetCaption(loColumn.ControlSource)
							loObject.Caption = lcCaption
						endif loObject.Caption = 'Header1' ...
						loObject.FontName = .FontName
						loObject.FontSize = .FontSize
						exit
					endif upper(loObject.BaseClass) = 'HEADER'
				next loObject
			next loColumn
		
		* If we're supposed to auto-fit the columns, do so.
		
			if .lAutoFit
				.AutoFit()
			endif .lAutoFit
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerimage AS image 		&& The base class for Image objects
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorerimage"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerImage
		* Based On:						Image
		* Purpose:						Base class for all Image objects
		* Author:						Doug Hennig
		* Last revision:				12/15/2005
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:					0 (Transparent)
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						bind OnFormChange to Thisform.lChanged if
		*								lNotifyOnFormChange is .T.
		*	RightClick:					call This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		* If we're supposed to bind to the lChanged property of the form, do so.
		
		if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
			pemstatus(Thisform, 'lChanged', 5)
			bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
		endif This.lNotifyOnFormChange ...
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerlabel AS label 		&& The base class for Label objects
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	AutoSize = .T.
	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	Caption = "Label1"
	FontName = "Tahoma"
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorerlabel"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerLabel
		* Based On:						Label
		* Purpose:						Base class for all Label objects
		* Author:						Doug Hennig
		* Last revision:				04/27/2007
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	AutoSize:					.T.
		*	BackStyle:					0 (Transparent)
		*	FontName:					Tahoma
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						bind OnFormChange to Thisform.lChanged if
		*								lNotifyOnFormChange is .T. Change FontName to
		*								Segoe UI in Vista
		*	RightClick:					calls This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerline AS line 		&& The base class for Line objects
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorerline"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerLine
		* Based On:						Line
		* Purpose:						Base class for all Line objects
		* Author:						Doug Hennig
		* Last revision:				12/15/2005
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						bind OnFormChange to Thisform.lChanged if
		*								lNotifyOnFormChange is .T.
		*	RightClick:					calls This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		* If we're supposed to bind to the lChanged property of the form, do so.
		
		if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
			pemstatus(Thisform, 'lChanged', 5)
			bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
		endif This.lNotifyOnFormChange ...
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerlistbox AS listbox 		&& The base class for ListBox objects
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the control source
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lrequeryoninit		&& .T. to call Requery from Init
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: lupdatecontrolsource		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*a: aitems[1,0]		&& An array that can hold the values used for the ListBox when RowSourceType is 5
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	FontName = "Tahoma"
	IntegralHeight = .T.
	ItemTips = .T.
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lrequeryoninit = .T.		&& .T. to call Requery from Init
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	lupdatecontrolsource = .F.		&& .T. if UpdateControlSource should be called from InteractiveChange
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorerlistbox"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	RowSource = "This.aItems"
	RowSourceType = 5
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="aitems" type="property" display="aItems"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="lrequeryoninit" type="property" display="lRequeryOnInit"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
		<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerListBox
		* Based On:						ListBox
		* Purpose:						Base class for all ListBox objects
		* Author:						Doug Hennig
		* Last revision:				03/23/2017
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	FontName:					Tahoma
		*	IntegralHeight:				.T.
		*	ItemTips:					.T.
		*	RowSource:					This.aItems (see below)
		*	RowSourceType:				5 (Array)
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						initialize This.aItems to blanks and call
		*								This.Requery if This.lRequeryOnInit is .T. Bind
		*								InteractiveChange to the form's AnyChange
		*								method and bind OnFormChange to the form's
		*								lChanged property if necessary. Change FontName
		*								to Segoe UI in Vista
		*	InteractiveChange:			calls UpdateControlSource and raises the
		*								AnyChange event
		*	ProgrammaticChange:			raises the AnyChange event
		*	Requery:					handle RowSourceType = 1-Value when This.aItems
		*								contains the array of values
		*	RightClick:					calls This.ShowMenu
		*
		* Custom public properties added:
		*	aItems[1]:					an array that can hold the values used for the
		*								ListBox when RowSourceType is 5
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
		*								its form's AnyChange method
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lRequeryOnInit:				.T. to call Requery from Init
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUpdateControlSource:		.T. if UpdateControlSource should be called
		*								from InteractiveChange
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AnyChange:					called from the InteractiveChange and
		*								ProgrammaticChange events to consolidate
		*								change code in one place
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateControlSource:		updates the control source
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		local loParent
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* Call Requery() if we're supposed to; otherwise, initialize aItems to a blank
		* string.
		
			if .lRequeryOnInit
				.Requery()
			else
				.aItems = ''
			endif .lRequeryOnInit
		
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
			if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'AnyChange', 5)
				bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
			endif .lBindToFormAnyChange ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Update the control source in case something binding to our AnyChange event
		* looks at it.
		
		with This
			if .lUpdateControlSource
				.UpdateControlSource()
			endif .lUpdateControlSource
		endwith
		
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE Requery
		* If RowSource is 0-None or 1-Value but aItems contains values, either set
		* RowSource to a comma-delimited list of values (1-Value) or use AddItem from
		* aItems. This allows disabled lines using a prompt of "\-".
		
		lparameters tlNoAction
		local lnI
		with This
			if not tlNoAction and inlist(.RowSourceType, 0, 1) and ;
				vartype(.aItems[1]) = 'C' and (not empty(.aItems[1]) or ;
				alen(.aItems, 1) > 0)
				if .RowSourceType <> 0
					.RowSource = ''
				endif .RowSourceType <> 0
				.Clear()
				for lnI = 1 to alen(.aItems, 1)
					if .RowSourceType = 0
						.AddItem(.aItems[lnI, 1])
					else
						.RowSource = .RowSource + iif(lnI = 1, '', ',') + .aItems[lnI, 1]
					endif .RowSourceType = 0
				next lnI
			endif not tlNoAction ...
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the control source
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Public
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Last revision:	02/27/2006
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorermodaldialog AS projectexplorerform OF "projectexplorerctrls.vcx" 		&& The base class for modal dialogs
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	DoCreate = .T.
	MaxButton = .F.
	MinButton = .F.
	Name = "projectexplorermodaldialog"
	WindowType = 1
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerModalDialog
		* Based On:						ProjectExplorerForm
		* Purpose:						The base class for modal dialogs
		* Author:						Doug Hennig
		* Last revision:				06/02/2015
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	MaxButton:					.F.
		*	MinButton:					.F.
		*	WindowType:					1 (Modal)
		*
		* Changes in "Based On" class methods:
		*	Activate:					set AlwaysOnTop temporarily .T. to avoid issues
		*								with modal form behind other windows
		*	Init:						center the form in _screen or current form if
		*								reasonable
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Activate
		* Get around a problem with modal dialogs not always appearing on top of other
		* forms by setting AlwaysOnTop temporarily to .T.
		
		local llSave
		llSave = This.AlwaysOnTop
		This.AlwaysOnTop = .T.
		if not llSave
			This.AlwaysOnTop = .F.
		endif not llSave
		
	ENDPROC

	PROCEDURE Init
		* Center the form in _screen or the current screen if reasonable.
		
		local loObject
		dodefault()
		with This
			if .Desktop and .AutoCenter and (not pemstatus(This, 'oPersist', 5) or ;
				empty(.oPersist.cKey))
				do case
					case type('_screen.ActiveForm.Name') = 'C'
						loObject = _screen.ActiveForm
					case _screen.Visible and _screen.WindowState <> 1
						loObject = _screen
				endcase
				if vartype(loObject) = 'O'
					.Top  = max(loObject.Top  + (loObject.Height - .Height)/2, 0)
					.Left = loObject.Left + (loObject.Width  - .Width)/2
				endif vartype(loObject) = 'O'
			endif .Desktop ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexploreroptionbutton AS optionbutton 
 	*< CLASSDATA: Baseclass="optionbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: hideballoontip		&& Hides a balloon tip for the control
		*m: showballoontip		&& Shows a balloon tip for the control
		*p: cballoontiptitle		&& The title for the balloon tip
		*p: lballoontips		&& .T. to use balloon tips
		*p: lhaveballoontipcontrol		&& .T. if the form has a balloon tip control
		*p: oexception		&& A reference to an Exception object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lhaveballoontipcontrol
	AutoSize = .T.
	BackStyle = 0
	Caption = "Option1"
	cballoontiptitle = 		&& The title for the balloon tip
	FontName = "Tahoma"
	Height = 16
	lballoontips = .F.		&& .T. to use balloon tips
	lhaveballoontipcontrol = .NULL.		&& .T. if the form has a balloon tip control
	Name = "projectexploreroptionbutton"
	oexception = .NULL.		&& A reference to an Exception object
	Width = 63
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="hideballoontip" display="HideBalloonTip"/>
		<memberdata name="showballoontip" display="ShowBalloonTip"/>
		<memberdata name="cballoontiptitle" display="cBalloonTipTitle"/>
		<memberdata name="lballoontips" display="lBalloonTips"/>
		<memberdata name="lhaveballoontipcontrol" display="lHaveBalloonTipControl"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerOptionButton
		* Based On:						OptionButton
		* Purpose:						Base class for all OptionButton objects
		* Author:						Doug Hennig
		* Last revision:				04/27/2007
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:					0 (Transparent)
		*	FontName:					Tahoma
		*
		* Changes in "Based On" class methods:
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	GotFocus:					call This.ShowBalloonTip to show balloon tips
		*	Init:						change the font to Segoe UI in Vista
		*	KeyPress:					ignore Ctrl-0
		*	LostFocus:					call This.HideBalloonTip to hide balloon tips
		*	MouseEnter:					call This.ShowBalloonTip to show balloon tips
		*	MouseLeave:					call This.HideBalloonTip to hide balloon tips
		*
		* Custom public properties added:
		*	cBalloonTipTitle:			the title for the balloon tip
		*	lBalloonTips:				.T. to use balloon tips
		*	oException:					a reference to an Exception object
		*
		* Custom protected properties added:
		*	lHaveBalloonTipControl:		.T. if the form has a balloon tip control
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*
		* Custom protected methods added:
		*	HideBalloonTip:				hides a balloon tip for the control
		*	ShowBalloonTip:				shows a balloon tip for the control
		*==============================================================================
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE GotFocus
		This.ShowBalloonTip(.T.)
		
	ENDPROC

	PROTECTED PROCEDURE hideballoontip		&& Hides a balloon tip for the control
		if This.lBalloonTips and This.lHaveBalloonTipControl
			Thisform.oBalloonTip.ctlShow(0)
		endif This.lBalloonTips ...
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE LostFocus
		This.HideBalloonTip()
		
	ENDPROC

	PROCEDURE MouseEnter
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.ShowBalloonTip()
		
	ENDPROC

	PROCEDURE MouseLeave
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.HideBalloonTip()
		
	ENDPROC

	PROTECTED PROCEDURE showballoontip		&& Shows a balloon tip for the control
		lparameters tlGotFocus
		#define CON_BTPOS_ACTIVECTRL 	2
		#define CON_BTPOS_MOUSE			6
		#define TTI_INFO				1
		
		* Set lHaveBalloonTipControl if the form has a balloon tip control.
		
		if vartype(This.lHaveBalloonTipControl) <> 'L'
			This.lHaveBalloonTipControl = pemstatus(Thisform, 'oBalloonTip', 5)
		endif vartype(This.lHaveBalloonTipControl) <> 'L'
		
		* If we're supposed to show balloon tips and we have a control, do so.
		
		if This.lBalloonTips and This.lHaveBalloonTipControl
			Thisform.oBalloonTip.ctlShow(iif(tlGotFocus, CON_BTPOS_ACTIVECTRL, ;
				CON_BTPOS_MOUSE), This.ToolTipText, This.cBalloonTipTitle, TTI_INFO)
		endif This.lBalloonTips ...
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexploreroptiongroup AS optiongroup 		&& The base class for OptionGroup objects
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		*m: enabled_assign		&& Sets the Enabled property of the object and all member objects to the specified value so all objects appear to be enabled or disabled
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*m: validation		&& Abstract method for custom validation code
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: lskipvalidonformclose		&& .T. if we can skip validating this control when the form is closed
		*p: lupdatecontrolsource		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	ButtonCount = 2
	Height = 46
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	lskipvalidonformclose = .T.		&& .T. if we can skip validating this control when the form is closed
	lupdatecontrolsource = .T.		&& .T. if UpdateControlSource should be called from InteractiveChange
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	MemberClass = "projectexploreroptionbutton"
	MemberClassLibrary = projectexplorerctrls.vcx
	Name = "projectexploreroptiongroup"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	Width = 71
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
		<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
		</VFPData>		&& XML Metadata for customizable properties
	projectexploreroptionbutton1.Left = 5
	projectexploreroptionbutton1.Name = "projectexploreroptionbutton1"
	projectexploreroptionbutton1.Top = 5
	projectexploreroptionbutton2.Left = 5
	projectexploreroptionbutton2.Name = "projectexploreroptionbutton2"
	projectexploreroptionbutton2.Top = 24
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerOptionGroup
		* Based On:						OptionGroup
		* Purpose:						Base class for all OptionGroup objects
		* Author:						Doug Hennig
		* Last revision:				10/09/2008
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:					0 (Transparent)
		*	MemberClass:				ProjectExplorerOptionButton
		*	MemberClassLibrary:			ProjectExplorerCtrls.VCX
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						bind InteractiveChange to the form's AnyChange
		*								method and bind OnFormChange to the form's
		*								lChanged property if necessary
		*	InteractiveChange:			raises the AnyChange event
		*	ProgrammaticChange:			raises the AnyChange event
		*	RightClick:					calls This.ShowMenu
		*	Valid:						prevent validation code from executing if the
		*								user is cancelling, retain focus if a field
		*								rule failed, and call the custom Validation
		*								method
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
		*								its form's AnyChange method
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
		*								the form is closed
		*	lUpdateControlSource:		.T. if UpdateControlSource should be called
		*								from InteractiveChange
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AnyChange:					called from the InteractiveChange and
		*								ProgrammaticChange events to consolidate
		*								change code in one place
		*	Enabled_Access:				sets the Enabled property of the object and all
		*								member objects to the specified value so all
		*								objects appear to be enabled or disabled
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateControlSource:		updates the ControlSource with the new value
		*	Validation:					abstract method for custom validation code
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
	ENDPROC

	PROCEDURE enabled_assign		&& Sets the Enabled property of the object and all member objects to the specified value so all objects appear to be enabled or disabled
		* Enable or disable member objects.
		
		lparameters tlEnabled
		This.SetAll('Enabled', tlEnabled)
		This.Enabled = tlEnabled
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
			if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'AnyChange', 5)
				bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
			endif .lBindToFormAnyChange ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Update the control source in case something binding to our AnyChange event
		* looks at it.
		
		if This.lUpdateControlSource
			This.UpdateControlSource()
		endif This.lUpdateControlSource
		
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Public
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Last revision:	02/27/2006
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Last revision:	08/20/2002
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(This.lSkipValidOnFormClose and ;
			type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& Abstract method for custom validation code
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerpage AS page 
 	*< CLASSDATA: Baseclass="page" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: enabled_assign		&& Sets the Enabled property of all member objects to the specified value so they appear to be enabled or disabled
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: cmemberclass		&& The class for a delayed instantiation member
		*p: cmemberlibrary		&& The library containing the class specified in cMemberClass
		*p: lsetfocustofirstobject		&& .T. to set focus to the first object on the page when the page is activated
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	Caption = "Page1"
	cmemberclass = 		&& The class for a delayed instantiation member
	cmemberlibrary = 		&& The library containing the class specified in cMemberClass
	FontName = "Tahoma"
	Height = 142
	lsetfocustofirstobject = .T.		&& .T. to set focus to the first object on the page when the page is activated
	Name = "projectexplorerpage"
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	Width = 142
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="cmemberclass" type="property" display="cMemberClass" favorites="True"/>
		<memberdata name="cmemberlibrary" type="property" display="cMemberLibrary" favorites="True"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsetfocustofirstobject" type="property" display="lSetFocusToFirstObject"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerPage
		* Based On:						Page
		* Purpose:						Base class for all Page objects
		* Author:						Doug Hennig
		* Last revision:				03/27/2015
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	FontName:					Tahoma
		*
		* Changes in "Based On" class methods:
		*	Activate:					refresh the controls on the page and
		*								instantiate a member object
		*	Destroy:					nuke member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						change FontName to Segoe UI in Vista
		*	RightClick:					calls This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	cMemberClass:				the class for a delayed instantiation member
		*	cMemberLibrary:				the library containing the class specified in
		*								cMemberClass
		*	lSetFocusToFirstObject:		.T. to set focus to the first object on the
		*								page when the page is activated
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	Release:					releases the object
		*	Enabled_Assign:				sets the Enabled property of all member objects
		*								to the specified value so they appear to be
		*								enabled or disabled
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Activate
		local llLockScreen, ;
			llSave
		with This
		
		* Lock the screen for snappier refreshes.
		
			llLockScreen = Thisform.LockScreen
			if not llLockScreen
				Thisform.LockScreen = .T.
			endif not llLockScreen
		
		* If we're supposed to instantiate a member object and haven't yet done so, do
		* that now.
		
			if not empty(.cMemberClass) and type('.oMember.Name') <> 'C'
				if '\' + upper(.cMemberLibrary) $ set('CLASSLIB')
				 	.AddObject('oMember', .cMemberClass)
				else
				 	.NewObject('oMember', .cMemberClass, .cMemberLibrary)
				endif '\' ...
				llSave = pemstatus(.oMember, 'lSaveAnchor', 5)
				with .oMember
					if llSave
						.lSaveAnchor = .T.
					endif llSave
					.Top     = 10
					.Left    = 10
					.Width   = .Width  + This.Parent.Width  - ;
						Thisform.nInitialWidth
					.Height  = .Height + This.Parent.Height - ;
						Thisform.nInitialHeight
					.Visible = .T.
					if llSave
						.lSaveAnchor = .F.
					endif llSave
					.ZOrder(1)
				endwith
			endif not empty(.cMemberClass) ...
		
		* Refresh all controls.
		
			.Refresh()
		
		* Call Thisform.SetFocusToFirstObject to set focus to the first control on the
		* page if we're supposed to. We may not always want that behavior: the user may
		* select a page to merely view its content while leaving focus on another
		* object that's not in the pageframe. Also, don't do this if the mouse button
		* isn't down; in that case, we were activated from the keyboard. Also note that
		* we pass .T. to SetFocusToFirstObject so it doesn't change the active page of
		* any pageframes this page contains.
		
			if .lSetFocusToFirstObject and mdown()
				Thisform.SetFocusToFirstObject(This, .T.)
			endif .lSetFocusToFirstObject ...
		
		* Restore the LockScreen setting.
		
			if not llLockScreen
				Thisform.LockScreen = .F.
			endif not llLockScreen
		endwith
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE enabled_assign		&& Sets the Enabled property of all member objects to the specified value so they appear to be enabled or disabled
		* If the page is enabled or disabled, do the same for every control on the page
		* so they appear enabled or disabled.
		
		lparameters tlEnabled
		with This
			.SetAll('Enabled', tlEnabled)
			.Enabled = tlEnabled
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		endwith
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	01/25/2003
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items may have been added to the menu (abstract
		*						in this class)
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .Parent.lUseFormShortcutMenu and ;
						type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .Parent.lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerpageframe AS pageframe 		&& The base class for PageFrame objects
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: getactivepagenumber		&& Gets the page number in the Pages collection that matches the current page order
		*m: getpagenumber		&& Gets the page number in the Pages collection that matches the specified page order
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: setenabled		&& Sets the Enabled property of the specified page and all member objects to the specified value so all objects appear to be enabled or disabled
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	ActivePage = 1
	Anchor = 15
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	ErasePage = .T.
	Height = 250
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	MemberClass = "projectexplorerpage"
	MemberClassLibrary = projectexplorerctrls.vcx
	Name = "projectexplorerpageframe"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	PageCount = 1
	TabStyle = 1
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="getpagenumber" type="method" display="GetPageNumber"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="setenabled" type="method" display="SetEnabled"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="getactivepagenumber" type="method" display="GetActivePageNumber"/>
		<memberdata name="activepage" type="property" display="ActivePage"/>
		</VFPData>		&& XML Metadata for customizable properties
	projectexplorerpage1.Name = "projectexplorerpage1"
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerPageFrame
		* Based On:						PageFrame
		* Purpose:						Base class for all PageFrame objects
		* Author:						Doug Hennig
		* Last revision:				10/26/2010
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	Anchor:						15 (resize height and width)
		*	PageCount:					1
		*	MemberClass:				ProjectExplorerPage
		*	MemberClassLibrary:			ProjectExplorerCtrls.VCX
		*	TabStyle:					1 (Non-justified)
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nuke member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						bind OnFormChange to Thisform.lChanged if
		*								lNotifyOnFormChange is .T.
		*	RightClick:					calls This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	GetActivePageNumber:		gets the page number in the Pages collection
		*								that matches the current page order
		*	GetPageNumber:				gets the page number in the Pages collection
		*								that matches the specified page order
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	SetEnabled:					sets the Enabled property of the specified page
		*								and all member objects to the specified value
		*								so all objects appear to be enabled or disabled
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE getactivepagenumber		&& Gets the page number in the Pages collection that matches the current page order
		return This.GetPageNumber(This.ActivePage)
		
	ENDPROC

	PROCEDURE getpagenumber		&& Gets the page number in the Pages collection that matches the specified page order
		* Gets the page number in the Pages collection that matches the specified page
		* order. These values won't be the same if the PageOrder property for any page
		* has been changed.
		
		lparameters tnActivePage
		local lnPage, ;
			lnI
		with This
			lnPage = 0
			for lnI = 1 to .PageCount
				if .Pages[lnI].PageOrder = tnActivePage
					lnPage = lnI
					exit
				endif .Pages[lnI].PageOrder = tnActivePage
			next lnI
		endwith
		return lnPage
		
	ENDPROC

	PROCEDURE Init
		* If we're supposed to bind to the lChanged property of the form, do so.
		
		if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
			pemstatus(Thisform, 'lChanged', 5)
			bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
		endif This.lNotifyOnFormChange ...
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE setenabled		&& Sets the Enabled property of the specified page and all member objects to the specified value so all objects appear to be enabled or disabled
		* If a page is enabled or disabled, so the same for every control on the page
		* so they appear disabled.
		
		lparameters tnPage, ;
			tlEnabled
		with This.Pages[tnPage]
			if This.ActivePage = tnPage
				.SetAll('Enabled', tlEnabled)
			endif This.ActivePage = tnPage
			.Enabled = tlEnabled
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerseparator AS separator 		&& The base class for Separator objects
 	*< CLASSDATA: Baseclass="separator" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: release		&& Releases the object
	*</DefinedPropArrayMethod>

	Height = 0
	Name = "projectexplorerseparator"
	Style = 1
	Width = 0
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerSeparator
		* Based On:						Separator
		* Purpose:						The base class for all Separator objects
		* Author:						Doug Hennig
		* Last revision:				01/26/2003
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	Style:						1-Vertical Rule
		*
		* Changes in "Based On" class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	Release:					releases the object
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorershape AS shape 		&& The base class for all Shape objects
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED nsavedanchor
	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorershape"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	SpecialEffect = 0
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerShape
		* Based On:						Shape
		* Purpose:						The base class for all Shape objects
		* Author:						Doug Hennig
		* Last revision:				12/15/2005
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:					0 - Transparent
		*	SpecialEffect:				0 - 3D
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	Init:						bind OnFormChange to Thisform.lChanged if
		*								lNotifyOnFormChange is .T.
		*	RightClick:					calls This.ShowMenu
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		* If we're supposed to bind to the lChanged property of the form, do so.
		
		if This.lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
			pemstatus(Thisform, 'lChanged', 5)
			bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
		endif This.lNotifyOnFormChange ...
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerspinner AS spinner 		&& The base class for all Spinner objects
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: adjustselstart		&& Adjust SelStart as necessary
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		*m: lsaveanchor_assign
		*m: nhighvalue_assign
		*m: nlowvalue_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: setcalcvalues		&& Handles changes to any of the "calculator" properties
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*m: validation		&& An abstract method for custom validation code
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: cinputmask		&& The saved InputMask
		*p: csign		&& The saved sign of the value
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lcalculator		&& .T. to use calculator-style digit entry
		*p: lhasdecimal		&& .T. if the value has a decimal part
		*p: lhasinteger		&& .T. if the value has an integer part
		*p: lindecimalpart		&& .T. if the cursor is in the decimal part of the value
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: lskipvalidonformclose		&& .T. if we can skip validating this control when the form is closed
		*p: lupdatecontrolsource		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nhighvalue		&& The maximum value
		*p: nlowvalue		&& The minimum value
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: nselstart		&& The saved value of SelStart
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED cinputmask,csign,lhasdecimal,lhasinteger,lindecimalpart,nsavedanchor,nselstart
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	cinputmask = 		&& The saved InputMask
	csign = 		&& The saved sign of the value
	FontName = "Tahoma"
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lcalculator = .T.		&& .T. to use calculator-style digit entry
	lhasdecimal = .F.		&& .T. if the value has a decimal part
	lhasinteger = .T.		&& .T. if the value has an integer part
	lindecimalpart = .F.		&& .T. if the cursor is in the decimal part of the value
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	lskipvalidonformclose = .T.		&& .T. if we can skip validating this control when the form is closed
	lupdatecontrolsource = .T.		&& .T. if UpdateControlSource should be called from InteractiveChange
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "projectexplorerspinner"
	nhighvalue = 999999999		&& The maximum value
	nlowvalue = -99999999		&& The minimum value
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	nselstart = 0		&& The saved value of SelStart
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="adjustselstart" type="method" display="AdjustSelStart"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="cinputmask" type="property" display="cInputMask"/>
		<memberdata name="csign" type="property" display="cSign"/>
		<memberdata name="lcalculator" type="property" display="lCalculator" favorites="True"/>
		<memberdata name="lhasdecimal" type="property" display="lHasDecimal"/>
		<memberdata name="lhasinteger" type="property" display="lHasInteger"/>
		<memberdata name="lindecimalpart" type="property" display="lInDecimalPart"/>
		<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="nhighvalue" type="property" display="nHighValue" favorites="True"/>
		<memberdata name="nhighvalue_assign" type="method" display="nHighValue_Assign"/>
		<memberdata name="nlowvalue" type="property" display="nLowValue" favorites="True"/>
		<memberdata name="nlowvalue_assign" type="method" display="nLowValue_Assign"/>
		<memberdata name="nselstart" type="property" display="nSelStart"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="setcalcvalues" type="method" display="SetCalcValues"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
		<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerSpinner
		* Based On:						Spinner
		* Purpose:						The base class for all Spinner objects
		* Author:						Doug Hennig. "Calculator-style" entry based on
		*								code by Marcelo Ris published in FoxPro
		*								Advisor, June 1999
		* Last revision:				05/25/2017
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	FontName:					Tahoma
		*	SelectOnEntry:				.T.
		*
		* Changes in "Based On" class methods:
		*	Click:						if we're acting like a calculator, make any
		*								necessary adjustments to SelStart
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	GotFocus:					if we're acting like a calculator, adjust
		*								SelStart to be in the integer part
		*	Init:						initialize "calculator" values. Bind
		*								InteractiveChange to the form's AnyChange
		*								method and bind OnFormChange to the form's
		*								lChanged property if necessary. Change FontName
		*								to Segoe UI in Vista
		*	InteractiveChange:			set SelStart to its saved value and make any
		*								necessary adjustments, then raise the AnyChange
		*								event
		*	KeyPress:					handle calculator-style entry
		*	ProgrammaticChange:			set SelStart to its saved value and make any
		*								necessary adjustments, then raise the AnyChange
		*								event
		*	RightClick:					calls This.ShowMenu
		*	Valid:						prevent validation code from executing if the
		*								user is cancelling, retain focus if a field
		*								rule failed, and call the custom Validation
		*								method
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
		*								its form's AnyChange method
		*	lCalculator:				.T. to use calculator-style digit entry
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
		*								the form is closed
		*	lUpdateControlSource:		.T. if UpdateControlSource should be called
		*								from InteractiveChange
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	nHighValue:					the maximum value (Assign calls SetCalcValues)
		*	nLowValue:					the minimum value (Assign calls SetCalcValues)
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	cInputMask:					the saved InputMask
		*	cSign:						the saved sign of the value
		*	lHasDecimal:				.T. if the value has a decimal part
		*	lHasInteger:				.T. if the value has an integer part
		*	lInDecimalPart:				.T. if the cursor is in the decimal part of the
		*								value
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*	nSelStart:					the saved value of SelStart
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AnyChange:					called from the InteractiveChange and
		*								ProgrammaticChange events to consolidate
		*								change code in one place
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	SetCalcValues:				handles changes to any of the "calculator"
		*								properties
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateControlSource:		updates the ControlSource with the new value
		*	Validation:					abstract method for custom validation code
		*
		* Custom protected methods added:
		*	AdjustSelStart:				adjust SelStart as necessary
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE adjustselstart		&& Adjust SelStart as necessary
		lparameters tnMove
		local lnLen, ;
			lcText1, ;
			lcText2, ;
			lnMin, ;
			lnSelStart, ;
			lnMove, ;
			lnSelLength, ;
			lnPos, ;
			lnChar
		with This
		
		* Calculate the minimum position for the cursor by removing any non-digit
		* characters from the InputMask.
		
			lnLen   = len(.InputMask)
			lcText1 = .Text
			lcText2 = ltrim(lcText1)
			do while not empty(lcText2) and not isdigit(left(lcText2, 1))
				lcText2 = ltrim(right(lcText2, len(lcText2) - 1))
			enddo while not empty(lcText2) ...
			lnMin = len(lcText1) - len(lcText2)
		
		* Calculate the the new cursor position, keeping it between the maximum and
		* minimum values.
		
			lnSelStart = .SelStart + tnMove
			do case
				case lnSelStart < lnMin
					lnSelStart = lnMin
					lnMove     = 0
				case lnSelStart > lnLen
					lnSelStart = lnLen
					lnMove     = 0
				otherwise
					lnMove = tnMove
			endcase
		
		* Depending on whether we're moving positive or negative, move the cursor right
		* or left every time there is a non-digit on the left.
		
			if lnMove >= 0
				do while lnSelStart < lnLen and ;
					substr(.InputMask, lnSelStart + 1, 1) <> '9'
					lnSelStart = lnSelStart + 1
				enddo while lnSelStart < lnLen ...
			else
				do while lnSelStart > lnMin and ;
					substr(.InputMask, lnSelStart + 1, 1) <> '9'
					lnSelStart = lnSelStart - 1
				enddo while lnSelStart > lnMin ...
			endif lnMove >= 0
		
		* Adjust SelLength as necessary, then adjust SelStart to the new position.
		
			lnSelLength = .SelLength
			if lnSelLength > 0
				lnSelLength = max(lnSelLength - (lnSelStart - .SelStart), 0)
			endif lnSelLength > 0
			.SelStart  = lnSelStart
			.nSelStart = lnSelStart
			.SelLength = lnSelLength
		
		* Set the spinner's increment to the value (integer or decimal) corresponding
		* to the left position of the cursor.
		
			lnPos   = lnSelStart + 1
			lnChar  = 1
			lcText1 = .InputMask
			do while lnChar <= len(lcText1) 
				lcText2 = substr(lcText1, lnChar, 1)
				do case
					case lcText2 = '.'
						if lnChar <= lnSelStart
							lnPos = lnPos - 1
						endif lnChar <= lnSelStart
						lnChar = lnChar + 1
			      	case not isdigit(lcText2)
						if lnChar <= lnSelStart
							lnPos = lnPos - 1
						endif lnChar <= lnSelStart
						lcText1    = stuff(lcText1, lnChar, 1, '')
						lnSelStart = lnSelStart - 1
					otherwise
						lnChar = lnChar + 1
				endcase
			enddo while lnChar <= len(lcText1) 
			.Increment = val(strtran(stuff(lcText1, lnPos, 0, '1'), '9', '0'))
		endwith
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		* Abstract method
		
	ENDPROC

	PROCEDURE Click
		* If we're acting like a calculator, make any necessary adjustments to
		* SelStart.
		
		with This
			if .lCalculator
				.AdjustSelStart(0)
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE GotFocus
		with This
		
		* If we're acting like a calculator, adjust SelStart to be in the integer part.
		
			if .lCalculator
				if .lHasDecimal
					.AdjustSelStart(at('.', .InputMask) - .SelStart)
				else
					.AdjustSelStart(len(.InputMask) - .SelStart)
				endif .lHasDecimal
				.lInDecimalPart = not .lHasInteger
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE Init
		local loParent
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* Initialize "calculator" properties.
		
			.SetCalcValues()
		
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
			if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'AnyChange', 5)
				bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
			endif .lBindToFormAnyChange ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
		
		* If we're acting like a calculator, set SelStart to its saved value and then
		* make any necessary adjustments.
		
			if .lCalculator
				.SelStart = .nSelStart
				.AdjustSelStart(0)
			endif .lCalculator
		
		* Update the control source in case something binding to our AnyChange event
		* looks at it.
		
			if .lUpdateControlSource
				.UpdateControlSource()
			endif .lUpdateControlSource
		
		* Call a common method for handling changes.
		
			raiseevent(This, 'AnyChange')
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		local lnSelEnd, ;
			lcString, ;
			lnPos, ;
			llIntPart, ;
			lnLen, ;
			lnI, ;
			lcChar, ;
			lnAddSelStart, ;
			lnValue, ;
			llIntFull, ;
			lnDecPos, ;
			llChanged, ;
			llOtherWise, ;
			llNoDefault
		
		* Prevent Ctrl-0 from inserting a null value.
		
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
			return
		endif tnKeyCode = asc('0') ...
		with This
			if .lCalculator
		
		* If some characters are selected and the user entered a digit or hit Del,
		* replace the selected characters with the input key.
		
				if .SelLength > 0 and (between(tnKeyCode, 48, 57) or ;
					tnKeyCode = 7) and tnShiftAltCtrl = 0
					lnSelEnd  = .SelStart + .SelLength
					lcString  = .Text
					lnPos     = 1
					llIntPart = .T.
					lnLen     = len(.InputMask)
		   
		* Remove the selected characters from the value.
		
					for lnI = 1 to lnLen
						lcChar = substr(.InputMask, lnI, 1)
						do case
							case not inlist(lcChar, '.', '-', ' ') and ;
								not isdigit(lcChar)
								lcString = stuff(lcString, lnPos, 1, '')
							case lcChar = '.'
								llIntPart = .F.
								lnPos     = lnPos + 1
							case not between(lnI, .SelStart + 1, lnSelEnd)
								lnPos = lnPos + 1
							case llIntPart
								lcString = stuff(lcString, lnPos, 1, '')
							otherwise
								lcString = stuff(lcString, lnPos, 1, '0')
								lnPos    = lnPos + 1
						endcase
					next lnI
		
		* Recalculate the SelStart position.
		
					lnAddSelStart = 0
					lnPos         = at('.', .InputMask)
					do case
						case lnPos = 0
							lnAddSelStart = .SelLength
						case between(lnPos, .SelStart + 1, lnSelEnd)
							lnAddSelStart = lnPos - .SelStart
						case lnPos > lnSelEnd
							lnAddSelStart = .SelLength
					endcase
		
		* Save the new value and adjust the cursor position.
		
					lnPos     = .SelStart
					.Value    = val(lcString)
					.SelStart = lnPos
					.AdjustSelStart(lnAddSelStart - (.SelStart - lnPos))
		
		* If the user hit Del, we're done.
		
					if tnKeyCode = 7
						nodefault
						.InteractiveChange()
						return
					endif tnKeyCode = 7
				endif .SelLength > 0 ...
		
		* Save the sign if the value is non-zero.
		
				do case
					case .Value = 0
					case .Value > 0
						.cSign = ''
					otherwise
						.cSign = '-'
				endcase
		
		* Save the value, then remove non-digit characters, and substitute the cursor
		* position with CHR(1).
		
				lnValue  = .Value
				lcString = stuff(.Text, .SelStart + 1, 0, chr(1))
				lnPos    = 1
				do while lnPos <= len(lcString)
					lcChar = substr(lcString, lnPos, 1)
					if not inlist(lcChar, '.', '-', ' ', chr(1)) and ;
						not isdigit(lcChar)
						lcString = stuff(lcString, lnPos, 1, '')
					else
						lnPos = lnPos + 1
					endif not inlist(lcChar ...
				enddo while lnPos <= len(lcString)
		
		* See if the integer part is full.
		
				llIntFull = len(lcString) = len(ltrim(lcString))
				lcString  = alltrim(lcString)
		
		* Find the cursor position and remove it, then save the decimal position.
		
				lnPos    = at(chr(1), lcString) - 1
				lcString = strtran(lcString, chr(1))
				lnDecPos = at('.', lcString)
		
		* See if the cursor is in the decimal or integer position.
		
				do case
					case not .lHasDecimal
						.lInDecimalPart = .F.
					case lnPos > lnDecPos or (lnPos = lnDecPos and llIntFull)
						.lInDecimalPart = .T.
					case lnPos < lnDecPos and .lHasInteger
						.lInDecimalPart = .F.
				endcase
		
		* Process things depending on what key the user hit.
		
				lnAddSelStart = 0
				llChanged     = .F.
				llOtherwise   = .F.
				lnValue       = val(lcString)
				do case
		
		* "0" to "9": enter the digit.
		
					case between(tnKeyCode, 48, 57) and tnShiftAltCtrl = 0
						nodefault
						llNoDefault = .T.
						do case
		
		* If we're in the integer part and it isn't full, insert the character in the
		* integer part.
		
							case not .lInDecimalPart and not llIntFull
								if lnPos = lnDecPos
									lnPos = lnPos - 1
								endif lnPos = lnDecPos
								lcString  = stuff(lcString, lnPos + 1, 0, ;
									chr(tnKeyCode))
								lnValue   = val(lcString)
								llChanged = .T.
		
		* We're not at the end of the decimal area yet, so overwrite it.
		
				         	case .SelStart < len(.InputMask)
								lcString      = stuff(lcString, lnPos + 1, 1, ;
									chr(tnKeyCode))
								lnAddSelStart = 1
								lnValue       = val(lcString)
								llChanged     = .T.
						endcase
		
		* Backspace: remove the digit to the left if there is one.
		
					case tnKeyCode = 127
						nodefault
						llNoDefault = .T.
						if lnPos > 0
		
		* If we have an integer part and we're at the decimal point, move to the left
		* to put the cursor in a valid position.
		
							if .lHasInteger and substr(lcString, lnPos, 1) = '.'
								lnPos = lnPos - 1
								.lInDecimalPart = .F.
							endif .lHasInteger ...
		
		* If there is a digit on the left, remove it.
		
							if lnPos > 0 and ;
								not inlist(substr(lcString, lnPos, 1), '-', '.')
								lcString = stuff(lcString, lnPos, 1, '')
		
		* If we're at the decimal part, move the cursor to the left.
		
								if .lInDecimalPart
									lnAddSelStart = -1
								endif .lInDecimalPart
								lnValue   = val(lcString)
								llChanged = .T.
							endif lnPos > 0 ...
						endif lnPos > 0
		
		* Del: remove the digit to the right if there is one.
		
					case tnKeyCode = 7
						nodefault
						llNoDefault = .T.
						if lnPos < len(lcString) and substr(lcString, lnPos, 1) <> '-'
		
		* If we're at the decimal point and have a decimal part, put the cursor at it.
		
							if .lHasDecimal and substr(lcString, lnPos, 1) = '.'
								.lInDecimalPart = .T.
							endif .lHasDecimal ...
		
		* Remove the character after the cursor. If it's at the integer part, move to
		* the right.
		
							lcString = stuff(lcString, lnPos + 1, 1, '')
							if not .lInDecimalPart
								lnAddSelStart = 1
							endif not .lInDecimalPart
							lnValue   = val(lcString)
							llChanged = .T.
						endif lnPos < len(lcString) ...
		
		* "C": set the value to zero.
		
					case inlist(tnKeyCode, 67, 99) and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						llNoDefault = .T.
						.cSign      = ''
						lnValue     = 0.0000
						llChanged   = .T.
						if .lHasDecimal
							lnAddSelStart = at('.', .InputMask) - .SelStart
						else
							lnAddSelStart = len(.InputMask) - .SelStart
						endif .lHasDecimal
						.lInDecimalPart = not .lHasInteger
		
		* +: change to positive.
		
					case tnKeyCode = 43 and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						llNoDefault = .T.
						if .SpinnerHighValue < 0
							.cSign = '-'
							if lnValue > 0
								lnValue   = -lnValue
								llChanged = .T.
							endif lnValue > 0
						else
							.cSign = ''
							if lnValue < 0
								lnValue   = -lnValue
								llChanged = .T.
							endif lnValue < 0
						endif .SpinnerHighValue < 0
		
		* -: change to negative.
		
					case tnKeyCode = 45 and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						llNoDefault = .T.
						.cSign      = iif(.cSign = '-', '', '-')
						do case
							case .SpinnerLowValue < 0
								lnValue   = -lnValue
								llChanged = .T.
							case .cSign = '-'
					            .cSign = ''
						endcase
		
		* Decimal: change to decimal input.
		
					case tnKeyCode = asc('.') and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						llNoDefault = .T.
						if .lHasDecimal
							.lInDecimalPart = .T.
							lnAddSelStart = at('.', .InputMask) - .SelStart
							llChanged     = .T.
						endif .lHasDecimal
		
		* Home: move the cursor to the beginning.
		
					case tnKeyCode = 1
						nodefault
						.lInDecimalPart = not .lHasInteger
						lnAddSelStart   = -.SelStart
						llChanged       = .T.
		
		* End: move the cursor to the end.
		
					case tnKeyCode = 6
						nodefault
						.lInDecimalPart = .lHasDecimal
						lnAddSelStart   = len(.InputMask) - .SelStart + 1
						llChanged       = .T.
		
		* Left arrow: move the cursor to the left.
		
					case tnKeyCode = 19
						nodefault
						lnAddSelStart = -1
						llChanged     = .T.
		
		* Right arrow: move the cursor to the right.
		
					case tnKeyCode = 4
						nodefault
						lnAddSelStart = 1
						llChanged     = .T.
		
		* Ctrl-UpArrow: set the maximum value.
		
					case tnKeyCode = 141 and tnShiftAltCtrl = 2
						nodefault
						llNoDefault = .T.
						lnValue     = val(transform(.SpinnerHighValue, .cInputMask))
						.cSign      = iif(lnValue > 0, '', '-')
						llChanged   = .T.
		
		* Ctrl-DownArrow: set the minimum value.
		
					case tnKeyCode = 145 and tnShiftAltCtrl = 2
						nodefault
						llNoDefault = .T.
						lnValue     = val(transform(.SpinnerLowValue, .cInputMask))
						.cSign      = iif(lnValue > 0, '', '-')
						llChanged   = .T.
		
		* Don't do anything.
		
					otherwise
						llOtherwise = .T.
				endcase
		
		* If the value was changed, update the spinner's value and cursor position.
		
				if not llOtherwise and llChanged
					if (.cSign == '-' and lnValue > 0) or (.cSign == ''  and ;
						lnValue < 0)
						lnValue = -lnValue
					endif (.cSign == '-' ...
					lnPos     = .SelStart
					.Value    = lnValue
					.SelStart = lnPos
					.AdjustSelStart(lnAddSelStart)
				endif not llOtherwise ...
		
		* If we used a NODEFAULT and changed the value, fire InteractiveChange.
		
				if llNoDefault
					.InteractiveChange()
				endif llNoDefault
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE nhighvalue_assign
		lparameters tnValue
		with This
			.nHighValue = tnValue
			.InputMask  = ''
			.SetCalcValues()
			if .lCalculator
				.AdjustSelStart(0)
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE nlowvalue_assign
		lparameters tnValue
		This.nLowValue = tnValue
		This.SetCalcValues()
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
		
		* If we're acting like a calculator, set SelStart to its saved value and then
		* make any necessary adjustments.
		
			if .lCalculator
				.SelStart = .nSelStart
				.AdjustSelStart(0)
			endif .lCalculator
		
		* Call a common method for handling changes.
		
			raiseevent(This, 'AnyChange')
		endwith
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE setcalcvalues		&& Handles changes to any of the "calculator" properties
		local lcValue, ;
			lnPos, ;
			lcMaxMask, ;
			lnLen, ;
			lnI, ;
			lcChar, ;
			lcMinMask, ;
			lnPos, ;
			lnMax, ;
			lnMin
		with This
		
		* If the InputMask is empty, initialize it with a default value.
		
			if empty(.InputMask) and not empty(.nHighValue)
				lcValue   = trim(padr(.nHighValue, 20))
				lnPos     = at('.', lcValue)
			   .InputMask = replicate('9', floor(log10(.nHighValue)) + 1) + ;
				   	iif(lnPos > 0, '.' + replicate('9', len(lcValue) - lnPos), '')
			endif empty(.InputMask) ...
		
		* Find the maximum mask by removing any special characters from InputMask.
		
			lcMaxMask = ''
			lnLen     = len(.InputMask)
			for lnI = 1 to lnLen
				lcChar = substr(.InputMask, lnI, 1)
				if isdigit(lcChar) or lcChar = '.'
					lcMaxMask = lcMaxMask + lcChar
				endif isdigit(lcChar) or lcChar = '.'
			next lnI
		
		* Save the maximum mask in cInputMask.
		
			.cInputMask = lcMaxMask
		
		* The minimum mask is obtained by removing the first character of the maximum
		* mask so we have one character for the sign.
		
			lcMinMask = right(lcMaxMask, len(lcMaxMask) - 1)
		
		* Set SpinnerHighValue and SpinnerLowValue to valid values. We won't set the
		* Keyboard equivalents because that prevents the user from canceling out of a
		* form without entering a valid value; instead, we'll trap that in Valid.
		
			lnMax = min(val(lcMaxMask),  .nHighValue, 2147483647)
			lnMin = max(-val(lcMinMask), .nLowValue,  -2147483647)
			.SpinnerHighValue = lnMax
			.SpinnerLowValue  = lnMin
		
		* If the values are only a single digit, turn off calculator mode.
		
			if lnMin >= 0 and lnMax <= 9
				.lCalculator = .F.
			endif lnMin >= 0 and lnMax <= 9
		
		* See if the mask has integer and decimal parts, and save it.
		
			if .lCalculator
				lnPos = at('.', .InputMask) 
				if lnPos > 0
					.lHasInteger = '9' $ left(.InputMask, lnPos - 1)
					.lHasDecimal = '9' $ substr(.InputMask, lnPos)
				else
					.lHasInteger = '9' $ This.InputMask
					.lHasDecimal = .F.
				endif lnPos > 0
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	05/25/2017
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		* Abstract method.
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Public
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Last revision:	02/27/2006
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Last revision:	08/20/2002
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(This.lSkipValidOnFormClose and ;
			type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Don't allow a value outside the valid range.
		
		if not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
			return 0
		endif not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorertextbox AS textbox 		&& The base class for all TextBox objects
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		*m: hideballoontip		&& Hides a balloon tip for the control
		*m: lsaveanchor_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showballoontip		&& Shows a balloon tip for the control
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*m: validation		&& An abstract method for custom validation code
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: cballoontiptitle		&& The title for the balloon tip
		*p: lballoontips		&& .T. to use balloon tips
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lhaveballoontipcontrol		&& .T. if the form has a balloon tip control
		*p: lhideonmouseleave		&& .T. to hide the balloon tip when the mouse leaves the control
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: lskipvalidonformclose		&& .T. if we can skip validating this control when the form is closed
		*p: lupdatecontrolsource		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lhaveballoontipcontrol,nsavedanchor
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	cballoontiptitle = 		&& The title for the balloon tip
	FontName = "Tahoma"
	IntegralHeight = .F.
	lballoontips = .F.		&& .T. to use balloon tips
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lhaveballoontipcontrol = .NULL.		&& .T. if the form has a balloon tip control
	lhideonmouseleave = .T.		&& .T. to hide the balloon tip when the mouse leaves the control
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	lskipvalidonformclose = .T.		&& .T. if we can skip validating this control when the form is closed
	lupdatecontrolsource = .F.		&& .T. if UpdateControlSource should be called from InteractiveChange
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Margin = 0
	Name = "projectexplorertextbox"
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to a ProjectExplorerShortcutMenu object
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="showballoontip" type="method" display="ShowBalloonTip"/>
		<memberdata name="hideballoontip" type="method" display="HideBalloonTip"/>
		<memberdata name="lballoontips" type="property" display="lBalloonTips"/>
		<memberdata name="lhaveballoontipcontrol" type="property" display="lHaveBalloonTipControl"/>
		<memberdata name="cballoontiptitle" type="property" display="cBalloonTipTitle"/>
		<memberdata name="lhideonmouseleave" display="lHideOnMouseLeave"/>
		<memberdata name="lupdatecontrolsource" display="lUpdateControlSource"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerTextBox
		* Based On:						TextBox
		* Purpose:						The base class for all TextBox objects
		* Author:						Doug Hennig
		* Last revision:				11/25/2017
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	FontName:					Tahoma
		*	Margin:						0 so textboxes look better when font changed
		*								dynamically
		*	SelectOnEntry:				.T.
		*
		* Changes in "Based On" class methods:
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	GotFocus:					call This.ShowBalloonTip to show balloon tips
		*	Init:						bind AnyChange to the form's AnyChange method
		*								and bind OnFormChange to the form's lChanged
		*								property if necessary. Change FontName to
		*								Segoe UI in Vista.
		*	InteractiveChange:			raises the AnyChange event
		*	KeyPress:					ignore Ctrl-0 and backspace at the start of the
		*								control
		*	LostFocus:					call This.HideBalloonTip to hide balloon tips
		*	MouseEnter:					call This.ShowBalloonTip to show balloon tips
		*	MouseLeave:					call This.HideBalloonTip to hide balloon tips
		*	ProgrammaticChange:			raises the AnyChange event
		*	RightClick:					call This.ShowMenu
		*	Valid:						prevent validation code from executing if the
		*								user is cancelling, retain focus if a field
		*								rule failed, and call the custom Validation
		*								method
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	cBalloonTipTitle:			the title for the balloon tip
		*	lBalloonTips:				.T. to use balloon tips
		*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
		*								its form's AnyChange method
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
		*								the form is closed
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	lHaveBalloonTipControl:		.T. if the form has a balloon tip control
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AnyChange:					called from the InteractiveChange and
		*								ProgrammaticChange events to consolidate
		*								change code in one place
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateControlSource:		updates the ControlSource with the new value
		*	Validation:					abstract method for custom validation code
		*
		* Custom protected methods added:
		*	HideBalloonTip:				hides a balloon tip for the control
		*	ShowBalloonTip:				shows a balloon tip for the control
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		* Abstract method
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE GotFocus
		This.ShowBalloonTip(.T.)
		
	ENDPROC

	PROTECTED PROCEDURE hideballoontip		&& Hides a balloon tip for the control
		if This.lBalloonTips and This.lHaveBalloonTipControl
			Thisform.oBalloonTip.ctlShow(0)
		endif This.lBalloonTips ...
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
			if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'AnyChange', 5)
				bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
			endif .lBindToFormAnyChange ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Update the control source in case something binding to our AnyChange event
		* looks at it.
		
		if This.lUpdateControlSource
			This.UpdateControlSource()
		endif This.lUpdateControlSource
		
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
		* Prevent backspace from leaving the control.
		
		if tnKeyCode = 127 and This.SelStart = 0 and This.SelLength = 0
		   nodefault
		endif tnKeyCode = 127 ...
		
	ENDPROC

	PROCEDURE LostFocus
		This.HideBalloonTip()
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE MouseEnter
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.ShowBalloonTip()
		
	ENDPROC

	PROCEDURE MouseLeave
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		if This.lHideOnMouseLeave and This.lHaveBalloonTipControl and ;
			not Thisform.oBalloonTip.ctlCloseButton
			This.HideBalloonTip()
		endif This.lHideOnMouseLeave ...
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		raiseevent(This, 'AnyChange')
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	05/25/2017
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		* Abstract method.
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROTECTED PROCEDURE showballoontip		&& Shows a balloon tip for the control
		lparameters tlGotFocus
		#define CON_BTPOS_ACTIVECTRL 	2
		#define CON_BTPOS_MOUSE			6
		#define TTI_INFO				1
		
		* Set lHaveBalloonTipControl if the form has a balloon tip control.
		
		if vartype(This.lHaveBalloonTipControl) <> 'L'
			This.lHaveBalloonTipControl = pemstatus(Thisform, 'oBalloonTip', 5)
		endif vartype(This.lHaveBalloonTipControl) <> 'L'
		
		* If we're supposed to show balloon tips and we have a control, do so.
		
		if This.lBalloonTips and This.lHaveBalloonTipControl
			Thisform.oBalloonTip.ctlShow(iif(tlGotFocus, CON_BTPOS_ACTIVECTRL, ;
				CON_BTPOS_MOUSE), This.ToolTipText, This.cBalloonTipTitle, TTI_INFO)
		endif This.lBalloonTips ...
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Public
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Last revision:	02/27/2006
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Last revision:	08/20/2002
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(This.lSkipValidOnFormClose and ;
			type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorertimer AS timer 		&& The base class for all Timer objects
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: release		&& Releases the object
		*m: releasemembers		&& Abstract method to nuke member references
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class specified as Library,Class)
		*p: lrelease		&& .T. as the object is being released
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class specified as Library,Class)
	Height = 23
	lrelease = .F.		&& .T. as the object is being released
	Name = "projectexplorertimer"
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerTimer
		* Based On:						Timer
		* Purpose:						The base class for all Timer objects
		* Author:						Doug Hennig
		* Last revision:				02/17/2017
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	Height:						23 so the object is small when dropped on a form
		*	Width:						23 so the object is small when dropped on a form
		*
		* Changes in "Based On" class methods:
		*	Destroy:					cleanup as the object is destroyed
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	oException:					a reference to an Exception object
		*
		* Custom protected properties added:
		*	lRelease:					.T. as the object is being released
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	Release:					releases the object
		*	ReleaseMembers:				abstract method to nuke member references
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Last Revision:	09/27/2001
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Last Revision:	02/17/2017
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorertoolbar AS toolbar 		&& The base class for all Toolbar objects
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: afterrefresh		&& An abstract method of code to execute after a form is refreshed
		*m: beforerefresh		&& An abstract method of code to execute before a form is refreshed
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: finderrorhandler		&& Find the first parent for a specified object that has code in its Error method
		*m: handleerror		&& Calls the ErrorHandler method of the oError object (if there is a valid one) or displays a generic error message
		*m: refreshform		&& Refreshes the form
		*m: releasemembers		&& Abstract method to nuke member references
		*m: reseterror		&& Resets lErrorOccurred and aErrorInfo
		*m: seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: lerrorinfosaved		&& .T. if the error information has been saved in aErrorInfo
		*p: lerroroccurred		&& .T. if an error occurred (set in Error)
		*p: lrelease		&& .T. as the object is being released
		*p: nlasterror		&& The index to the last error that occurred in aErrorInfo
		*p: oerror		&& A reference to an error handling object
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to a ProjectExplorerShortcutMenu object
		*a: aerrorinfo[1,0]		&& An array of error information
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lerrorinfosaved,lrelease
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	Caption = "Toolbar1"
	lerrorinfosaved = .F.		&& .T. if the error information has been saved in aErrorInfo
	lerroroccurred = .F.		&& .T. if an error occurred (set in Error)
	lrelease = .F.		&& .T. as the object is being released
	Name = "projectexplorertoolbar"
	nlasterror = 0		&& The index to the last error that occurred in aErrorInfo
	oerror = .NULL.		&& A reference to an error handling object
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL		&& A reference to a ProjectExplorerShortcutMenu object
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="aerrorinfo" type="property" display="aErrorInfo"/>
		<memberdata name="afterrefresh" type="method" display="AfterRefresh" favorites="True"/>
		<memberdata name="beforerefresh" type="method" display="BeforeRefresh" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="finderrorhandler" type="method" display="FindErrorHandler"/>
		<memberdata name="handleerror" type="method" display="HandleError"/>
		<memberdata name="lerrorinfosaved" type="property" display="lErrorInfoSaved"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="nlasterror" type="property" display="nLastError"/>
		<memberdata name="oerror" type="property" display="oError"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="refreshform" type="method" display="RefreshForm"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
		<memberdata name="reseterror" type="method" display="ResetError"/>
		<memberdata name="seterror" type="method" display="SetError"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						ProjectExplorerToolbar
		* Based On:						Toolbar
		* Purpose:						The base class for all Toolbar objects
		* Author:						Doug Hennig
		* Last revision:				04/26/2006
		* Include file:					ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	DblClick:					don't undock the toolbar on a double-click
		*	Destroy:					hides the toolbar so it disappears faster, and
		*								clean up other things
		*	Error:						calls This.SetError and This.HandleError
		*	Release:					calls This.Cleanup
		*	RightClick:					calls This.ShowMenu
		*
		* Custom public properties added:
		*	aErrorInfo:					an array of error information
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lErrorOccurred:				.T. if an error occurred (set in Error)
		*	nLastError:					the index to the last error that occurred in
		*								aErrorInfo
		*	oException:					a reference to an Exception object
		*	oError:						a reference to an error handling object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an ProjectExplorerShortcutMenu
		*								object
		*
		* Custom protected properties added:
		*	lErrorInfoSaved:			.T. if the error information has been saved in
		*								aErrorInfo
		*	lRelease:					.T. as the object is being released
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AfterRefresh:				an abstract method of code to execute after a
		*								form is refreshed
		*	BeforeRefresh:				an abstract method of code to execute before a
		*								form is refreshed
		*	FindErrorHandler:			called by the Error method of contained objects
		*								to find a parent that has code in its Error
		*								method
		*	HandleError:				calls the ErrorHandler method of the oError
		*								object (if there is a valid one) or displays a
		*								generic error message
		*	RefreshForm:				refreshes the form
		*	ReleaseMembers:				abstract method to nuke member references
		*	ResetError:					resets lErrorOccurred and aErrorInfo
		*	SetError:					sets lErrorOccurred and aErrorInfo to
		*								information  about the most recent error
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*
		* Custom protected methods added:
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*==============================================================================
		
	ENDPROC

	PROCEDURE afterrefresh		&& An abstract method of code to execute after a form is refreshed
	ENDPROC

	PROCEDURE beforerefresh		&& An abstract method of code to execute before a form is refreshed
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Last Revision:	03/04/2000
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.oHook, oError, and oMenu are .NULL.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		This.oHook    = .NULL.
		This.oError   = .NULL.
		This.oMenu    = .NULL.
		
	ENDPROC

	PROCEDURE DblClick
		* Don't undock the toolbar on a double-click.
		
		nodefault
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Called when the object is being destroyed
		* Author:			Doug Hennig
		* Last revision:	03/04/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the toolbar and any member objects are destroyed
		*==============================================================================
		
		with This
		
		* Hide the toolbar so it appears to go away faster.
		
			.Hide()
		
		* Cleanup as the object is destroyed.
		
			.Cleanup()
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Called when an error occurs in this object or a member
		*						object
		* Author:			Doug Hennig
		* Last revision:	02/16/2003
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number where the error occurred
		* Returns:			varies
		* Environment in:	an error has occurred
		*					This.oException may contain an Exception object
		* Environment out:	control may be returned to the object/method that caused
		*						the error (either as RETURN or RETRY) or to the routine
		*						containing the READ EVENTS for the application
		*					the form may be released
		*					see This.SetError() and This.HandleError() for other
		*						environmental changes
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcReturn, ;
			lcReturnToOnCancel, ;
			lnPos, ;
			lcObject
		with This
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
			lcMethod = tcMethod
			lnLine   = tnLine
			lcSource = message(1)
			aerror(laError)
			if vartype(.oException) = 'O'
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		
		* Use SetError() and HandleError() to gather error information and handle it.
		
			.SetError(lcMethod, lnLine, lcSource, @laError)
			.lErrorInfoSaved = .F.
			lcReturn = .HandleError()
		
		* Figure out where to go if the user chooses "Cancel".
		
			do case
				case left(sys(16, 1), at('.', sys(16, 1)) - 1) = 'PROCEDURE ' + ;
					upper(.Name)
					lcReturnToOnCancel = ''
				case type('.oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = .oError.cReturnToOnCancel
				case type('oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = oError.cReturnToOnCancel
				otherwise
					lcReturnToOnCancel = 'MASTER'
			endcase
		endwith
		
		* Handle the return value, depending on whether the error was "ours" or came
		* from a member.
		
		lnPos    = at('.', lcMethod)
		lcObject = iif(lnPos = 0, '', upper(left(lcMethod, lnPos - 1)))
		do case
		
		* We're supposed to close the form, so do so and return to the master program
		* (we'll just cancel if we *are* the master program).
		
			case lcReturn = ccMSG_CLOSEFORM
				This.Release()
				if empty(lcReturnToOnCancel)
					cancel
				else
					return to &lcReturnToOnCancel
				endif empty(lcReturnToOnCancel)
		
		* This wasn't our error, so return the error resolution string.
		
			case lnPos > 0 and not (lcObject == upper(This.Name) or ;
				'DATAENVIRONMENT' $ upper(lcMethod))
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* If Cancel was chosen but the master program is this form, we'll just cancel.
		
			case lcReturn = ccMSG_CANCEL and empty(lcReturnToOnCancel)
				cancel
		
		* Cancel was chosen, so return to the master program.
		
			case lcReturn = ccMSG_CANCEL
				return to &lcReturnToOnCancel
		
		* Return to the routine in error to continue on.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE finderrorhandler		&& Find the first parent for a specified object that has code in its Error method
		*==============================================================================
		* Method:			FindErrorHandler
		* Status:			Public
		* Purpose:			Travel up the containership hierarchy until we find a
		*						parent for the specified object that has code in its
		*						Error method
		* Author:			Doug Hennig
		* Last revision:	04/02/2002
		* Parameters:		toObject - an object reference to the desired object
		* Returns:			an object reference to the first parent of the specified
		*						object that has code in its Error method if one could
		*						be found, or .NULL. if not
		* Environment in:	none
		* Environment out:	none
		* Note:				Tthis method prevents a problem with controls sitting on
		*						base class Page or Column objects -- no error trapping
		*						gets done if no custom code is directly entered into
		*						these objects
		*
		*					This mechanism only works in the VFP development
		*						environment or in an APP/EXE with debug info turned on
		*==============================================================================
		
		lparameters toObject
		local loParent
		loParent = toObject.Parent
		do while vartype(loParent) = 'O'
			do case
				case pemstatus(loParent, 'Error', 0)
					exit
				case type('loParent.Parent') = 'O'
					loParent = loParent.Parent
				otherwise
					loParent = .NULL.
			endcase
		enddo while vartype('loParent') = 'O'
		
		* If we couldn't find a valid parent object (likely because we're running in an
		* EXE with debug info turned off, let's return ourselves.
		
		if isnull(loParent)
			loParent = This
		endif isnull(loParent)
		return loParent
		
	ENDPROC

	PROCEDURE handleerror		&& Calls the ErrorHandler method of the oError object (if there is a valid one) or displays a generic error message
		*==============================================================================
		* Method:			HandleError
		* Status:			Public
		* Purpose:			Handles an error
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		none
		* Returns:			a string indicating the error resolution; see SFERRORS.H
		*						for the possible values
		* Environment in:	This.nErrorInfo points to the row in This.aErrorInfo that
		*						has information about the current error
		* Environment out:	an error message may have been displayed, or some other
		*						error resolution may have been taken
		* Notes:			if This.oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if a global oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if an ON ERROR routine is in effect, it's called
		*					if none of these is true, a generic error message is
		*						displayed
		*==============================================================================
		
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcErrorMessage, ;
			lcErrorInfo, ;
			lcSource, ;
			loError, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		with This
			lnError        = .aErrorInfo[.nLastError, cnAERR_NUMBER]
			lcMethod       = .Name + '.' + .aErrorInfo[.nLastError, cnAERR_METHOD]
			lnLine         = .aErrorInfo[.nLastError, cnAERR_LINE]
			lcErrorMessage = .aErrorInfo[.nLastError, cnAERR_MESSAGE]
			lcErrorInfo    = .aErrorInfo[.nLastError, cnAERR_OBJECT]
			lcSource       = .aErrorInfo[.nLastError, cnAERR_SOURCE]
		
		* Get a reference to our error handling object if there is one. It could either
		* be a member of the form or a global object.
		
			do case
				case vartype(.oError) = 'O'
					loError = .oError
				case type('oError.Name') = 'C'
					loError = oError
				otherwise
					loError = .NULL.
			endcase
			do case
		
		* If the error is "cannot set focus during valid" or "DataEnvironment already
		* unloaded", we'll let it go.
		
				case lnError = cnERR_CANT_SET_FOCUS or lnError = cnERR_DE_UNLOADED
					lcReturn = ccMSG_CONTINUE
		
		* We have an error handling object, so call its ErrorHandler() method.
		
				case not isnull(loError)
					lcReturn = loError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
				case not empty(on('ERROR'))
					lcError = upper(on('ERROR'))
					lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
					lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
					lcError = strtran(lcError, ',ERROR()',  ',lnError')
					lcError = strtran(lcError, ' ERROR()',  ' lnError')
					lcError = strtran(lcError, 'LINENO()',  'lnLine')
					lcError = strtran(lcError, 'MESSAGE()', 'lcErrorMessage')
					lcError = strtran(lcError, 'SYS(2018)', 'lcErrorInfo')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
					if left(lcError, 3) = 'DO ' or '=' $ lcError
						&lcError
						lcReturn = ccMSG_CONTINUE
					else
						lcReturn = &lcError
					endif left(lcError, 3) = 'DO ' ...
		
		* We don't have an error handling object, so display a dialog box.
		
				otherwise
					lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
						ccMSG_MESSAGE + ' ' + lcErrorMessage + ccCR + ;
						iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
						ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
						transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
					if version(2) = 0
						lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
							'Choose OK to continue or Cancel to cancel execution', ;
							MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
					else
						lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
							'Choose Yes to display the debugger, No to continue ' + ;
							'without the debugger, or Cancel to cancel execution', ;
							MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
					endif version(2) = 0
					lcReturn = ccMSG_CONTINUE
					do case
						case lnChoice = IDYES
							lcReturn = ccMSG_DEBUG
						case lnChoice = IDCANCEL
							lcReturn = ccMSG_CANCEL
					endcase
			endcase
		endwith
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not upper(lcReturn) $ upper(ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ;
			ccMSG_CLOSEFORM + ccMSG_DEBUG), ccMSG_CONTINUE, lcReturn)
		return lcReturn
		
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form
		*==============================================================================
		* Method:			RefreshForm
		* Status:			Public
		* Purpose:			Refreshes the form
		* Author:			Doug Hennig
		* Last revision:	11/04/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form has been refreshed and any code in the
		*						BeforeRefresh and AfterRefresh methods has executed
		*==============================================================================
		
		with This
			.LockScreen = .T.
			.BeforeRefresh()
			.Refresh()
			.AfterRefresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE Release
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
	ENDPROC

	PROCEDURE reseterror		&& Resets lErrorOccurred and aErrorInfo
		*==============================================================================
		* Method:			ResetError
		* Status:			Public
		* Purpose:			Reset lErrorOccurred and aErrorInfo
		* Author:			Doug Hennig
		* Last revision:	03/16/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.lErrorOccurred is .F.
		*					This.nLastError is 1
		*					This.aErrorInfo is dimensioned to a single blank row
		*==============================================================================
		
		with This
			.lErrorOccurred = .F.
			dimension .aErrorInfo[1, cnAERR_MAX]
			.aErrorInfo = ''
			.nLastError = 1
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error
		*==============================================================================
		* Method:			SetError
		* Status:			Public
		* Purpose:			Handle errors
		* Author:			Doug Hennig
		* Last revision:	04/26/2006
		* Parameters:		tcMethod - the method or function the error occurred in
		*					tnLine   - the line number within tcMethod
		*					tcSource - the code causing the error
		*					taError  - an array of error information
		* Returns:			.T.
		* Environment in:	This.aErrorInfo is dimensioned appropriately
		*					This.lErrorSet is .T. if this method has already been called
		*						for this error
		* Environment out:	This.lErrorOccurred is .T.
		*					This.lErrorSet is .T.
		*					This.nLastError points to the current row in This.aErrorInfo
		*					This.aErrorInfo is filled with error information as
		*						follows:
		*
		*					Column	Information
		*					------	-----------
		*					1 - 7	same as AERROR()
		*					8		method error occurred in
		*					9		line error occurred on
		*					10		code causing error
		*					11		date/time error occurred
		*					12		not used
		*					13		XML string of properties and their values for the
		*							object that caused the error (may be blank)
		*==============================================================================
		
		lparameters tcMethod, ;
			tnLine, ;
			tcSource, ;
			taError
		local lnRows, ;
			lnCols, ;
			lnLast, ;
			lnError, ;
			lnRow, ;
			lnI
		external array taError
		with This
		
		* If we've already been called, just update the method information.
		
			if .lErrorInfoSaved
				.aErrorInfo[.nLastError, cnAERR_METHOD] = tcMethod
			else
		
		* Flag that an error occurred.
		
				.lErrorOccurred  = .T.
				.lErrorInfoSaved = .T.
				lnRows = alen(taError, 1)
				lnCols = alen(taError, 2)
				lnLast = iif(empty(.aErrorInfo[1, 1]), 0, alen(.aErrorInfo, 1))
				dimension .aErrorInfo[lnLast + lnRows, cnAERR_MAX]
		
		* For each row in the error array, put each column into our array.
		
				for lnError = 1 to lnRows
					lnRow = lnLast + lnError
					for lnI = 1 to lnCols
						.aErrorInfo[lnRow, lnI] = taError[lnError, lnI]
					next lnI
		
		* Add some additional information to the current row in our array.
		
					.aErrorInfo[lnRow, cnAERR_METHOD]   = tcMethod
					.aErrorInfo[lnRow, cnAERR_LINE]     = tnLine
					.aErrorInfo[lnRow, cnAERR_SOURCE]   = ;
						iif(tcSource = .aErrorInfo[lnRow, cnAERR_MESSAGE], '', ;
						tcSource)
					.aErrorInfo[lnRow, cnAERR_DATETIME] = datetime()
				next lnError
				.nLastError = alen(.aErrorInfo, 1)
			endif not .lErrorInfoSaved
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	ProjectExplorerMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = fullpath('ProjectExplorerMenu.vcx', This.ClassLibrary)
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('ProjectExplorerShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE
