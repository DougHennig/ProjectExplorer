*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="projectexplorerpersist.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS projectexplorerpersistent AS projectexplorercustom OF "projectexplorerctrls.vcx" 		&& Base class for persistent properties objects
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: additem		&& Adds an item that should be persisted
		*m: convertchartotype		&& Converts the specified character string to the specified data type
		*m: converttypetochar		&& Converts the specified value to a character string
		*m: defineitems		&& An abstract method to define the items this class will manage
		*m: restore		&& Restores the values for one or all items
		*m: restoreone		&& Restores the value for a single item
		*m: restoreoneitem		&& Abstract method to restore a single item
		*m: save		&& Saves the values for one or all items
		*m: saveone		&& Saves the value for a single item
		*m: saveoneitem		&& Abstract method to save a single item
		*m: wasitemrestored		&& Returns .T. if the specified item was restored
		*p: lrestoreoninit		&& .T. to restore the values of the items when the object is instantiated
		*p: lsaveondestroy		&& .T. if the current values of the items should be automatically saved when the object is destroyed
		*p: lupdatetarget		&& .T. to have Restore store the value into the managed property
		*a: aitems[1,0]		&& An array of items managed by this class
	*</DefinedPropArrayMethod>

	PROTECTED aitems
	lrestoreoninit = .T.		&& .T. to restore the values of the items when the object is instantiated
	lsaveondestroy = .T.		&& .T. if the current values of the items should be automatically saved when the object is destroyed
	lupdatetarget = .T.		&& .T. to have Restore store the value into the managed property
	Name = "projectexplorerpersistent"
	_memberdata = <VFPData>
		<memberdata name="aitems" type="property" display="aItems"/>
		<memberdata name="convertchartotype" type="method" display="ConvertCharToType"/>
		<memberdata name="converttypetochar" type="method" display="ConvertTypeToChar"/>
		<memberdata name="defineitems" type="method" display="DefineItems"/>
		<memberdata name="lrestoreoninit" type="property" display="lRestoreOnInit"/>
		<memberdata name="lsaveondestroy" type="property" display="lSaveOnDestroy"/>
		<memberdata name="lupdatetarget" type="property" display="lUpdateTarget"/>
		<memberdata name="restoreone" type="method" display="RestoreOne"/>
		<memberdata name="restoreoneitem" type="method" display="RestoreOneItem"/>
		<memberdata name="saveone" type="method" display="SaveOne"/>
		<memberdata name="saveoneitem" type="method" display="SaveOneItem"/>
		<memberdata name="wasitemrestored" type="method" display="WasItemRestored"/>
		<memberdata name="additem" type="method" display="AddItem"/>
		<memberdata name="restore" type="method" display="Restore"/>
		<memberdata name="save" type="method" display="Save"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:					ProjectExplorerPersistent
		* Based On:					ProjectExplorerCustom
		* Purpose:					Persistent item base class
		* Author:					Doug Hennig
		* Last revision:			01/27/2005
		* Include file:				ProjectExplorerCtrls.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Destroy:				calls Save() if This.lSaveOnDestroy is .T.
		*	Init:					calls DefineItems(), and optionally calls
		*							Restore()
		*
		* Custom public properties added:
		*	lRestoreOnInit:			.T. to restore the values of the items when the
		*							object is instantiated
		*	lSaveOnDestroy:			.T. if the current values of the items should be
		*							automatically saved when the object is destroyed
		*	lUpdateTarget:			.T. to have Restore store the value into the
		*							managed property
		*
		* Custom protected properties added:
		*	aItems:					an array of items managed by this class
		*
		* Custom public methods added:
		*	DefineItems:			an abstract method to define the items this class
		*							will manage
		*	Restore:				restores values for one or all items
		*	Save:					saves values for one or all items
		*	WasItemRestored:		returns .T. if the specified item was restored
		*
		* Custom protected methods added:
		*	ConvertCharToType:		converts the specified character string to the
		*							specified data type
		*	ConvertTypeToChar:		converts the specified value to a character string
		*	RestoreOne:				restores the value for a single item
		*	RestoreOneItem:			abstract method to restore a single item
		*	SaveOne:				saves the value for a single item
		*	SaveOneItem:			abstract method to save a single item
		*==============================================================================
		
	ENDPROC

	PROCEDURE additem		&& Adds an item that should be persisted
		*==============================================================================
		* Method:			AddItem
		* Status:			Public
		* Purpose:			Adds an item that should be persisted
		* Author:			Doug Hennig
		* Last revision:	07/09/2008
		* Parameters:		tcKey           - the key where the item is stored in the
		*						persistent storage
		*					tcItem          - the item being persisted
		*					tcDataType      - the data type of the item (optional: if
		*						it isn't specified, the type will be determined)
		*					tlNoConvertType - .T. for no conversion or .F. to convert
		*						the persisted string to the desired data type and vice
		*						versa
		*					tuDefault       - the default values to use (optional: if
		*						it isn't specified, the current value is used)
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	the last row in This.aItems has information about the
		*						item
		*==============================================================================
		
		lparameters tcKey, ;
			tcItem, ;
			tcDataType, ;
			tlNoConvertType, ;
			tuDefault
		local lnItem
		
		* Ensure we have valid parameters.
		
		if vartype(tcKey) <> 'C' or empty(tcKey) or vartype(tcItem) <> 'C' or ;
			empty(tcItem) or (pcount() > 2 and (vartype(tcDataType) <> 'C' or ;
			empty(tcDataType))) or (pcount() > 3 and vartype(tlNoConvertType) <> 'L')
			error cnERR_ARGUMENT_INVALID
			return .F.
		endif vartype(tcKey) <> 'C' ...
		
		* Add the item to the array.
		
		with This
			lnItem = alen(.aItems, 1)
			lnItem = iif(lnItem = 1 and empty(.aItems[1, 1]), 1, lnItem + 1)
			dimension .aItems[lnItem, 6]
			.aItems[lnItem, 1] = tcKey
			.aItems[lnItem, 2] = tcItem
			if pcount() > 2
				.aItems[lnItem, 3] = tcDataType
			else
				.aItems[lnItem, 3] = type(tcItem)
			endif pcount() > 3
			.aItems[lnItem, 4] = tlNoConvertType
			.aItems[lnItem, 6] = iif(pcount() < 5, .NULL., tuDefault)
		endwith
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE convertchartotype		&& Converts the specified character string to the specified data type
		*==============================================================================
		* Method:			ConvertCharToType
		* Status:			Protected
		* Purpose:			Converts the specified character string to the specified
		*						data type
		* Author:			Doug Hennig
		* Last revision:	01/28/2005
		* Parameters:		tuValue - the value to convert
		*					tcType  - the data type to convert it to
		* Returns:			the value converted to the desired type
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tuValue, ;
			tcType
		local lcType, ;
			luReturn, ;
			lnStrict
		lcType = vartype(tuValue)
		do case
			case lcType = tcType
				luReturn = tuValue
			case tcType = 'L' and empty(tuValue)	&& CAST('' AS L) gives .T. instead of .F.
				luReturn = .F.
			otherwise
				luReturn = cast(tuValue as &tcType)
		endcase
		return luReturn
		
	ENDPROC

	PROTECTED PROCEDURE converttypetochar		&& Converts the specified value to a character string
		*==============================================================================
		* Method:			ConvertTypeToChar
		* Status:			Protected
		* Purpose:			Converts the specified value to a string
		* Author:			Doug Hennig
		* Last revision:	01/27/2005
		* Parameters:		tuValue - the value to convert
		* Returns:			the value converted to a string
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tuValue
		local lcType, ;
			lcReturn
		lcType = vartype(tuValue)
		do case
			case lcType = 'C'
				lcReturn = tuValue
			case lcType = 'L'
				lcReturn = transform(tuValue, 'Y')
			otherwise
				lcReturn = transform(tuValue)
		endcase
		return lcReturn
		
	ENDPROC

	PROCEDURE defineitems		&& An abstract method to define the items this class will manage
		*==============================================================================
		* Method:			DefineItems
		* Status:			Public
		* Purpose:			Define the items this object will manage
		* Author:			Doug Hennig
		* Last revision:	11/04/99
		* Parameters:		none
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	see This.AddItem
		* Notes:			This method must be coded in a subclass or specific
		*						instance of the object. Here's an example that defines
		*						two items, WindowTopPosition and WindowLeftPosition,
		*						and binds them to the form's Top and Left properties:
		*
		*					llOK = This.AddItem('WindowTopPosition', 'Thisform.Top')
		*					llOK = llOK and This.AddItem('WindowLeftPosition', ;
		*						'Thisform.Left')
		*					return llOK
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Save the values of the items managed by this object if
		*						necessary
		* Author:			Doug Hennig
		* Last revision:	11/04/99
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.aItems contains information about the items being
		*						managed
		* Environment out:	the persisted values for the items may have been saved
		*==============================================================================
		
		with This
			if .lSaveOnDestroy
				.Save()
			endif .lSaveOnDestroy
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Initialize the class
		* Author:			Doug Hennig
		* Last revision:	10/15/2004
		* Parameters:		tlNoRestore - .T. to not restore the persisted values for the
		*						items
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	This.aItems contains information about the items being
		*						managed
		*					the persisted values for the items may have been restored
		*==============================================================================
		
		lparameters tlNoRestore
		local llReturn
		with This
		
		* Call the method where the items to be managed is filled in.
		
			llReturn = .DefineItems()
		
		* If we're supposed to, restore the items managed by the object.
		
			if llReturn and not tlNoRestore and .lRestoreOnInit
				.Restore()
			endif llReturn ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE restore		&& Restores the values for one or all items
		*==============================================================================
		* Method:			Restore
		* Status:			Public
		* Purpose:			Restores the values for one or all items
		* Author:			Doug Hennig
		* Last revision:	02/05/2017
		* Parameters:		tcItem - the item to restore (optional: if it isn't
		*						specified, the values of all items are restored)
		* Returns:			the value if a single item was specified
		* Environment in:	none
		* Environment out:	the values of the specified item (or all items) has been
		*						restored
		*==============================================================================
		
		lparameters tcItem
		local lcItem, ;
			luReturn, ;
			lnI
		
		* Ensure that if the property was specified, it's a valid name, and that we
		* have some properties defined.
		
		lcItem   = iif(vartype(tcItem) = 'C' and not empty(tcItem), tcItem, '')
		luReturn = .NULL.
		if alen(This.aItems, 2) = 0 or empty(This.aItems[1, 1]) or ;
			empty(This.aItems[1, 2])
			error 'No items'
			return .F.
		endif alen(This.aItems, 2) = 0 ...
		with This
		
		* If no item was specified, restore them all.
		
			if empty(lcItem)
				for lnI = 1 to alen(.aItems, 1)
					.RestoreOne(lnI)
				next lnI
		
		* If an item was specified, try to find it. If we can, restore it. If not, give
		* an error.
		
			else
				lnI = ascan(.aItems, lcItem, -1, -1, 1, 15)
				if lnI > 0
					luReturn = .RestoreOne(lnI)
				else
					error cnERR_PROPERTY_NOT_FOUND, tcItem
				endif lnI > 0
			endif empty(lcItem)
		endwith
		return luReturn
		
	ENDPROC

	PROTECTED PROCEDURE restoreone		&& Restores the value for a single item
		*==============================================================================
		* Method:			RestoreOne
		* Status:			Protected
		* Purpose:			Restores the value for a single item
		* Author:			Doug Hennig
		* Last revision:	07/09/2008
		* Parameters:		tnItem - the row number in This.aItems for the item
		* Returns:			the value or .NULL. if it failed
		* Environment in:	This.aItems has been properly set up
		* Environment out:	the value for the specified item has been restored
		*					the fifth column of the row for this key in This.aItems is
		*						.T. if the value was restored
		*==============================================================================
		
		lparameters tnItem
		local lcItem, ;
			luCurrent, ;
			luDefault, ;
			luValue
		with This
		
		* If we're going to be updating the target item, get its name and current
		* value. 
		
			if .lUpdateTarget
				lcItem    = .aItems[tnItem, 2]
				luCurrent = evaluate(lcItem)
				if isnull(.aItems[tnItem, 6])
					luDefault = luCurrent
				else
					luDefault = .aItems[tnItem, 6]
				endif isnull(.aItems[tnItem, 6])
			endif .lUpdateTarget
		
		* Call RestoreOneItem to get the value, convert it to the proper data type if
		* necessary, and store it in the bound item if the value is different.
		
			luValue = .RestoreOneItem(.aItems[tnItem, 1], luDefault)
			if not isnull(luValue)
				if not .aItems[tnItem, 4]
					luValue = .ConvertCharToType(luValue, .aItems[tnItem, 3])
				endif not .aItems[tnItem, 4] ...
				if .lUpdateTarget and not luCurrent == luValue
					store luValue to (lcItem)
					.aItems[tnItem, 5] = .T.
				endif .lUpdateTarget ...
			endif isnull(luValue)
		endwith
		return luValue
		
	ENDPROC

	PROTECTED PROCEDURE restoreoneitem		&& Abstract method to restore a single item
		*==============================================================================
		* Method:			RestoreOneItem
		* Status:			Protected
		* Purpose:			Abstract method to restore a single item
		* Author:			Doug Hennig
		* Last revision:	06/26/2001
		* Parameters:		tcKey     - the key where the item is stored in the
		*						persistent storage
		*					tuDefault - the current value for the item
		* Returns:			.T. if everything went OK
		* Environment in:	see the implementation in a subclass
		* Environment out:	see the implementation in a subclass
		* Notes:			This method must be coded in a subclass or specific
		*						instance of the object
		*==============================================================================
		
		lparameters tcKey, ;
			tuDefault
		
	ENDPROC

	PROCEDURE save		&& Saves the values for one or all items
		*==============================================================================
		* Method:			Save
		* Status:			Public
		* Purpose:			Save the values for one or all items
		* Author:			Doug Hennig
		* Last revision:	02/05/2017
		* Parameters:		tcItem  - the item to save (optional: if it isn't
		*						specified, the values of all items are saved)
		*					tuValue - the value to save if a single item was specified
		*						(optional: if it isn't specified, the current value of
		*						the bound item is used)
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	the values of the specified item (or all items) has been
		*						persisted
		*==============================================================================
		
		lparameters tcItem, ;
			tuValue
		local llReturn, ;
			lnI
		
		* Ensure that if the item was specified, it's a valid name, and that we have
		* some items defined.
		
		if pcount() = 1 and (vartype(tcItem) <> 'C' or empty(tcItem))
			error cnERR_ARGUMENT_INVALID
			return .F.
		endif pcount() = 1 ...
		if alen(This.aItems, 2) = 0 or empty(This.aItems[1, 1]) or ;
			empty(This.aItems[1, 2])
			error 'No items'
			return .F.
		endif alen(This.aItems, 2) = 0 ...
		with This
		
		* If no item was specified, save them all.
		
			llReturn = .T.
			if pcount() = 0
				for lnI = 1 to alen(.aItems, 1)
					llReturn = llReturn and .SaveOne(lnI)
				next lnI
		
		* If an item was specified, try to find it. If we can, save it. If not, give an
		* error.
		
			else
				lnI = ascan(.aItems, tcItem, -1, -1, 1, 15)
				do case
					case lnI = 0
						error cnERR_PROPERTY_NOT_FOUND, tcItem
						llReturn = .F.
					case pcount() = 1
						llReturn = .SaveOne(lnI)
					otherwise
						llReturn = .SaveOne(lnI, tuValue)
				endcase
			endif pcount() = 0
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE saveone		&& Saves the value for a single item
		*==============================================================================
		* Method:			SaveOne
		* Status:			Protected
		* Purpose:			Saves the value for a single item
		* Author:			Doug Hennig
		* Last revision:	03/15/2002
		* Parameters:		tnItem  - the row number in This.aItems for the item
		*					tuValue - the value to save if a single item was specified
		*						(optional: if it isn't specified, the current value of
		*						the bound item is used)
		* Returns:			.T. if everything went OK
		* Environment in:	This.aItems has been properly set up
		* Environment out:	the value for the specified item has been saved
		*==============================================================================
		
		lparameters tnItem, ;
			tuValue
		local luValue, ;
			llReturn
		with This
		
		* If it wasn't passed, get the value from the bound item. Convert the value to
		* character if we're supposed to, then call SaveOneItem to save it.
		
			if pcount() = 1
				luValue = evaluate(.aItems[tnItem, 2])
			else
				luValue = tuValue
			endif pcount() = 1
			if not .aItems[tnItem, 4]
				luValue = .ConvertTypeToChar(luValue)
			endif not .aItems[tnItem, 4]
			llReturn = .SaveOneItem(.aItems[tnItem, 1], luValue)
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE saveoneitem		&& Abstract method to save a single item
		*==============================================================================
		* Method:			SaveOneItem
		* Status:			Protected
		* Purpose:			Abstract method to save a single item
		* Author:			Doug Hennig
		* Last revision:	06/26/2001
		* Parameters:		tcKey   - the key where the item is stored in the
		*						persistent storage
		*					tuValue - the value to store
		* Returns:			.T. if everything went OK
		* Environment in:	see the implementation in a subclass
		* Environment out:	see the implementation in a subclass
		* Notes:			This method must be coded in a subclass or specific
		*						instance of the object
		*==============================================================================
		
		lparameters tcKey, ;
			tuValue
		
	ENDPROC

	PROCEDURE wasitemrestored		&& Returns .T. if the specified item was restored
		*==============================================================================
		* Method:			WasItemRestored
		* Status:			Public
		* Purpose:			Returns .T. if the specified item was restored
		* Author:			Doug Hennig
		* Last revision:	02/05/2017
		* Parameters:		tcItem - the item to restore
		* Returns:			.T. if the item was restored
		* Environment in:	none
		* Environment out:	the values of the specified item (or all items) has been
		*						restored
		*==============================================================================
		
		lparameters tcItem
		local llReturn, ;
			lnI
		
		* Ensure that if the property was specified, it's a valid name, and that we
		* have some properties defined.
		
		if pcount() = 1 and (vartype(tcItem) <> 'C' or empty(tcItem))
			error cnERR_ARGUMENT_INVALID
			return .F.
		endif pcount() = 1 ...
		if alen(This.aItems, 2) = 0 or empty(This.aItems[1, 1]) or ;
			empty(This.aItems[1, 2])
			error 'No items'
			return .F.
		endif alen(This.aItems, 2) = 0 ...
		with This
		
		* Try to find the item. If we can, return .T. if it was restored.
		
			lnI = ascan(.aItems, tcItem, -1, -1, 1, 15)
			if lnI > 0
				llReturn = .aItems[lnI, 5]
			else
				error cnERR_PROPERTY_NOT_FOUND, tcItem
				llReturn = .F.
			endif lnI > 0
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerpersistentfile AS projectexplorerpersistent OF "projectexplorerpersist.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: cfilepath_assign
		*p: cfilepath		&& The file used for persistent storage
	*</DefinedPropArrayMethod>

	cfilepath = 		&& The file used for persistent storage
	Name = "projectexplorerpersistentfile"
	_memberdata = <VFPData>
		<memberdata name="cfilepath" type="property" display="cFilePath"/>
		<memberdata name="cfilepath_assign" type="method" display="cFilePath_Assign"/>
		</VFPData>
	
	PROCEDURE cfilepath_assign
		lparameters tcValue
		This.cFilePath = fullpath(tcValue)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerpersistentform AS projectexplorerpersistentregistry OF "projectexplorerpersist.vcx" 		&& Saves and restores form size and position
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: nheight		&& The height for the form
		*p: nleft		&& The left position for the form
		*p: ntop		&& The top position for the form
		*p: nwidth		&& The width for the form
		*p: oobject		&& An object to persist size and position for; if .NULL, Thisform is used
	*</DefinedPropArrayMethod>

	Name = "projectexplorerpersistentform"
	nheight = 0		&& The height for the form
	nleft = 0		&& The left position for the form
	ntop = 0		&& The top position for the form
	nwidth = 0		&& The width for the form
	oobject = .NULL.		&& An object to persist size and position for; if .NULL, Thisform is used
	_memberdata = <VFPData>
		<memberdata name="nheight" type="property" display="nHeight"/>
		<memberdata name="nleft" type="property" display="nLeft"/>
		<memberdata name="ntop" type="property" display="nTop"/>
		<memberdata name="nwidth" type="property" display="nWidth"/>
		<memberdata name="oobject" type="property" display="oObject"/>
		</VFPData>
	
	PROCEDURE defineitems
		* We'll manage the left, top, height, and width properties of the form.
		
		with This
			.AddItem('Left',   'This.nLeft')
			.AddItem('Top',    'This.nTop')
			.AddItem('Height', 'This.nHeight')
			.AddItem('Width',  'This.nWidth')
		endwith
		
	ENDPROC

	PROCEDURE restore
		lparameters tcItem
		local loObject, ;
			luReturn, ;
			lnMaxLeft, ;
			lnMaxTop, ;
			lnMaxWidth, ;
			lnMaxHeight
		if pcount() = 0
			luReturn = dodefault()
		else
			luReturn = dodefault(tcItem)
		endif pcount() = 0
		
		* If we have a specific object, use it. Otherwise, use Thisform.
		
		do case
			case vartype(This.oObject) = 'O'
				loObject = This.oObject
			case type('Thisform.Name') = 'C'
				loObject = Thisform
		endcase
		if vartype(loObject) = 'O'
			with This
		
		* If the form has Desktop .T., is a top-level form, or is dockable, get the
		* size of the virtual desktop. Otherwise, use the size of _screen.
		
				if pemstatus(loObject, 'Desktop', 5) and (loObject.Desktop or ;
					loObject.ShowWindow = 2 or loObject.Dockable > 0)
					declare integer GetSystemMetrics in Win32API integer
					#define SM_XVIRTUALSCREEN  76	&& virtual left
					#define SM_YVIRTUALSCREEN  77	&& virtual top
					#define SM_CXVIRTUALSCREEN 78   && virtual width
					#define SM_CYVIRTUALSCREEN 79   && virtual height
					lnMaxLeft   = GetSystemMetrics(SM_XVIRTUALSCREEN)
					lnMaxTop    = GetSystemMetrics(SM_YVIRTUALSCREEN)
					lnMaxWidth  = GetSystemMetrics(SM_CXVIRTUALSCREEN)
					lnMaxHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN)
				else
					lnMaxLeft   = 0
					lnMaxTop    = 0
					lnMaxWidth  = _screen.Width
					lnMaxHeight = _screen.Height
				endif pemstatus(loObject, 'Desktop', 5) ...
		
		* Test to see if the object is _screen.
		
				_screen.Tag = sys(2015)
				do case
		
		* If we restored the properties, ensure the form isn't moved or sized outside
		* the desktop boundaries.
		
					case .WasItemRestored('Top') or .WasItemRestored('Left') or ;
						.WasItemRestored('Height') or .WasItemRestored('Width')
						loObject.Width  = min(max(.nWidth,  0, loObject.MinWidth), ;
							lnMaxWidth)
						loObject.Height = min(max(.nHeight, 0, loObject.MinHeight), ;
							lnMaxHeight)
						do case
		
		* If we're past the left edge, move it to the left edge.
		
							case .nLeft < lnMaxLeft
								loObject.Left = lnMaxLeft
		
		* If we're past the right edge of the screen, move it to the right edge.
		
							case .nLeft + loObject.Width > lnMaxWidth + lnMaxLeft and ;
								not loObject.Tag == _screen.Tag
								loObject.Left = lnMaxWidth + lnMaxLeft - loObject.Width
		
		* We're cool, so put it where it was last time. If this form was ShowWindow set
		* to 1-In Top-Level Form and the current top-level form is on a different
		* monitor than the saved position, do this code twice; the first time, it
		* gives a value that places the form on the wrong monitor but it works the
		* second time.
		
							otherwise
								loObject.Left = .nLeft
								loObject.Left = .nLeft
						endcase
						do case
		
		* If we're past the top edge, move it to the top edge.
		
							case .nTop < lnMaxTop
								loObject.Top = lnMaxTop
		
		* If we're past the bottom edge of the screen, move it to the bottom edge.
		
							case .nTop + loObject.Height > lnMaxHeight + lnMaxTop and ;
								not loObject.Tag == _screen.Tag
								loObject.Top = lnMaxHeight + lnMaxTop - loObject.Height
		
		* We're cool, so put it where it was last time.
		
							otherwise
								loObject.Top = .nTop
						endcase
		
		* If we didn't, force the form to AutoCenter if we're supposed to.
		
					otherwise
						loObject.AutoCenter = loObject.AutoCenter
				endcase
			endwith
		endif vartype(loObject) = 'O'
		return luReturn
		
	ENDPROC

	PROCEDURE save
		lparameters tcItem, ;
			tuValue
		local loObject, ;
			luReturn
		with This
		
		* If we have a specific object, use it. Otherwise, use Thisform.
		
			do case
				case vartype(.oObject) = 'O'
					loObject = .oObject
				case type('Thisform.Name') = 'C'
					loObject = Thisform
			endcase
			if vartype(loObject) = 'O'
				.nWidth  = loObject.Width
				.nHeight = loObject.Height
				.nLeft   = loObject.Left
				.nTop    = loObject.Top
			endif vartype(loObject) = 'O'
		endwith
		do case
			case pcount() = 0
				luReturn = dodefault()
			case pcount() = 1
				luReturn = dodefault(tcItem)
			otherwise
				luReturn = dodefault(tcItem, tuValue)
		endcase
		return luReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerpersistentinifile AS projectexplorerpersistentfile OF "projectexplorerpersist.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "projectexplorerpersistentinifile"
	
	PROCEDURE Init
		lparameters tlNoRestore
		declare integer GetPrivateProfileString in Win32API ;
			string cSection, string cEntry, string cDefault, string @ cBuffer, ;
			integer nBufferSize, string cINIFile
		declare integer WritePrivateProfileString in Win32API ;
			string cSection, string cEntry, string cValue, string cINIFile
		dodefault(tlNoRestore)
		
	ENDPROC

	PROCEDURE restoreoneitem
		*==============================================================================
		* Method:			RestoreOneItem
		* Status:			Protected
		* Purpose:			Restores the value of a single item from the INI file
		* Author:			Doug Hennig
		* Last revision:	06/28/2001
		* Parameters:		tcKey     - the key where the item is stored in the
		*						persistent storage (the section name and key name
		*						separated with commas)
		*					tuDefault - the current value for the item
		* Returns:			the value from the INI file
		* Environment in:	This.cFilePath contains the name of the INI file
		* Environment out:	none
		*==============================================================================
		
		lparameters tcKey, ;
			tuDefault
		local luValue, ;
			lnPos, ;
			lcSection, ;
			lcKey, ;
			lcBuffer, ;
			lcDefault, ;
			luValue
		#define ccNULL             chr(0)
		#define cnBUFFER_SIZE      2048
		with This
		
		* Ensure we have a valid INI file. If not, we can't do anything.
		
			if empty(.cFilePath) or vartype(.cFilePath) <> 'C' or not file(.cFilePath)
				luValue = .NULL.
		
		* Read the value from the INI file.
		
			else
				lnPos     = at(',', tcKey)
				lcSection = left(tcKey, lnPos - 1)
				lcKey     = substr(tcKey, lnPos + 1)
				lcBuffer  = replicate(ccNULL, cnBUFFER_SIZE)
				lcDefault = .ConvertTypeToChar(tuDefault)
				GetPrivateProfileString(lcSection, lcKey, lcDefault, @lcBuffer, ;
					cnBUFFER_SIZE, .cFilePath)
				luValue   = strtran(lcBuffer, ccNULL)
			endif empty(.cFilePath) ...
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE saveoneitem
		*==============================================================================
		* Method:			SaveOneItem
		* Status:			Protected
		* Purpose:			Saves the value of a single item to the INI file
		* Author:			Doug Hennig
		* Last revision:	06/28/2001
		* Parameters:		tcKey   - the key where the item is stored in the
		*						persistent storage (the section name and key name
		*						separated with commas)
		*					tuValue - the value to store
		* Returns:			.T. if everything went OK
		* Environment in:	This.cFilePath contains the name of the INI file
		* Environment out:	the value for the specified item has been saved
		*==============================================================================
		
		lparameters tcKey, ;
			tuValue
		local lnPos, ;
			lcSection, ;
			lcKey, ;
			llReturn
		with This
		
		* If we have a valid INI file and section, save it.
		
			if not empty(.cFilePath) and vartype(.cFilePath) = 'C' and file(.cFilePath)
				lnPos     = at(',', tcKey)
				lcSection = left(tcKey, lnPos - 1)
				lcKey     = substr(tcKey, lnPos + 1)
				llReturn  = WritePrivateProfileString(lcSection, lcKey, tuValue, ;
					.cFilePath) > 0
			endif not empty(.cFilePath) ...
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerpersistentregistry AS projectexplorerpersistent OF "projectexplorerpersist.vcx" 		&& Saves and restores persistent properties from the Registry
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ckey		&& The Registry key where the properties should be stored
		*p: cregistryclass		&& The class to use for Registry handling
		*p: cregistrylibrary		&& The library the cRegistryClass is located in
		*p: oregistry		&& An object reference to the Registry handling object
	*</DefinedPropArrayMethod>

	ckey = 		&& The Registry key where the properties should be stored
	cregistryclass = ProjectExplorerRegistry		&& The class to use for Registry handling
	cregistrylibrary = ProjectExplorerRegistry.vcx		&& The library the cRegistryClass is located in
	Name = "projectexplorerpersistentregistry"
	oregistry = .NULL.		&& An object reference to the Registry handling object
	_memberdata = <VFPData>
		<memberdata name="ckey" type="property" display="cKey"/>
		<memberdata name="cregistryclass" type="property" display="cRegistryClass"/>
		<memberdata name="cregistrylibrary" type="property" display="cRegistryLibrary"/>
		<memberdata name="oregistry" type="property" display="oRegistry"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:					ProjectExplorerPersistentRegistry
		* Based On:					ProjectExplorerPersistent
		* Purpose:					Read/save persistent properties from the Registry
		* Author:					Doug Hennig
		* Last revision:			11/18/2017
		* Include file:				none
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Init:					instantiate a registry class into This.oRegistry
		*							and set the cKey property from a passed value
		*	RestoreOneItem:			reads the value of a single item from the Registry
		*	ReleaseMembers:			nuke member objects
		*	SaveOneItem:			saves the value of a single item to the Registry
		*
		* Custom public properties added:
		*	cKey:					the Registry key where the values should be stored
		*	cRegistryClass:			the class to use for Registry handling (default =
		*							ProjectExplorerRegistry)
		*	cRegistryLibrary:		the library the cRegistryClass is located in
		*							(default = ProjectExplorerRegistry.vcx)
		*	oRegistry:				an object reference to the Registry handling object
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	none
		*
		* Custom protected methods added:
		*	none
		*==============================================================================
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Instantiate a registry class into This.oRegistry and set
		*						the cKey property from a passed value
		* Author:			Doug Hennig
		* Last revision:	02/22/2008
		* Parameters:		tcKey       - the Registry key to use
		*					tlNoRestore - .T. to not restore the persisted values for
		*						the items
		* Returns:			.T. if everything went OK
		* Environment in:	the class specified in This.cRegistryClass and
		*						This.cRegistryLibrary can be found
		* Environment out:	This.oRegistry contains a reference to a Registry handling
		*						object
		*					if tcKey was passed, it's put into This.cKey
		*==============================================================================
		
		lparameters tcKey, ;
			tlNoRestore
		with This
		
		* Save the key if it was specified.
		
			if vartype(tcKey) = 'C' and not empty(tcKey)
				.cKey = tcKey
			endif vartype(tcKey) = 'C' ...
		
		* Create a registry object to do the actual dirty work.
		
			.oRegistry = newobject(.cRegistryClass, ;
				fullpath(.cRegistryLibrary, .ClassLibrary), '', .cKey)
		endwith
		return dodefault(iif(empty(This.cKey), .T., tlNoRestore))
		
	ENDPROC

	PROCEDURE releasemembers
		*==============================================================================
		* Method:			ReleaseMembers
		* Status:			Public
		* Purpose:			Nuke the member objects
		* Author:			Doug Hennig
		* Last revision:	11/04/99
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.oRegistry is set to .NULL.
		*==============================================================================
		
		dodefault()
		This.oRegistry = .NULL.
		
	ENDPROC

	PROCEDURE restoreoneitem
		*==============================================================================
		* Method:			RestoreOneItem
		* Status:			Protected
		* Purpose:			Restores the value of a single item from the Registry
		* Author:			Doug Hennig
		* Last revision:	06/26/2001
		* Parameters:		tcKey     - the key where the item is stored in the
		*						persistent storage
		*					tuDefault - the current value for the item
		* Returns:			the value from the Registry
		* Environment in:	This.cKey contains the key for the Registry
		* Environment out:	none
		*==============================================================================
		
		lparameters tcKey, ;
			tuDefault
		local luValue, ;
			llKey
		with This
		
		* Ensure we have a valid key. If not, we can't do anything.
		
			if empty(.cKey)
				luValue = .NULL.
		
		* Use the oRegistry object to get the value.
		
			else
				llKey   = .oRegistry.IsKeyValue(.cKey, tcKey)
				luValue = iif(llKey, .oRegistry.GetKey(.cKey, tcKey), tuDefault)
			endif empty(.cKey)
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE saveoneitem
		*==============================================================================
		* Method:			SaveOneItem
		* Status:			Protected
		* Purpose:			Abstract method to save a single item
		* Author:			Doug Hennig
		* Last revision:	06/26/2001
		* Parameters:		tcKey   - the key where the item is stored in the
		*						persistent storage
		*					tuValue - the value to store
		* Returns:			.T. if everything went OK
		* Environment in:	This.cKey contains the key for the Registry
		* Environment out:	the value for the specified item has been saved
		*==============================================================================
		
		lparameters tcKey, ;
			tuValue
		local llReturn
		with This
		
		* If we have a valid key, use the oRegistry object to save it.
		
			if not empty(.cKey)
				llReturn = .oRegistry.SetKey(.cKey, tcKey, tuValue)
			endif empty(.cKey)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerpersistenttable AS projectexplorerpersistentfile OF "projectexplorerpersist.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: opentable		&& Opens the persistence table
		*p: calias		&& The alias of the persistence table
		*p: ckeyfield		&& The name of the field containing the key
		*p: ctag		&& The tag on which to seek for the value
		*p: cvaluefield		&& The name of the field containing the value
	*</DefinedPropArrayMethod>

	calias = 		&& The alias of the persistence table
	ckeyfield = KEY		&& The name of the field containing the key
	ctag = KEY		&& The tag on which to seek for the value
	cvaluefield = VALUE		&& The name of the field containing the value
	Name = "projectexplorerpersistenttable"
	_memberdata = <VFPData>
		<memberdata name="calias" type="property" display="cAlias"/>
		<memberdata name="ckeyfield" type="property" display="cKeyField"/>
		<memberdata name="ctag" type="property" display="cTag"/>
		<memberdata name="cvaluefield" type="property" display="cValueField"/>
		<memberdata name="opentable" type="method" display="OpenTable"/>
		</VFPData>
	
	PROCEDURE Init
		lparameters tlNoRestore
		if empty(This.cAlias)
			This.cAlias = sys(2015)
		endif empty(This.cAlias)
		dodefault(tlNoRestore)
		
	ENDPROC

	PROCEDURE opentable		&& Opens the persistence table
		local llReturn
		with This
			do case
				case used(.cAlias)
					llReturn = .T.
				case used(juststem(.cFilePath))
					.cAlias  = juststem(.cFilePath)
					llReturn = .T.
				case empty(.cFilePath) or vartype(.cFilePath) <> 'C' or ;
					not file(.cFilePath)
					llReturn = .F.
				otherwise
					use (.cFilePath) again alias(.cAlias) shared in 0
					llReturn = used(.cAlias)
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE restoreoneitem
		*==============================================================================
		* Method:			RestoreOneItem
		* Status:			Protected
		* Purpose:			Restores the value of a single item from the table
		* Author:			Doug Hennig
		* Last revision:	06/13/2003
		* Parameters:		tcKey     - the key where the item is stored in the
		*						persistent storage
		*					tuDefault - the current value for the item
		* Returns:			the value from the table
		* Environment in:	This.cAlias contains the alias of the table, This.cTag
		*						contains the tag to seek on for the key, and
		*						This.cValueField contains the name of the value field
		* Environment out:	none
		*==============================================================================
		
		lparameters tcKey, ;
			tuDefault
		local luValue
		with This
			do case
				case not .OpenTable()
					luValue = .NULL.
				case not seek(upper(tcKey), .cAlias, .cTag)
					luValue = tuDefault
				otherwise
					luValue = evaluate(.cAlias + '.' + .cValueField)
		*** Commented out: we don't want to do this because can use expression (eg.
		*** "=SomeUDF()" to evaluate immediately and "<<expression>>" to evaluate
		*** at the time it's actually used
		***			if vartype(luValue) = 'C' and '<<' $ luValue
		*				luValue = textmerge(luValue + chr(0))
		*			endif vartype(luValue) = 'C' ...
			endcase
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE saveoneitem
		*==============================================================================
		* Method:			SaveOneItem
		* Status:			Protected
		* Purpose:			Saves the value of a single item to the table
		* Author:			Doug Hennig
		* Last revision:	04/24/2005
		* Parameters:		tcKey   - the key where the item is stored in the
		*						persistent storage
		*					tuValue - the value to store
		* Returns:			.T. if everything went OK
		* Environment in:	This.cAlias contains the alias of the table, This.cTag
		*						contains the tag to seek on for the key,
		*						This.cValueField contains the name of the value field,
		*						and This.cKeyField contains the name of the key field
		* Environment out:	the value for the specified item has been saved
		*==============================================================================
		
		lparameters tcKey, ;
			tuValue
		local llReturn, ;
			lcKey, ;
			lcValue
		with This
			do case
				case not .OpenTable()
					llReturn = .F.
				case not seek(upper(tcKey), .cAlias, .cTag)
					lcKey   = .cKeyField
					lcValue = .cValueField
					insert into (.cAlias) (&lcKey, &lcValue) values (tcKey, tuValue)
					llReturn = .T.
				otherwise
					replace (.cValueField) with tuValue in (.cAlias)
					llReturn = .T.
			endcase
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE
