*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="projectexplorerfilectrls.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS projectexplorerdirectory AS projectexplorercontainer OF "projectexplorerctrls.vcx" 		&& A container with a label, textbox, and button for a directory
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGetFile" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: adjustcontrols		&& Adjusts the control positions
		*m: anychange		&& Fired when the value of cDirectory changes
		*m: cdirectory_access
		*m: cdirectory_assign
		*m: clabelcaption_assign
		*m: validation		&& Allows validation
		*m: value_access
		*m: value_assign
		*p: ccaption		&& The caption for the GETDIR() dialog
		*p: ccontrolsource		&& The item this control's value is bound to
		*p: cdirectory		&& The directory
		*p: clabelcaption		&& The caption to use for the label
		*p: ctext		&& The text for the GETDIR() dialog
		*p: ladjustpositions		&& .T. if we should adjust the positions of the controls
		*p: value		&& The value of the control
	*</DefinedPropArrayMethod>

	Anchor = 10
	builder = \Development\Tools\SFFramework\Builders\SFBuilders.vcx,SFFileBuilder
	ccaption = Select Directory		&& The caption for the GETDIR() dialog
	ccontrolsource = 		&& The item this control's value is bound to
	cdirectory = 		&& The directory
	clabelcaption = 		&& The caption to use for the label
	ctext = 		&& The text for the GETDIR() dialog
	Height = 23
	ladjustpositions = .T.		&& .T. if we should adjust the positions of the controls
	Name = "projectexplorerdirectory"
	value = 		&& The value of the control
	Width = 343
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
		<memberdata name="ccontrolsource" type="property" display="cControlSource" favorites="True"/>
		<memberdata name="cdirectory" type="property" display="cDirectory"/>
		<memberdata name="cdirectory_access" type="method" display="cDirectory_Access"/>
		<memberdata name="cdirectory_assign" type="method" display="cDirectory_Assign"/>
		<memberdata name="ladjustpositions" type="property" display="lAdjustPositions" favorites="True"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="clabelcaption" type="property" display="cLabelCaption"/>
		<memberdata name="clabelcaptiion" type="property" display="cLabelCaptiion"/>
		<memberdata name="value" type="property" display="Value"/>
		<memberdata name="value_access" type="method" display="Value_Access"/>
		<memberdata name="value_assign" type="method" display="Value_Assign"/>
		<memberdata name="ctext" type="property" display="cText"/>
		<memberdata name="clabelcaption_assign" type="method" display="cLabelCaption_Assign"/>
		<memberdata name="adjustcontrols" type="method" display="AdjustControls"/>
		</VFPData>

	ADD OBJECT 'cmdGetFile' AS projectexplorergetdir WITH ;
		Anchor = 8, ;
		cafterdone = This.Parent.Validation(), ;
		cresult = This.Parent.cDirectory, ;
		Left = 320, ;
		Name = "cmdGetFile", ;
		TabStop = .F.
		*< END OBJECT: ClassLib="projectexplorerbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lblFile' AS projectexplorerlabel WITH ;
		Caption = "Directory", ;
		Name = "lblFile", ;
		Top = 3
		*< END OBJECT: ClassLib="projectexplorerctrls.vcx" BaseClass="label" />

	ADD OBJECT 'txtFile' AS projectexplorertextbox WITH ;
		Anchor = 10, ;
		Left = 55, ;
		MaxLength = 254, ;
		Name = "txtFile", ;
		Width = 265
		*< END OBJECT: ClassLib="projectexplorerctrls.vcx" BaseClass="textbox" />
	
	PROTECTED PROCEDURE adjustcontrols		&& Adjusts the control positions
		* Set the caption of the label if we need to and adjust the control position to
		* account for the size of the caption.
		
		lparameters tlForce
		with This
			if not empty(.cLabelCaption) and ;
				(not .lblFile.Caption == .cLabelCaption or tlForce)
				.lblFile.Caption  = .cLabelCaption
				.lblFile.AutoSize = .T.
				if .lAdjustPositions
					.txtFile.Left    = .lblFile.Width + 5
					.txtFile.Width   = .Width - .txtFile.Left - .cmdGetFile.Width
					.cmdGetFile.Left = .txtFile.Left + .txtFile.Width
				endif .lAdjustPositions
			endif not empty(.cLabelCaption) ...
		endwith
		
	ENDPROC

	PROCEDURE anychange		&& Fired when the value of cDirectory changes
		* Abstract method
		
	ENDPROC

	PROCEDURE cdirectory_access
		return addbs(alltrim(This.txtFile.Value))
		
	ENDPROC

	PROCEDURE cdirectory_assign
		lparameters tcDirectory
		local lcDirectory, ;
			lnPos, ;
			llChanged, ;
			lcAlias, ;
			lcField
		with This
			lcDirectory = alltrim(tcDirectory)
		
		* Update the Value of the textbox if we're not being called from it.
		
			if not 'TXTFILE.ANYCHANGE' $ program(program(-1) - 1) and ;
				not 'TXTFILE.ANYCHANGE' $ program(program(-1) - 2)
				.txtFile.Value = lcDirectory
			endif not 'TXTFILE.ANYCHANGE' $ program(program(-1) - 1) ...
		
		* Write the value to our ControlSource.
		
			if not .CalledFromThisClass()
				lnPos = at('.', .cControlSource)
				if lnPos > 0 and not lcDirectory == alltrim(evaluate(.cControlSource))
					llChanged = .T.
					lcAlias   = left(.cControlSource, lnPos - 1)
					lcField   = substr(.cControlSource, lnPos + 1)
					if used(lcAlias)
						replace (lcField) with lcDirectory in (lcAlias)
					else
						store lcDirectory to (.cControlSource)
					endif used(lcAlias)
				endif lnPos > 0 ...
			endif not .CalledFromThisClass()
		
		* Update the TooltipText.
		
			try
				.txtFile.TooltipText = displaypath(lcDirectory, 127)
			catch
			endtry
		
		* Fire the AnyChange hook method if the value changed.
		
			if llChanged
				.AnyChange()
			endif llChanged
		endwith
		
	ENDPROC

	PROCEDURE clabelcaption_assign
		lparameters tuNewValue
		This.cLabelCaption = tuNewValue
		This.AdjustControls(.T.)
		
	ENDPROC

	PROCEDURE LostFocus
		* If the LostFocus method is fired because the user clicked on a button with
		* the Cancel property set to .T. or if the button has an lCancel property
		* (which is part of the SFCommandButton base class) and it's .T., or if we're
		* closing the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation.
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE Refresh
		* If necessary, write the ControlSource's value to our cDirectory property.
		
		local lcDirectory
		with This
			if not empty(.cControlSource)
				lcDirectory = evaluate(.cControlSource)
				if not .cDirectory == lcDirectory
					.cDirectory = lcDirectory
				endif not .cDirectory == lcDirectory
			endif not empty(.cControlSource)
		endwith
		
	ENDPROC

	PROCEDURE validation		&& Allows validation
		* Abstract method
		
	ENDPROC

	PROCEDURE value_access
		return This.cDirectory
		
	ENDPROC

	PROCEDURE value_assign
		lparameters tuNewValue
		This.cDirectory = tuNewValue
		
	ENDPROC

	PROCEDURE cmdGetFile.Click
		with This
			.cCaption    = .Parent.cCaption
			.cText       = .Parent.cText
			.cDefaultDir = '[' + .Parent.cDirectory + ']'
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE cmdGetFile.Init
		This.cDefaultDir = '=' + This.cResult
		dodefault()
		
	ENDPROC

	PROCEDURE txtFile.anychange
		* If we're not being called from cDirectory_Assign, update the cDirectory
		* property.
		
		if not 'CDIRECTORY_ASSIGN' $ program(program(-1) - 2)
			This.Parent.cDirectory = This.Value
		endif not 'CDIRECTORY_ASSIGN' $ program(program(-1) - 2)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerdirectoryvertical AS projectexplorerdirectory OF "projectexplorerfilectrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	Height = 43
	ladjustpositions = .F.
	Name = "projectexplorerdirectoryvertical"
	Width = 288
	CMDGETFILE.Left = 265
	CMDGETFILE.Name = "CMDGETFILE"
	CMDGETFILE.Top = 20
	LBLFILE.Name = "LBLFILE"
	TXTFILE.Left = 0
	TXTFILE.Name = "TXTFILE"
	TXTFILE.Top = 20

ENDDEFINE

DEFINE CLASS projectexplorerfile AS projectexplorercontainer OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGetFile" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Fired when the value of cFileName changes
		*m: cfilename_access
		*m: cfilename_assign
		*m: filechanged		&& Fired when the filename is changed interactively
		*m: validation		&& Allows validation
		*m: value_access
		*m: value_assign
		*m: width_assign
		*p: ccaption		&& The value for cmdGetFile.cCaption
		*p: ccontrolsource		&& The item this control's value is bound to
		*p: cextensions		&& The value for cmdGetFile.cExtensions
		*p: cfilename		&& The filename
		*p: clabelcaption		&& The caption to use for the label
		*p: ladjustpositions		&& .T. if we should adjust the positions of the controls
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lvalidfilename		&& .T. if we have a valid file name
		*p: value		&& The value of the control
	*</DefinedPropArrayMethod>

	Anchor = 10
	builder = \Development\Tools\SFFramework\Builders\SFBuilders.vcx,SFFileBuilder
	ccaption = 		&& The value for cmdGetFile.cCaption
	ccontrolsource = 		&& The item this control's value is bound to
	cextensions = 		&& The value for cmdGetFile.cExtensions
	cfilename = 		&& The filename
	clabelcaption = 		&& The caption to use for the label
	Height = 23
	ladjustpositions = .T.		&& .T. if we should adjust the positions of the controls
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lvalidfilename = .T.		&& .T. if we have a valid file name
	Name = "projectexplorerfile"
	value = 		&& The value of the control
	Width = 343
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
		<memberdata name="ccontrolsource" type="property" display="cControlSource" favorites="True"/>
		<memberdata name="cextensions" type="property" display="cExtensions" favorites="True"/>
		<memberdata name="cfilename" type="property" display="cFileName"/>
		<memberdata name="cfilename_access" type="method" display="cFileName_Access"/>
		<memberdata name="cfilename_assign" type="method" display="cFileName_Assign"/>
		<memberdata name="ladjustpositions" type="property" display="lAdjustPositions" favorites="True"/>
		<memberdata name="lvalidfilename" type="property" display="lValidFileName"/>
		<memberdata name="validation" type="method" display="Validation"/>
		<memberdata name="width_assign" type="method" display="Width_Assign"/>
		<memberdata name="clabelcaption" type="property" display="cLabelCaption"/>
		<memberdata name="value" type="property" display="Value"/>
		<memberdata name="value_access" type="method" display="Value_Access"/>
		<memberdata name="value_assign" type="method" display="Value_Assign"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="filechanged" type="method" display="FileChanged"/>
		</VFPData>

	ADD OBJECT 'cmdGetFile' AS projectexplorergetfile WITH ;
		Anchor = 8, ;
		cafterdone = This.Parent.Validation(), ;
		cdefault = This.Parent.cFileName, ;
		cresult = This.Parent.cFileName, ;
		Left = 320, ;
		Name = "cmdGetFile", ;
		TabStop = .F.
		*< END OBJECT: ClassLib="projectexplorerbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lblFile' AS projectexplorerlabel WITH ;
		Caption = "File", ;
		Name = "lblFile", ;
		Top = 3
		*< END OBJECT: ClassLib="projectexplorerctrls.vcx" BaseClass="label" />

	ADD OBJECT 'txtFile' AS projectexplorertextbox WITH ;
		Anchor = 10, ;
		Left = 30, ;
		MaxLength = 240, ;
		Name = "txtFile", ;
		Width = 290
		*< END OBJECT: ClassLib="projectexplorerctrls.vcx" BaseClass="textbox" />
	
	PROCEDURE anychange		&& Fired when the value of cFileName changes
		* Abstract method
		
	ENDPROC

	PROCEDURE cfilename_access
		return alltrim(This.txtFile.Value)
		
	ENDPROC

	PROCEDURE cfilename_assign
		lparameters tcFileName
		local lcFileName, ;
			lnPos, ;
			lcAlias, ;
			lcField
		with This
			lcFileName = alltrim(tcFileName)
		
		* Update the Value of the textbox if we're not being called from it.
		
			if not 'TXTFILE.ANYCHANGE' $ program(program(-1) - 1) and ;
				not 'TXTFILE.ANYCHANGE' $ program(program(-1) - 2)
				.txtFile.Value = lcFileName
			endif not 'TXTFILE.ANYCHANGE' $ program(program(-1) - 1) ...
		
		* Write the value to our ControlSource.
		
			if not .CalledFromThisClass() or ;
				'SFGETFILE.CLICK' $ program(program(-1) - 2)
				lnPos = at('.', .cControlSource)
				if lnPos > 0 and not lcFileName == alltrim(evaluate(.cControlSource))
					lcAlias = left(.cControlSource, lnPos - 1)
					lcField = substr(.cControlSource, lnPos + 1)
					if used(lcAlias)
						replace (lcField) with lcFileName in (lcAlias)
					else
						store lcFileName to (.cControlSource)
					endif used(lcAlias)
					raiseevent(This, 'FileChanged')
				endif lnPos > 0 ...
			endif not .CalledFromThisClass() ...
		
		* Update the TooltipText.
		
			try
				.txtFile.TooltipText = displaypath(lcFileName, 127)
			catch
			endtry
		
		* Fire the AnyChange hook method (backward compatibility only).
		
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE filechanged		&& Fired when the filename is changed interactively
		* Abstract method
		
	ENDPROC

	PROCEDURE Init
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
		if This.lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
			pemstatus(Thisform, 'AnyChange', 5)
			bindevent(This, 'FileChanged', Thisform, 'AnyChange')
		endif This.lBindToFormAnyChange ...
		
	ENDPROC

	PROCEDURE LostFocus
		if not This.lValidFileName
			This.txtFile.SetFocus()
		endif not This.lValidFileName
		
	ENDPROC

	PROCEDURE Refresh
		with This
		
		* Adjust the control position to account for the size of the caption.
		
			if not empty(.cLabelCaption) and not .lblFile.Caption == .cLabelCaption
				.lblFile.Caption  = .cLabelCaption
				.lblFile.AutoSize = .T.
				if .lAdjustPositions
					.txtFile.Left    = .lblFile.Width + 5
					.txtFile.Width   = .Width - .txtFile.Left - .cmdGetFile.Width
					.cmdGetFile.Left = .txtFile.Left + .txtFile.Width
				endif .lAdjustPositions
			endif not empty(.cLabelCaption) ...
		
		* If necessary, write the ControlSource's value to our cFileName property.
		
			if not empty(.cControlSource)
				.cFileName = evaluate(.cControlSource)
			endif not empty(.cControlSource)
		endwith
		
	ENDPROC

	PROCEDURE validation		&& Allows validation
		* Abstract method
		
	ENDPROC

	PROCEDURE value_access
		return This.cFileName
		
	ENDPROC

	PROCEDURE value_assign
		lparameters tuNewValue
		This.cFileName = tuNewValue
		
	ENDPROC

	PROCEDURE width_assign
		* Adjust the width of the textbox and position of the commandbutton when the
		* width changes.
		
		lparameters tnValue
		This.Width = tnValue
		* This is a workaround for a VFP bug that fires the Assign method when the
		* width is accessed
		if type('This.cmdGetFile.Name') = 'C'
			This.cmdGetFile.Left = tnValue - This.cmdGetFile.Width
			This.txtFile.Width   = tnValue - This.txtFile.Left - This.cmdGetFile.Width
		endif type('This.cmdGetFile.Name') = 'C'
		
	ENDPROC

	PROCEDURE cmdGetFile.Click
		local lcFileName
		with This
			.cCaption    = .Parent.cCaption
			.cExtensions = .Parent.cExtensions
			lcFileName   = .Parent.cFileName
			dodefault()
			if not lcFileName == .Parent.cFileName
				raiseevent(This.Parent, 'FileChanged')
			endif not lcFileName == .Parent.cFileName
		endwith
		
	ENDPROC

	PROCEDURE txtFile.anychange
		* If we're not being called from cFileName_Assign, update the cFileName
		* property.
		
		if not 'CFILENAME_ASSIGN' $ program(program(-1) - 2)
			This.Parent.cFileName = This.Value
		endif not 'CFILENAME_ASSIGN' $ program(program(-1) - 2)
		
	ENDPROC

	PROCEDURE txtFile.InteractiveChange
		local lnStart, ;
			lnLength
		lnStart  = This.SelStart
		lnLength = This.SelLength
		dodefault()
		raiseevent(This.Parent, 'FileChanged')
		This.SelStart  = lnStart
		This.SelLength = lnLength
		
	ENDPROC

	PROCEDURE txtFile.validation
		local loObject
		loObject = sys(1270)
		if vartype(loObject) = 'O' and ;
			((type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0) or ;
			upper(loObject.Name) = 'CMDGETFILE')
			return .T.
		else
			return This.Parent.Validation() and This.Parent.lValidFileName
		endif vartype(loObject) = 'O' ...
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerfilevertical AS projectexplorerfile OF "projectexplorerfilectrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	Height = 43
	ladjustpositions = .F.
	Name = "projectexplorerfilevertical"
	Width = 313
	CMDGETFILE.Left = 290
	CMDGETFILE.Name = "CMDGETFILE"
	CMDGETFILE.Top = 20
	LBLFILE.Name = "LBLFILE"
	TXTFILE.Left = 0
	TXTFILE.Name = "TXTFILE"
	TXTFILE.Top = 20

ENDDEFINE
