*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="projectexplorerexplorer.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS projectexplorerexplorerform AS projectexplorerform OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oSplitter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oPersist" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addmenutoform		&& Adds a menu to the form
		*m: adjustcontrols		&& Does any last-minute adjustment of controls
		*m: displayproperties		&& Displays the properties for the selected item
		*m: hideprogressbar		&& Hides the progress bar
		*m: restoreformsize		&& Restores the form size and position
		*m: saveformsize		&& Saves the form size and position
		*m: setupstatusbar		&& Sets up the properties of the status bar
		*m: statusbarclick		&& Fired when the user clicks the status bar
		*m: updatemessagepanel		&& Updates the text in the message panel
		*m: updateprogressbar		&& Updates the value of the progress bar
		*m: updatestatepanel		&& Updates the "state" panel of the status bar
		*p: ccurrentnodeid		&& The ID of the currently selected node
		*p: ccurrentnodekey		&& The key of the currently selected node
		*p: ccurrentnodetype		&& The type of the currently selected node
		*p: cdefaultstatemessage		&& The default message for the state panel of the status bar
		*p: cgobackicon		&& The icon to use for the Go Back panel
		*p: cregistrykey		&& The Registry key used for persisting settings
		*p: cstateiconbusy		&& The image to use when something other than the default message is displayed in the state panel
		*p: cstateiconready		&& The image to use when the default message is displayed in the state panel
		*p: cstatepanelname		&& The name of the state panel
		*p: ctoolbarclass		&& The class to use for a toolbar
		*p: ctoolbarlibrary		&& The library containing the class specified in cToolbarClass
		*p: ladjustmentsdone		&& .T. once all adjustments are done
		*p: lforceredraw		&& .T. to use DOEVENTS FORCE when updating control panel
		*p: lstatepanelautosize		&& .T. to auto-size the state panel
		*p: lstatusbar		&& .T. to display a status bar
		*p: luseformfont		&& .T. for all objects to use the same font as the form
		*p: nheightadjust		&& The height the form is reduced by when a toolbar is docked
		*p: nsplitterleft		&& The starting position for the splitter control
		*p: nstatepanelwidth		&& The width of the state panel if lStatePanelAutoSize is .F.
		*p: omenu		&& A reference to a ProjectExplorerMenu object
		*p: otoolbar		&& A reference to a toolbar
	*</DefinedPropArrayMethod>

	ccurrentnodeid = 		&& The ID of the currently selected node
	ccurrentnodekey = 		&& The key of the currently selected node
	ccurrentnodetype = 		&& The type of the currently selected node
	cdefaultstatemessage = Ready		&& The default message for the state panel of the status bar
	cgobackicon = Back.ico		&& The icon to use for the Go Back panel
	cregistrykey = 		&& The Registry key used for persisting settings
	cstateiconbusy = Red2.ico		&& The image to use when something other than the default message is displayed in the state panel
	cstateiconready = Green2.ico		&& The image to use when the default message is displayed in the state panel
	cstatepanelname = StatePanel		&& The name of the state panel
	ctoolbarclass = 		&& The class to use for a toolbar
	ctoolbarlibrary = 		&& The library containing the class specified in cToolbarClass
	DataSession = 2
	DoCreate = .T.
	Height = 304
	ladjustmentsdone = .F.		&& .T. once all adjustments are done
	lforceredraw = .T.		&& .T. to use DOEVENTS FORCE when updating control panel
	lstatepanelautosize = .F.		&& .T. to auto-size the state panel
	lstatusbar = .F.		&& .T. to display a status bar
	luseformfont = .T.		&& .T. for all objects to use the same font as the form
	MinHeight = 300
	MinWidth = 600
	Name = "projectexplorerexplorerform"
	nborderstyle = 3
	nheightadjust = 0		&& The height the form is reduced by when a toolbar is docked
	nsplitterleft = 0		&& The starting position for the splitter control
	nstatepanelwidth = 200		&& The width of the state panel if lStatePanelAutoSize is .F.
	omenu = .NULL.		&& A reference to a ProjectExplorerMenu object
	otoolbar = .NULL.		&& A reference to a toolbar
	Width = 680
	_memberdata = <VFPData>
		<memberdata name="cregistrykey" type="property" display="cRegistryKey"/>
		<memberdata name="ctoolbarclass" type="property" display="cToolbarClass"/>
		<memberdata name="ctoolbarlibrary" type="property" display="cToolbarLibrary"/>
		<memberdata name="nsplitterleft" type="property" display="nSplitterLeft"/>
		<memberdata name="otoolbar" type="property" display="oToolbar"/>
		<memberdata name="updatestatepanel" type="method" display="UpdateStatePanel"/>
		<memberdata name="updateprogressbar" type="method" display="UpdateProgressBar"/>
		<memberdata name="nstatepanelwidth" type="property" display="nStatePanelWidth"/>
		<memberdata name="lstatepanelautosize" type="property" display="lStatePanelAutoSize"/>
		<memberdata name="cstatepanelname" type="property" display="cStatePanelName"/>
		<memberdata name="hideprogressbar" type="method" display="HideProgressBar"/>
		<memberdata name="setupstatusbar" type="method" display="SetupStatusBar"/>
		<memberdata name="restoreformsize" type="method" display="RestoreFormSize"/>
		<memberdata name="updatemessagepanel" type="method" display="UpdateMessagePanel"/>
		<memberdata name="saveformsize" type="method" display="SaveFormSize"/>
		<memberdata name="cdefaultstatemessage" type="property" display="cDefaultStateMessage"/>
		<memberdata name="displayproperties" type="method" display="DisplayProperties"/>
		<memberdata name="ccurrentnodeid" type="property" display="cCurrentNodeID"/>
		<memberdata name="ccurrentnodekey" type="property" display="cCurrentNodeKey"/>
		<memberdata name="ccurrentnodetype" type="property" display="cCurrentNodeType"/>
		<memberdata name="cstateiconready" type="property" display="cStateIconReady"/>
		<memberdata name="cstateiconbusy" type="property" display="cStateIconBusy"/>
		<memberdata name="statusbarclick" type="method" display="StatusBarClick"/>
		<memberdata name="cgobackicon" type="property" display="cGoBackIcon"/>
		<memberdata name="luseformfont" type="property" display="lUseFormFont"/>
		<memberdata name="addmenutoform" display="AddMenuToForm"/>
		<memberdata name="adjustcontrols" display="AdjustControls"/>
		<memberdata name="ladjustmentsdone" display="lAdjustmentsDone"/>
		<memberdata name="nheightadjust" display="nHeightAdjust"/>
		<memberdata name="lforceredraw" display="lForceRedraw"/>
		<memberdata name="lstatusbar" display="lStatusBar"/>
		<memberdata name="omenu" display="oMenu"/>
		</VFPData>

	ADD OBJECT 'oPersist' AS projectexplorerpersistentform WITH ;
		Left = 0, ;
		lrestoreoninit = .F., ;
		lsaveondestroy = .F., ;
		Name = "oPersist", ;
		Top = 0
		*< END OBJECT: ClassLib="projectexplorerpersist.vcx" BaseClass="custom" />

	ADD OBJECT 'oSplitter' AS projectexplorersplitterh WITH ;
		Height = 295, ;
		Left = 220, ;
		Name = "oSplitter", ;
		nobject1minsize = 200, ;
		nobject2minsize = 300, ;
		Top = 10
		*< END OBJECT: ClassLib="projectexplorersplitter.vcx" BaseClass="container" />
	
	PROCEDURE about
		* Subclassing notes:
		*
		* - Add controls to the left and right of the splitter, adjusting the
		*   position and height of the splitter so it's right between them.
		*
		* - Set the following properties of oSplitter: cObject1Name,
		*   cObject1Name, nObject1MinSize, and nObject2MinSize.
		*
		* - Set cRegistryKey to the Registry key used to save and restore the size and
		*   position of this form.
		*
		* - Set cToolbarClass and cToolbarLibrary to the class and library for a
		*   toolbar if one is wanted.
		*
		* - Set lStatePanelAutoSize to .T. if the state panel (the rightmost one)
		*   should automatically size itself.
		*
		* - Set nStatePanelWidth to the desired width of the state panel if
		*   lStatePanelAutoSize is .F.
		*
		* - Set cGoBackIcon, cStateIconBusy, and cStateIconReady to the icons to use
		*   for the Go Back button and the state panel when the state is busy and ready
		*
		* - Set Caption and Icon as desired.
		
	ENDPROC

	PROCEDURE Activate
		* Create a toolbar if necessary. Because the toolbar takes up some of the form
		* height, ensure that the form is no smaller than the minimum height by setting
		* MinHeight to itself.
		
		local lnHeight
		with This
			if not empty(.cToolbarClass) and vartype(.oToolbar) <> 'O'
				lnHeight = .Height
				.oToolbar = newobject(.cToolbarClass, 	;
					fullpath(.cToolbarLibrary, .ClassLibrary))
				.oToolbar.Dock(TOOL_TOP)
				.oToolbar.Show()
				.MinHeight     = .MinHeight
				.nHeightAdjust = lnHeight - .Height
			endif not empty(.cToolbarClass) ...
		
		* Do any last-minute adjustments needed.
		
			if not .lAdjustmentsDone
				.AdjustControls()
				.lAdjustmentsDone = .T.
			endif not This.lAdjustmentsDone
		endwith
		
	ENDPROC

	PROCEDURE addmenutoform		&& Adds a menu to the form
		* Abstract method.
		
	ENDPROC

	PROCEDURE adjustcontrols		&& Does any last-minute adjustment of controls
		* Abstract method
		
	ENDPROC

	PROCEDURE afterrefresh
		* If we have a toolbar, refresh it.
		
		if vartype(This.oToolbar) = 'O'
			This.oToolbar.RefreshForm()
		endif vartype(This.oToolbar) = 'O'
		
	ENDPROC

	PROCEDURE displayproperties		&& Displays the properties for the selected item
		* Abstract method.
		
		lparameters tnPage
		
	ENDPROC

	PROCEDURE hideprogressbar		&& Hides the progress bar
		* Hides the progress bar.
		
		if This.lStatusBar
			This.oStatus.ProgressBar.ctlVisible = .F.
		endif This.lStatusBar
		
	ENDPROC

	PROCEDURE Init
		* Set up the status bar.
		
		This.SetupStatusBar()
		dodefault()
		
	ENDPROC

	PROCEDURE releasemembers
		* Save the form size and position and nuke the menu and toolbar if they exist.
		
		if vartype(This.oMenu) = 'O'
			This.oMenu.Release()
		endif vartype(This.oMenu) = 'O'
		if vartype(This.oToolbar) = 'O'
			This.oToolbar.Release()
		endif vartype(This.oToolbar) = 'O'
		This.SaveFormSize()
		
	ENDPROC

	PROCEDURE Resize
		* Because of the menu, it's possible to resize the form shorter than MinHeight,
		* so let's prevent that here.
		
		if This.Height < This.MinHeight
			This.Height = This.MinHeight
		endif This.Height < This.MinHeight
		
	ENDPROC

	PROCEDURE restoreformsize		&& Restores the form size and position
		* Restores the form size and position.
		
		with This
			.nSplitterLeft = .oSplitter.Left
			if not empty(.cRegistryKey)
				if empty(.oPersist.cKey)
					.oPersist.cKey = .cRegistryKey
				endif empty(.oPersist.cKey)
				.oPersist.Restore()
			endif not empty(.cRegistryKey)
		endwith
		
	ENDPROC

	PROCEDURE saveformsize		&& Saves the form size and position
		* Saves the form size and position. Adjust the form's height by nHeightAdjust,
		* which is how much space a docked toolbar reduced the form height by.
		
		with This
			.Height = .Height + .nHeightAdjust
			.nSplitterLeft = .oSplitter.Left
			if not empty(.cRegistryKey)
				.oPersist.Save()
			endif not empty(.cRegistryKey)
		endwith
		
	ENDPROC

	PROCEDURE setupstatusbar		&& Sets up the properties of the status bar
		* If we're supposed to have a status bar, add one and set the properties of the
		* status bar panels.
		
		local lcLibrary
		if This.lStatusBar
			lcLibrary = fullpath('ctl32.vcx', This.ClassLibrary)
			This.NewObject('oStatus', 'ctl32_StatusBar', lcLibrary)
			with This.oStatus
		
		* Create a panel for a Go Back icon.
		
				with .ctlPanels(.ctlPanelCount - 1)
					.ctlName        = 'Back'
					.ctlWidth       = 30
					.ctlIcon        = This.cGoBackIcon
					.ctlToolTipText = 'Go back'
				endwith
		
		* Create a state panel.	
		
				with .ctlPanels(.ctlPanelCount)
					.ctlName      = This.cStatePanelName
					.ctlAlignment = 1 && right
					.ctlAutoSize  = This.lStatePanelAutoSize
					.ctlWidth     = This.nStatePanelWidth
				endwith
		
		* Turn off other panels.
		
				.PanelOvr.ctlVisible  = .F.
				.PanelCaps.ctlVisible = .F.
				.PanelNum.ctlVisible  = .F.
				.PanelDate.ctlVisible = .F.
			endwith
		
		* Bind to the ctlClick event of the status bar.
		
			bindevent(This.oStatus, 'ctlClick', This, 'StatusBarClick')
		endif This.lStatusBar
		
	ENDPROC

	PROCEDURE Show
		lparameters tnStyle
		with This
		
		* Do the default behavior.
		
			dodefault(tnStyle)
		
		* Restore the form height and position.
		
			.RestoreFormSize()
		
		* Move the splitter to its former position. Note that we do this here rather
		* than in RestoreFormSize because that method may be overridden.
		
			.oSplitter.MoveSplitterToPosition(.nSplitterLeft)
		
		* Add a menu to the form (AddMenuToForm is abstract in this class but can be
		* implemented in a subclass).
		
			.AddMenuToForm()
		
		* If all objects are supposed to use the same font as the form, do so.
		
			if .lUseFormFont
				.SetAll('FontName', .FontName)
			endif .lUseFormFont
		
		* Display the default message in the status bar.
		
			.UpdateStatePanel()
		endwith
		
	ENDPROC

	PROCEDURE statusbarclick		&& Fired when the user clicks the status bar
		* Abstract method
		
	ENDPROC

	PROCEDURE updatemessagepanel		&& Updates the text in the message panel
		* Updates the message in the message panel and returns the former message.
		
		lparameters tcMessage
		local lcText
		with This
			if .lStatusBar
				lcText = .oStatus.ctlMessage
				if not lcText == tcMessage
					.oStatus.ctlMessage = tcMessage
				endif not lcText == tcMessage
			endif .lStatusBar
		endwith
		return lcText
		
	ENDPROC

	PROCEDURE updateprogressbar		&& Updates the value of the progress bar
		* Ensures the progress bar is visible and updates its value.
		
		lparameters tnValue
		do case
			case not This.lStatusBar
			case tnValue = 0
				This.HideProgressBar()
			otherwise
				with This.oStatus.ProgressBar
					if not .ctlVisible
						.ctlVisible = .T.
					endif not .ctlVisible
					.ctlValue = tnValue
				endwith
		endcase
		doevents
		
	ENDPROC

	PROCEDURE updatestatepanel		&& Updates the "state" panel of the status bar
		* Updates the message in the state panel (another panel name can also be
		* passed to update that panel) and returns the former message.
		
		lparameters tcMessage, ;
			tcPanel
		local lcPanel, ;
			loPanel, ;
			lcText, ;
			lcMessage
		with This
			lcPanel = iif(vartype(tcPanel) = 'C' and not empty(tcPanel), tcPanel, ;
				.cStatePanelName)
			if type('.oStatus.' + lcPanel + '.Name') = 'C'
		
		* Get a reference to the panel and the current text so we can return it.
		
				loPanel = .oStatus.&lcPanel
				lcText  = loPanel.ctlCaption
		
		* If the message wasn't specified, use the default message.
		
				lcMessage = iif(vartype(tcMessage) = 'C' and (not empty(tcMessage) or ;
					lcPanel <> .cStatePanelName), tcMessage, .cDefaultStateMessage)
		
		* If the message is different than the current text, use the message.
		
				if not lcText == lcMessage
					loPanel.ctlCaption = lcMessage
		
		* Display the appropriate image.
		
					do case
						case lcPanel <> .cStatePanelName
						case lcMessage = .cDefaultStateMessage and ;
							not empty(.cStateIconReady)
							loPanel.ctlIcon = .cStateIconReady
						case lcMessage <> .cDefaultStateMessage and ;
							not empty(.cStateIconBusy)
							loPanel.ctlIcon = .cStateIconBusy
					endcase
				endif not lcText == lcMessage
		
		* Force the refresh if we're supposed to.
		
				if .lForceRedraw
					doevents force
				endif .lForceRedraw
			endif type('.oStatus.' + lcPanel + '.Name') = 'C'
		endwith
		return lcText
		
	ENDPROC

	PROCEDURE oPersist.defineitems
		* Tell the persistence object that it's supposed to save and restore the value
		* of the nSplitterLeft property.
		
		dodefault()
		This.AddItem('SplitterPosition', 'Thisform.nSplitterLeft')
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerexplorerformtreeview AS projectexplorerexplorerform OF "projectexplorerexplorer.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oTreeViewContainer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProperties" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: goback		&& Goes back to a previously selected node
		*p: lloadtreeviewatstartup		&& .T. to load the TreeView in Show
		*p: ocurrenttreeviewcontainer		&& A reference to the current TreeViewContainer object
	*</DefinedPropArrayMethod>

	DoCreate = .T.
	lloadtreeviewatstartup = .T.		&& .T. to load the TreeView in Show
	Name = "projectexplorerexplorerformtreeview"
	ocurrenttreeviewcontainer = .NULL.		&& A reference to the current TreeViewContainer object
	_memberdata = <VFPData>
		<memberdata name="goback" display="GoBack"/>
		<memberdata name="lloadtreeviewatstartup" display="lLoadTreeviewAtStartup"/>
		<memberdata name="ocurrenttreeviewcontainer" display="oCurrentTreeViewContainer"/>
		</VFPData>
	oSplitter.cobject1name = oTreeViewContainer
	oSplitter.cobject2name = pgfProperties
	oSplitter.Height = 308
	oSplitter.Left = 210
	oSplitter.Name = "oSplitter"
	oSplitter.Top = 0
	oPersist.Name = "oPersist"

	ADD OBJECT 'oTreeViewContainer' AS projectexplorertreeviewexplorer WITH ;
		Height = 308, ;
		Left = -1, ;
		lloadtreeviewatstartup = .F., ;
		Name = "oTreeViewContainer", ;
		Top = -1, ;
		Width = 211, ;
		oTree.Height = 314, ;
		oTree.Name = "oTree", ;
		oTree.Width = 210, ;
		oImageList.Left = 160, ;
		oImageList.Name = "oImageList", ;
		oImageList.Top = 0, ;
		tmrSync.Name = "tmrSync", ;
		oStack.Name = "oStack", ;
		tmrReload.Name = "tmrReload"
		*< END OBJECT: ClassLib="projectexplorerexplorer.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProperties' AS projectexplorerpageframe WITH ;
		Anchor = 13, ;
		ErasePage = .T., ;
		Height = 309, ;
		Left = 220, ;
		luseformshortcutmenu = .T., ;
		Name = "pgfProperties", ;
		TabIndex = 2, ;
		Tabs = .F., ;
		Top = -1, ;
		Width = 463, ;
		projectexplorerpage1.Name = "projectexplorerpage1"
		*< END OBJECT: ClassLib="projectexplorerctrls.vcx" BaseClass="pageframe" />
	
	PROCEDURE about
		* Subclassing notes:
		*
		* - Set pgfProperties.PageCount to the desired number of pages and add controls
		*   to each page. These will likely be containers of controls (you can use
		*   ProjectExplorerPropertiesContainer if desired but not required).
		*
		* Subclassing notes from This.Parent:
		*
		* - Set cRegistryKey to the Registry key used to save and restore the size and
		*   position of this form.
		*
		* - Set cToolbarClass and cToolbarLibrary to the class and library for a
		*   toolbar if one is wanted.
		*
		* - Set lStatePanelAutoSize to .T. if the state panel (the rightmost one)
		*   should automatically size itself.
		*
		* - Set nStatePanelWidth to the desired width of the state panel if
		*   lStatePanelAutoSize is .F.
		*
		* - Set Caption and Icon as desired.
		*
		* Subclassing notes from ProjectExplorerTreeViewCursor:
		*
		* - Fill in the LoadImages and FillTreeViewCursor methods of
		*   oTreeViewContainer. See the comments in those methods in
		*	ProjectExplorerTreeViewCursor for sample code.
		*
		* - Set lSortRootNodes as desired.
		*
		* - Set lAllowRename to .T. to always allow renaming the selected node (the
		*   default is .F.). You could also put code into the Refresh method of
		*   container objects on the appropriate page of the pageframe that sets
		*   lAllowRename to .T. if the selected node can be renamed. You'll need to add
		*   code to TreeAfterLabelEdit to rename the record in the source data.
		*
		* - Set lAllowDelete to .T. to always allow deleting the selected node (the
		*   default is .F.). You could also put code into the Refresh method of
		*   container objects on the appropriate page of the pageframe that sets
		*   lAllowDelete to .T. if the selected node can be deleted. (In that case,
		*   you could have a menu item or command button to delete the selected node
		*   with it conditionally being enabled based on lAllowDelete.) You'll need to
		*   add code to DeleteNode to remove the record from the source data and have
		*   it call RemoveNode to remove the node from the TreeView. You can also call
		*   This.oTree.Nodes.Remove(KeyValue) to remove other nodes (not child nodes,
		*   since those are automatically removed) if necessary.
		*
		* - Set lAllowInsert as .T. to allow the user to add nodes (the default is
		*   .F.). In that case, fill in InsertNode with the necessary code.
		*
		* - Fill in cRegistryKeySuffix with the subnode of the Registry key for the
		*   form if you want to use a subnode. Otherwise, leave it blank to store the
		*   settings for the TreeView in the form's Registry key.
		
	ENDPROC

	PROCEDURE adjustcontrols
		* If we're in a top-level form, adjust the TreeView and pageframe heights. The
		* reason is because the statusbar adds a dummy bottom-docked toolbar and then
		* takes over that place for itself, so the space at the bottom of the form for
		* the statusbar is unused empty space.
		
		local lnAnchor
		with This
			if .ShowWindow = 2 and .lStatusBar
				lnAnchor                   = .oTreeViewContainer.Anchor
				.oTreeViewContainer.Anchor = 0
				.oTreeViewContainer.Height = .Height + 2
				.oTreeViewContainer.Anchor = lnAnchor
				lnAnchor                   = .pgfProperties.Anchor
				.pgfProperties.Anchor      = 0
				.pgfProperties.Height      = .Height + 2
				.pgfProperties.Anchor      = lnAnchor
			endif .ShowWindow = 2 ...
		
		* If we have a menu, adjust the TreeView and pageframe heights. The
		* reason is because the menu takes up some space at the top of the form and the
		* form height is automatically adjusted accordingly but these controls aren't
		* so they're too tall.
		
		*** For some reason, this code doesn't seem to be needed anymore.
		*	if vartype(.oMenu) = 'O'
		*		lnAnchor                   = .pgfProperties.Anchor
		*		.pgfProperties.Anchor      = 0
		*		.pgfProperties.Height      = .pgfProperties.Height - sysmetric(20)
		*		.pgfProperties.Anchor      = lnAnchor
		*		lnAnchor                   = .oTreeViewContainer.Anchor
		*		.oTreeViewContainer.Anchor = 0
		*		.oTreeViewContainer.Height = .oTreeViewContainer.Height - sysmetric(20)
		*		.oTreeViewContainer.Anchor = lnAnchor
		*		lnAnchor                   = .oSplitter.Anchor
		*		.oSplitter.Anchor          = 0
		*		.oSplitter.Height          = .oSplitter.Height - sysmetric(20)
		*		.oSplitter.Anchor          = lnAnchor
		*	endif vartype(.oMenu) = 'O'
		
		* This seems goofy but due to when restoring of form size is done, if we don't
		* use it, the TreeView isn't drawn properly until the user clicks it.
		
			.Height = .Height + 1
			.Height = .Height - 1
		endwith
		
	ENDPROC

	PROCEDURE displayproperties
		* Display information about the selected item by selecting the specified page
		* in the properties pageframe and refreshing it.
		
		lparameters tnPage
		with This
			if between(tnPage, 1, .pgfProperties.PageCount)
				.pgfProperties.ActivePage = tnPage
				.pgfProperties.Pages(tnPage).Refresh()
			endif between(tnPage, 1, .pgfProperties.PageCount)
		endwith
		
	ENDPROC

	PROCEDURE goback		&& Goes back to a previously selected node
		*==============================================================================
		* Method:			GoBack
		* Status:			Public
		* Purpose:			Goes back to a previously selected node
		* Author:			Doug Hennig
		* Last Revision:	04/19/2018
		* Parameters:		tcKey - the key of the node to go back to (optional: if it
		*						isn't passed, the most recent node is used)
		* Returns:			.T.
		* Environment in:	see This.oTreeViewContainer.GoBack
		* Environment out:	see This.oTreeViewContainer.GoBack
		*==============================================================================
		
		lparameters tcKey
		This.oCurrentTreeViewContainer.GoBack(tcKey)
		
	ENDPROC

	PROCEDURE Init
		* Save a reference to the TreeViewContainer (we may have more than one in a
		* subclass).
		
		This.oCurrentTreeViewContainer = This.oTreeViewContainer
		dodefault()
		
	ENDPROC

	PROCEDURE releasemembers
		* Nuke the reference to the TreeViewContainer.
		
		This.oCurrentTreeViewContainer = This.oTreeViewContainer
		dodefault()
		
	ENDPROC

	PROCEDURE restoreformsize
		* Because the form isn't visible when its size is restored, we have to manually
		* set the sizes of the controls.
		
		local lnHeight, ;
			lnWidth, ;
			lnAnchor
		with This
			lnHeight = .Height
			lnWidth  = .Width
			dodefault()
			if not .Visible
				lnAnchor              = .pgfProperties.Anchor
				.pgfProperties.Anchor = 0
				.pgfProperties.Width  = .pgfProperties.Width  + .Width  - lnWidth
				.pgfProperties.Height = .pgfProperties.Height + .Height - lnHeight
				.pgfProperties.Anchor = lnAnchor
				lnAnchor              = .oTreeViewContainer.Anchor
				.oTreeViewContainer.Anchor = 0
				.oTreeViewContainer.Width  = .oTreeViewContainer.Width  + .Width  - lnWidth
				.oTreeViewContainer.Height = .oTreeViewContainer.Height + .Height - lnHeight
				.oTreeViewContainer.Anchor = lnAnchor
				lnAnchor              = .oSplitter.Anchor
				.oSplitter.Anchor = 0
				.oSplitter.Height = .oSplitter.Height + .Height - lnHeight
				.oSplitter.Anchor = lnAnchor
			endif not .Visible
		endwith
		
	ENDPROC

	PROCEDURE Show
		* Load the TreeView if it hasn't already been.
		
		lparameters tnStyle
		dodefault(tnStyle)
		if not This.oCurrentTreeViewContainer.lLoadTreeviewAtStartup and This.lLoadTreeviewAtStartup
			This.oCurrentTreeViewContainer.LoadTree()
		endif not This.oCurrentTreeViewContainer.lLoadTreeviewAtStartup ...
		
	ENDPROC

	PROCEDURE statusbarclick
		* If the user clicked the Go Back panel, tell the TreeView to go back to the
		* previous node.
		
		local loPanel
		with This
			if .lStatusBar and .oStatus.nPanel > 0
				loPanel = .oStatus.ctlPanels(.oStatus.nPanel)
				if vartype(loPanel) = 'O' and loPanel.ctlName = 'Back'
					.GoBack()
				endif vartype(loPanel) = 'O' ...
			endif .lStatusBar ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerpropertiescontainer AS projectexplorercontainer OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackColor = 255,255,255
	BackStyle = 1
	Height = 250
	Name = "projectexplorerpropertiescontainer"
	Width = 440

ENDDEFINE

DEFINE CLASS projectexplorertreeviewcontroller AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addrecordtotreeviewcursor		&& Adds a record to the TreeView cursor
		*m: aftergetchildnodes		&& Fills the passed collection with objects containing properties about the child nodes of the specified node
		*m: aftergetrootnodes		&& Fills the passed collection with objects containing properties about the root nodes
		*m: afterloadnode		&& Loads the specified node into the TreeView
		*m: afterloadtree		&& Loads the TreeView
		*m: beforegetchildnodes		&& Fills the passed collection with objects containing properties about the child nodes of the specified node
		*m: beforegetrootnodes		&& Fills the passed collection with objects containing properties about the root nodes
		*m: beforeloadnode		&& Loads the specified node into the TreeView
		*m: beforeloadtree		&& Loads the TreeView
		*m: canaddnodetocollection		&& Returns .T. if the current record in the cursor can be added to the node collection
		*m: candrop		&& Returns .T. if the specified source can be dropped on the specified node
		*m: canstartdrag		&& Returns .T. if the current node in the TreeView can be dragged
		*m: deletenode		&& Deletes the selected node
		*m: executenode		&& Called when the user presses Enter for a node if lAllowEnter is .T.
		*m: filltreeviewcursor		&& Fills the cursor driving the TreeView with the records to display
		*m: getregistrykey		&& Gets the Registry key to use
		*m: goback		&& Goes back to the previously selected node
		*m: handledragdrop		&& Handles the completion of a DragDrop operation
		*m: loadimages		&& Loads the ImageList control with desired images
		*m: pushkey		&& Pushes the specified key onto the stack
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: treedblclick		&& Fired when the user double-clicks on the TreeView
		*m: treeolecompletedrag		&& Called when an OLECompleteDrag events occurs in the TreeView
		*m: treeolestartdrag		&& Called when an OLEStartDrag event occurs in the TreeView
	*</DefinedPropArrayMethod>

	Name = "projectexplorertreeviewcontroller"
	_memberdata = <VFPData>
		<memberdata name="addrecordtotreeviewcursor" display="AddRecordToTreeViewCursor"/>
		<memberdata name="candrop" display="CanDrop"/>
		<memberdata name="canstartdrag" display="CanStartDrag"/>
		<memberdata name="deletenode" display="DeleteNode"/>
		<memberdata name="executenode" display="ExecuteNode"/>
		<memberdata name="filltreeviewcursor" display="FillTreeViewCursor"/>
		<memberdata name="goback" display="GoBack"/>
		<memberdata name="handledragdrop" display="HandleDragDrop"/>
		<memberdata name="loadimages" display="LoadImages"/>
		<memberdata name="pushkey" display="PushKey"/>
		<memberdata name="shortcutmenu" display="ShortcutMenu"/>
		<memberdata name="treedblclick" display="TreeDblClick"/>
		<memberdata name="treeolecompletedrag" display="TreeOLECompleteDrag"/>
		<memberdata name="treeolestartdrag" display="TreeOLEStartDrag"/>
		<memberdata name="beforegetchildnodes" display="BeforeGetChildNodes"/>
		<memberdata name="aftergetchildnodes" display="AfterGetChildNodes"/>
		<memberdata name="beforegetrootnodes" display="BeforeGetRootNodes"/>
		<memberdata name="aftergetrootnodes" display="AfterGetRootNodes"/>
		<memberdata name="beforeloadnode" display="BeforeLoadNode"/>
		<memberdata name="afterloadnode" display="AfterLoadNode"/>
		<memberdata name="beforeloadtree" display="BeforeLoadTree"/>
		<memberdata name="afterloadtree" display="AfterLoadTree"/>
		<memberdata name="getregistrykey" display="GetRegistryKey"/>
		<memberdata name="canaddnodetocollection" display="CanAddNodeToCollection"/>
		</VFPData>
	
	PROCEDURE addrecordtotreeviewcursor		&& Adds a record to the TreeView cursor
		* Abstract method.
		
		lparameters toTreeViewContainer
		
	ENDPROC

	PROCEDURE aftergetchildnodes		&& Fills the passed collection with objects containing properties about the child nodes of the specified node
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			tcType, ;
			tcID, ;
			toCollection
		
	ENDPROC

	PROCEDURE aftergetrootnodes		&& Fills the passed collection with objects containing properties about the root nodes
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			toCollection
		
	ENDPROC

	PROCEDURE afterloadnode		&& Loads the specified node into the TreeView
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			toNodeItem,	;
			tcParentKey, ;
			toNode
		
	ENDPROC

	PROCEDURE afterloadtree		&& Loads the TreeView
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			tlNoSelect
		
	ENDPROC

	PROCEDURE beforegetchildnodes		&& Fills the passed collection with objects containing properties about the child nodes of the specified node
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			tcType, ;
			tcID, ;
			toCollection
		
	ENDPROC

	PROCEDURE beforegetrootnodes		&& Fills the passed collection with objects containing properties about the root nodes
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			toCollection
		
	ENDPROC

	PROCEDURE beforeloadnode		&& Loads the specified node into the TreeView
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			toNodeItem,	;
			tcParentKey
		
	ENDPROC

	PROCEDURE beforeloadtree		&& Loads the TreeView
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			tlNoSelect
		
	ENDPROC

	PROCEDURE canaddnodetocollection		&& Returns .T. if the current record in the cursor can be added to the node collection
		* Abstract method.
		
	ENDPROC

	PROCEDURE candrop		&& Returns .T. if the specified source can be dropped on the specified node
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			toData, ;
			toNode, ;
			toObject, ;
			tnEffect, ;
			tnButton, ;
			tnShift
		
	ENDPROC

	PROCEDURE canstartdrag		&& Returns .T. if the current node in the TreeView can be dragged
		* Abstract method.
		
		lparameters toTreeViewContainer
		
	ENDPROC

	PROCEDURE deletenode		&& Deletes the selected node
		* Abstract method.
		
		lparameters toTreeViewContainer
		
	ENDPROC

	PROCEDURE executenode		&& Called when the user presses Enter for a node if lAllowEnter is .T.
		* Abstract method.
		
		lparameters toTreeViewContainer
		
	ENDPROC

	PROCEDURE filltreeviewcursor		&& Fills the cursor driving the TreeView with the records to display
		* Abstract method.
		
		lparameters toTreeViewContainer
		
	ENDPROC

	PROCEDURE getregistrykey		&& Gets the Registry key to use
		* Abstract method.
		
		lparameters toTreeViewContainer
		return ''
		
	ENDPROC

	PROCEDURE goback		&& Goes back to the previously selected node
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			tcKey
		
	ENDPROC

	PROCEDURE handledragdrop		&& Handles the completion of a DragDrop operation
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			toData, ;
			toNode, ;
			toObject
		
	ENDPROC

	PROCEDURE loadimages		&& Loads the ImageList control with desired images
		* Abstract method.
		
		lparameters toTreeViewContainer
		
	ENDPROC

	PROCEDURE pushkey		&& Pushes the specified key onto the stack
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			tcKey
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE treedblclick		&& Fired when the user double-clicks on the TreeView
		* Abstract method.
		
		lparameters toTreeViewContainer
		
	ENDPROC

	PROCEDURE treeolecompletedrag		&& Called when an OLECompleteDrag events occurs in the TreeView
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			tnEffect
		
	ENDPROC

	PROCEDURE treeolestartdrag		&& Called when an OLEStartDrag event occurs in the TreeView
		* Abstract method.
		
		lparameters toTreeViewContainer, ;
			toData, ;
			tnAllowedEffects
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorertreeviewexplorer AS projectexplorertreeviewcursor OF "projectexplorertreeview.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ocontroller		&& A reference to a controller object which has behavior used by this control
	*</DefinedPropArrayMethod>

	ccursorstructure = ID C(60), TYPE C(60), PARENTID C(60), PARENTTYPE C(60), TEXT C(60), IMAGE C(20), SELIMAGE C(20), EXPIMAGE C(20), SORTED L, NODEKEY C(60), PAGE N(1)
	lloadtreeviewatstartup = .F.
	luseformshortcutmenu = .T.
	Name = "projectexplorertreeviewexplorer"
	ocontroller = .NULL.		&& A reference to a controller object which has behavior used by this control
	_memberdata = <VFPData>
		<memberdata name="ocontroller" display="oController"/>
		</VFPData>
	oTree.Height = 200
	oTree.Name = "oTree"
	oTree.Width = 210
	oImageList.Left = 160
	oImageList.Name = "oImageList"
	oImageList.Top = 0
	tmrSync.Name = "tmrSync"
	tmrReload.Name = "tmrReload"
	
	PROCEDURE addnodetocollection
		lparameters toCollection
		local llAdd
		
		* If we have a controller, see if we should add the node.
		
		if vartype(This.oController) = 'O'
			llAdd = This.oController.CanAddNodeToCollection(This)
		else
			llAdd = .T.
		endif vartype(This.oController) = 'O'
		
		* Add the node if we're supposed to.
		
		if llAdd
			dodefault(toCollection)
		endif llAdd
		
	ENDPROC

	PROCEDURE addrecordtotreeviewcursor
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			return This.oController.AddRecordToTreeViewCursor(This)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE candrop
		* If we have a controller, have it do the work.
		
		lparameters toData, ;
			toNode, ;
			toObject, ;
			tnEffect, ;
			tnButton, ;
			tnShift
		if vartype(This.oController) = 'O'
			return This.oController.CanDrop(This, toData, toNode, toObject, @tnEffect, ;
				tnButton, tnShift)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE canstartdrag
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			return This.oController.CanStartDrag(This)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE deletenode
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			return This.oController.DeleteNode(This)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke the controller object.
		
		dodefault()
		This.oController = .NULL.
		
	ENDPROC

	PROCEDURE displayrecord
		lparameters tnPage
		local lnPage
		with This
		
		* Get the page we're supposed to display.
		
			do case
				case vartype(tnPage) = 'N'
					lnPage = tnPage
				case not empty(.cCursorAlias) and used(.cCursorAlias)
					lnPage = evaluate(.cCursorAlias + '.PAGE')
				otherwise
					lnPage = 0
			endcase
		
		* Set the node ID, key, and type for the selected item.
		
			Thisform.cCurrentNodeID   = .cCurrentNodeID
			Thisform.cCurrentNodeKey  = .cCurrentNodeKey
			Thisform.cCurrentNodeType = .cCurrentNodeType
		
		* Display the properties for the selected item.
		
			if lnPage <> 0 and .lInitialized
				Thisform.DisplayProperties(lnPage)
			endif lnPage <> 0 ...
		endwith
		
	ENDPROC

	PROCEDURE executenode
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			return This.oController.ExecuteNode(This)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE filltreeviewcursor
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			return This.oController.FillTreeViewCursor(This)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE getchildnodes
		lparameters tcType, ;
			tcID, ;
			toCollection
		
		* If we have a controller, have it do any pre-work.
		
		if vartype(This.oController) = 'O'
			This.oController.BeforeGetChildNodes(This, tcType, tcID, toCollection)
		endif vartype(This.oController) = 'O'
		
		* Do the usual behavior.
		
		dodefault(tcType, tcID, toCollection)
		
		* Allow the controller to do any post-work.
		
		if vartype(This.oController) = 'O'
			This.oController.AfterGetChildNodes(This, tcType, tcID, toCollection)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE getregistrykey
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			return This.oController.GetRegistryKey(This)
		else
			return dodefault()
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE getrootnodes
		lparameters toCollection
		
		* If we have a controller, have it do any pre-work.
		
		if vartype(This.oController) = 'O'
			This.oController.BeforeGetRootNodes(This, toCollection)
		endif vartype(This.oController) = 'O'
		
		* Do the usual behavior.
		
		dodefault(toCollection)
		
		* Allow the controller to do any post-work.
		
		if vartype(This.oController) = 'O'
			This.oController.AfterGetRootNodes(This, toCollection)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE goback
		* If we have a controller, have it do the work.
		
		lparameters tcKey
		if vartype(This.oController) = 'O'
			return This.oController.GoBack(This, tcKey)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE handledragdrop
		* If we have a controller, have it do the work.
		
		lparameters toData, ;
			toNode, ;
			toObject
		if vartype(This.oController) = 'O'
			return This.oController.HandleDragDrop(This, toData, toNode, toObject)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE Init
		lparameters toController, ;
			tcRegistryKey, ;
			tcTag
		do case
		
		* If we're passed a controller, save it.
		
			case vartype(toController) = 'O'
				This.oController = toController
		
		* If we're on a form that has a controller, use it.
		
			case type('Thisform.oTreeViewController.Name') = 'C'
				This.oController = Thisform.oTreeViewController
		endcase
		
		* Save the passed Registry key and tag.
		
		if vartype(tcRegistryKey) = 'C'
			This.cRegistryKey = tcRegistryKey
		endif vartype(tcRegistryKey) = 'C'
		if vartype(tcTag) = 'C'
			This.Tag = tcTag
		endif vartype(tcTag) = 'C'
		
		* Do the usual behavior.
		
		dodefault()
		
	ENDPROC

	PROCEDURE loadexpandednode
		* Show a message in the status bar while we load the children for a node.
		
		lparameters toNode
		local lcMessage, ;
			lcText
		lcMessage = 'Loading...'
		lcText = Thisform.UpdateStatePanel(lcMessage)
		dodefault(toNode)
		Thisform.UpdateStatePanel(lcText)
		
	ENDPROC

	PROCEDURE loadimages
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			return This.oController.LoadImages(This)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE loadnode
		lparameters toNodeItem, ;
			tcParentKey
		local loNode
		
		* If we have a controller, have it do any pre-work.
		
		if vartype(This.oController) = 'O'
			This.oController.BeforeLoadNode(This, toNodeItem, tcParentKey)
		endif vartype(This.oController) = 'O'
		
		* Do the usual behavior.
		
		loNode = dodefault(toNodeItem, tcParentKey)
		
		* Allow the controller to do any post-work.
		
		if vartype(This.oController) = 'O'
			This.oController.AfterLoadNode(This, toNodeItem, tcParentKey, loNode)
		endif vartype(This.oController) = 'O'
		return loNode
		
	ENDPROC

	PROCEDURE loadtree
		lparameters tlNoSelect
		local lcMessage
		
		* Show a message in the status bar while we load the tree.
		
		lcMessage = 'Loading...'
		Thisform.UpdateStatePanel(lcMessage)
		
		* If we have a controller, have it do any pre-work.
		
		if vartype(This.oController) = 'O'
			This.oController.BeforeLoadTree(This, tlNoSelect)
		endif vartype(This.oController) = 'O'
		
		* Do the usual behavior.
		
		dodefault(tlNoSelect)
		
		* Allow the controller to do any post-work.
		
		if vartype(This.oController) = 'O'
			This.oController.AfterLoadTree(This, tlNoSelect)
		endif vartype(This.oController) = 'O'
		
		* Clear the message.
		
		lcMessage = 'Ready'
		Thisform.UpdateStatePanel(lcMessage)
		
	ENDPROC

	PROCEDURE pushkey
		* If we have a controller, have it do the work.
		
		lparameters tcKey
		if vartype(This.oController) = 'O'
			return This.oController.PushKey(This, tcKey)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE shortcutmenu
		* If we have a controller, have it do the work.
		
		lparameters toMenu, ;
			tcObject
		if vartype(This.oController) = 'O'
			return This.oController.ShortcutMenu(This, toMenu, tcObject)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE showmenu
		* Destroy the menu after we've used it so it's recreated fresh each item
		* because some items in the menu may be conditional.
		
		dodefault()
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE treedblclick
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			This.oController.TreeDblClick(This)
		endif vartype(This.oController) = 'O'
		
		* Do the usual behavior.
		
		dodefault()
		
	ENDPROC

	PROCEDURE treeolecompletedrag
		lparameters tnEffect
		
		* Do the usual behavior.
		
		dodefault(tnEffect)
		
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			This.oController.TreeOLECompleteDrag(This, tnEffect)
		endif vartype(This.oController) = 'O'
		
	ENDPROC

	PROCEDURE treeolestartdrag
		lparameters toData, ;
			tnAllowedEffects
		
		* If we have a controller, have it do the work.
		
		if vartype(This.oController) = 'O'
			This.oController.TreeOLEStartDrag(This, toData, @tnAllowedEffects)
		endif vartype(This.oController) = 'O'
		
		* Do the usual behavior.
		
		dodefault(toData, tnAllowedEffects)
		
	ENDPROC

ENDDEFINE
