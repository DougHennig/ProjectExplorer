*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="projectexplorercommondialog.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS projectexplorercommondialog AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addfilter		&& Sets file extension filters for use when displaying dialog.
		*m: cleardlls
		*m: clearfilters		&& Clears all file extension filters.
		*m: dialoghandler
		*m: loaddlls
		*m: showdialog		&& Displays dialog with various options such as filters.
		*p: ccustomfilter		&& Custom filter the user created while using dialog.
		*p: cdefaultextension		&& Default file extension to display.
		*p: cfilename		&& Name of file selected or initially set as default.
		*p: cfilepath		&& Path that files were selected from.
		*p: cfiletitle		&& File title property of the selected file(s).
		*p: cinitialdirectory		&& Initial directory to show files from.
		*p: ctitlebartext		&& Caption for dialog title bar.
		*p: lallowmultiselect		&& Whether to allow selection of multiple files.
		*p: lfilemustexist		&& Allows only valid existing files to be entered.
		*p: lhidereadonly		&& Hides read-only files from list.
		*p: lnewexplorer		&& Use new explorer user interface and features such as Places bar.
		*p: lnochangedir		&& Don't allow initially displayed directory to be changed.
		*p: lnonetworkbutton		&& Do not include a network button in dialog.
		*p: lnoplacesbar		&& Do not include Places bar in dialog.
		*p: lnovalidate
		*p: loverwriteprompt		&& .T. to prompt to overwrite if the user selects an existing file
		*p: lpathmustexist		&& .T. if the path must exist
		*p: lsavedialog		&& Use Save dialog instead of Open one.
		*p: lusectl32		&& .T. to use the Ctl32 dialog instead
		*p: nfilecount		&& Number of files selected from dialog.
		*p: nfilterindex		&& Specifies which of the filters the user selected from the dialog.
		*p: nhwndowner		&& For internal use only.
		*p: ninstance		&& For internal use only.
		*a: afilenames[1,0]		&& Array of filenames returned from dialog.
		*a: afilterlist[1,2]		&& Array of file extension filters passed to dialog.
	*</DefinedPropArrayMethod>

	PROTECTED afilterlist,nhwndowner,ninstance
	*<PropValue>
		ccustomfilter = 
		cdefaultextension = 
		cfilename = 
		cfilepath = 
		cfiletitle = 
		cinitialdirectory = 
		ctitlebartext = 
		lallowmultiselect = .F.
		lfilemustexist = .F.
		lhidereadonly = .T.
		lnewexplorer = .T.
		lnochangedir = .F.
		lnonetworkbutton = .F.
		lnoplacesbar = .F.
		lnovalidate = .F.
		loverwriteprompt = .F.
		lpathmustexist = .F.
		lsavedialog = .F.
		lusectl32 = .F.
		Name = "projectexplorercommondialog"
		nfilecount = 0
		nfilterindex = 0
		nhwndowner = 0
		ninstance = 0
		_memberdata = <VFPData>
			<memberdata name="addfilter" type="method" display="AddFilter"/>
			<memberdata name="afilenames" type="property" display="aFileNames"/>
			<memberdata name="afilterlist" type="property" display="aFilterList"/>
			<memberdata name="ccustomfilter" type="property" display="cCustomFilter"/>
			<memberdata name="cdefaultextension" type="property" display="cDefaultExtension"/>
			<memberdata name="cfilename" type="property" display="cFileName"/>
			<memberdata name="cfilepath" type="property" display="cFilePath"/>
			<memberdata name="cfiletitle" type="property" display="cFileTitle"/>
			<memberdata name="cinitialdirectory" type="property" display="cInitialDirectory"/>
			<memberdata name="cleardlls" type="method" display="ClearDLLs"/>
			<memberdata name="clearfilters" type="method" display="ClearFilters"/>
			<memberdata name="ctitlebartext" type="property" display="cTitlebarText"/>
			<memberdata name="dialoghandler" type="method" display="DialogHandler"/>
			<memberdata name="lallowmultiselect" type="property" display="lAllowMultiSelect"/>
			<memberdata name="lfilemustexist" type="property" display="lFileMustExist"/>
			<memberdata name="lhidereadonly" type="property" display="lHideReadOnly"/>
			<memberdata name="lnewexplorer" type="property" display="lNewExplorer"/>
			<memberdata name="lnochangedir" type="property" display="lNoChangeDir"/>
			<memberdata name="lnonetworkbutton" type="property" display="lNoNetworkButton"/>
			<memberdata name="lnoplacesbar" type="property" display="lNoPlacesBar"/>
			<memberdata name="lnovalidate" type="property" display="lNoValidate"/>
			<memberdata name="loaddlls" type="method" display="LoadDLLs"/>
			<memberdata name="lpathmustexist" type="property" display="lPathMustExist"/>
			<memberdata name="lsavedialog" type="property" display="lSaveDialog"/>
			<memberdata name="nfilecount" type="property" display="nFileCount"/>
			<memberdata name="nfilterindex" type="property" display="nFilterIndex"/>
			<memberdata name="nhwndowner" type="property" display="nHwndOwner"/>
			<memberdata name="ninstance" type="property" display="nInstance"/>
			<memberdata name="showdialog" type="method" display="ShowDialog"/>
			<memberdata name="loverwriteprompt" type="property" display="lOverwritePrompt"/>
			<memberdata name="lusectl32" type="property" display="lUseCtl32"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE addfilter		&& Sets file extension filters for use when displaying dialog.
		lparameters tcDescription, ;
			tcSkeleton
		local lnNewRow
		with This
			lnNewRow = iif(empty(.aFilterList[1]), 1, alen(.aFilterList, 1) + 1)
			dimension .aFilterList[lnNewRow, 2]
			.aFilterList[lnNewRow, 1] = tcDescription
			if vartype(tcSkeleton) <> 'C' or empty(tcSkeleton)
				.aFilterList[lnNewRow, 2] = '*.*'
			else
				.aFilterList[lnNewRow, 2] = tcSkeleton
			endif vartype(tcSkeleton) <> 'C' ...
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE cleardlls
		clear dlls _FFC_SAVEFILENAME, _FFC_GETFILENAME, _FFC_MEMCPY, ;
			_FFC_MEMCPY2, _FFC_MALLOC, _FFC_FREEMEM
		
	ENDPROC

	PROCEDURE clearfilters		&& Clears all file extension filters.
		LPARAMETERS lComplete
		DIMENSION THIS.aFilterList[1,2]
		IF lComplete
			THIS.aFilterList= ""
		ELSE
			THIS.aFilterList[1,1] = "All files (*.*)"
			THIS.aFilterList[1,2] = "*.*"
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE dialoghandler
		
		#define OFN_READONLY                 0x00000001
		#define OFN_OVERWRITEPROMPT          0x00000002
		#define OFN_HIDEREADONLY             0x00000004
		#define OFN_NOCHANGEDIR              0x00000008
		#define OFN_SHOWHELP                 0x00000010
		#define OFN_ENABLEHOOK               0x00000020
		#define OFN_ENABLETEMPLATE           0x00000040
		#define OFN_ENABLETEMPLATEHANDLE     0x00000080
		#define OFN_NOVALIDATE               0x00000100
		#define OFN_ALLOWMULTISELECT         0x00000200
		#define OFN_EXTENSIONDIFFERENT       0x00000400
		#define OFN_PATHMUSTEXIST            0x00000800
		#define OFN_FILEMUSTEXIST            0x00001000
		#define OFN_CREATEPROMPT             0x00002000
		#define OFN_SHAREAWARE               0x00004000
		#define OFN_NOREADONLYRETURN         0x00008000
		#define OFN_NOTESTFILECREATE         0x00010000
		#define OFN_NONETWORKBUTTON          0x00020000		&& for old style dialog
		#define OFN_NOLONGNAMES              0x00040000     && force no long names for 4.x modules
		#define OFN_EXPLORER                 0x00080000     && new look commdlg
		#define OFN_NODEREFERENCELINKS       0x00100000
		#define OFN_LONGNAMES                0x00200000     && force long names for 3.x modules
		#define OFN_ENABLEINCLUDENOTIFY      0x00400000     && send include message to callback
		#define OFN_ENABLESIZING             0x00800000
		#define OFN_EX_NOPLACESBAR         	 0x00000001		&& used for newer OS only (uses FlagsEx)
		
		
		local lStructSize, hwndOwner, hInstance,;
			cMyFilter, i, lpMyFilter,;
			nMaxCustomFilter, cUserCustomFilter, lpUserCustomFilter,;
			nMaxFileName, cFileName, lpFileName,;
			nMaxFileTitle, cFileTitle, lpFileTitle
		local lpInitialDirectory, lpTitlebarText, nFlags, nFlagsEx, ;
			nFileOffset, nFileExtension, cDefExt,;
			lpDefExt, lCustomData, lpHook, lpTemplateName,;
			cMyStruct, nReturnVal, nFileNameOffset
		local lcFileName, lcUserCustomFilter, lcFileTitle,;
			nCurrentFilePos, nArraySize, nNextFilePos, ;
			lcCurDir, lnFilter
		
		hwndOwner = this.nHwndOwner
		hInstance = this.nInstance
		nFlags = 0
		nFlags = OFN_ENABLEHOOK
		nFlagsEx = 0
		
		* Blank certain properties before we start.
		
		dimension This.aFileNames[1]
		This.aFileNames[1] = ''
		This.nFileCount = 0
		
		*  Build the filter string.
		cMyFilter = ""
		for i = 1 to alen(this.aFilterList, 1)
			cMyFilter = cMyFilter + this.aFilterList[m.i,1] + chr(0) + this.aFilterList[m.i,2] + chr(0)
		endfor
		cMyFilter = cMyFilter + + repl(chr(0),2)
		lpMyFilter = _FFC_MALLOC(len(cMyFilter))
		if lpMyFilter = 0
		* Couldn't allocate memory
			return ""
		endif
		
		*  Setup Flags
		if this.lNewExplorer
			nFlags = nFlags + OFN_EXPLORER + OFN_ENABLESIZING
		endif
		if this.lHideReadOnly
			nFlags = nFlags + OFN_HIDEREADONLY
		endif
		if this.lFileMustExist
			nFlags = nFlags + OFN_FILEMUSTEXIST
		endif
		if this.lPathMustExist
			nFlags = nFlags + OFN_PATHMUSTEXIST
		endif
		if this.lNoNetworkButton
		* Old style dialogs only
			nFlags = nFlags + OFN_NONETWORKBUTTON
		endif
		if this.lNoChangeDir
			nFlags = nFlags + OFN_NOCHANGEDIR
		endif
		if this.lNoValidate
			nFlags = nFlags + OFN_NOVALIDATE
		endif
		if this.lOverwritePrompt
			nFlags = nFlags + OFN_OVERWRITEPROMPT
		endif
		if this.lAllowMultiSelect and !this.lSaveDialog
			nFlags = nFlags + OFN_ALLOWMULTISELECT
		endif
		
		*  Setup FlagsEx
		if this.lnoplacesbar
			nFlagsEx = nFlagsEx + OFN_EX_NOPLACESBAR
		endif
		
		declare integer memcpy in msvcrt.dll as _FFC_MEMCPY  integer , string @, integer
		
		_FFC_MEMCPY(lpMyFilter, @cMyFilter, len(cMyFilter))
		
		*  Prepare the custom filter string
		nMaxCustomFilter = 1024
		cUserCustomFilter = repl(chr(0), nMaxCustomFilter)
		lpUserCustomFilter = _FFC_MALLOC(nMaxCustomFilter)
		if lpUserCustomFilter = 0
		* Couldn't allocate memory
			_FFC_FREEMEM(lpMyFilter)
			return ""
		endif
		_FFC_MEMCPY(lpUserCustomFilter, @cUserCustomFilter, nMaxCustomFilter)
		
		* Prepare the string for the selected filename(s)
		nMaxFileName = 8192
		cFileName = left(this.cFileName, nMaxFileName - 1) + repl(chr(0), nMaxFileName - min(len(this.cFileName),nMaxFileName - 1))
		lpFileName = _FFC_MALLOC(nMaxFileName)
		if lpFileName = 0
			_FFC_FREEMEM(lpMyFilter)
			_FFC_FREEMEM(lpUserCustomFilter)
		endif
		_FFC_MEMCPY(lpFileName, @cFileName, nMaxFileName)
		
		*  File Title
		nMaxFileTitle = 300
		cFileTitle  = repl(chr(0), nMaxFileTitle)
		lpFileTitle = _FFC_MALLOC(nMaxFileTitle)
		if lpFileTitle = 0
			_FFC_FREEMEM(lpMyFilter)
			_FFC_FREEMEM(lpUserCustomFilter)
			_FFC_FREEMEM(lpFileName)
		endif
		_FFC_MEMCPY(lpFileTitle, @cFileTitle, nMaxFileTitle)
		
		*  Initial Directory
		lpInitialDirectory = _FFC_MALLOC(266)
		if lpInitialDirectory = 0
			_FFC_FREEMEM(lpMyFilter)
			_FFC_FREEMEM(lpUserCustomFilter)
			_FFC_FREEMEM(lpFileName)
			_FFC_FREEMEM(lpFileTitle)
		endif
		_FFC_MEMCPY(lpInitialDirectory, this.cInitialDirectory + chr(0), min(len(this.cInitialDirectory) + 1, 260))
		
		* Title bar text
		lpTitlebarText = _FFC_MALLOC(len(this.cTitlebartext) + 2)
		_FFC_MEMCPY(lpTitlebarText, this.cTitlebartext + chr(0) + chr(0), len(this.cTitlebartext) + 2)
		
		nFileOffset = 0
		nFileExtension = 0
		
		* Default Extension
		cDefExt = "TXT" + chr(0) + chr(0)
		lpDefExt = _FFC_MALLOC(len(this.cDefaultExtension) + 1)
		_FFC_MEMCPY(lpDefExt, this.cDefaultExtension + chr(0), len(this.cDefaultExtension) + 1)
		
		lCustomData = 0	&& not used without a hook
		lpHook = 0
		lpTemplateName = 0
		
		lStructSize = 22 * 4
		
		lnFilter = iif(This.nFilterIndex = 0, 1, This.nFilterIndex)
		
		cMyStruct = bintoc(lStructSize, '4RS') + ;
			bintoc(hwndOwner, '4RS') + ;
			bintoc(hInstance, '4RS') + ;
			bintoc(lpMyFilter, '4RS') + ;
			bintoc(lpUserCustomFilter, '4RS') + ;
			bintoc(nMaxCustomFilter, '4RS') + ;
			bintoc(lnFilter, '4RS') + ;
			bintoc(lpFileName, '4RS') + ;
			bintoc(nMaxFileName, '4RS') + ;
			bintoc(lpFileTitle, '4RS') + ;
			bintoc(nMaxFileTitle, '4RS') + ;
			bintoc(lpInitialDirectory, '4RS') + ;
			bintoc(lpTitlebarText, '4RS') + ;
			bintoc(nFlags, '4RS') + ;
			bintoc(nFileOffset, '2RS') + ;
			bintoc(nFileExtension, '2RS') + ;
			bintoc(lpDefExt, '4RS') + ;
			bintoc(lCustomData, '4RS') + ;
			bintoc(lpHook, '4RS') + ;
			bintoc(lpTemplateName, '4RS')
		
			cMyStruct = cMyStruct + ;
				bintoc(0, '4RS') + ;
				bintoc(0, '4RS') + ;
				bintoc(nFlagsEx, '4RS')
		
		* Save the current directory because the dialog changes it.
		
		lcCurDir = sys(5) + curdir()
		
		* Call the dialog now
		if this.lSaveDialog
			nReturnVal = _FFC_SAVEFILENAME(@cMyStruct)
		else
			nReturnVal = _FFC_GETFILENAME(@cMyStruct)
		endif
		
		* Restore the directory.
		
		cd (lcCurDir)
		
		if nReturnVal = 1
		*  Now retrieve info from allocated strings
		*  Retrieve Filename string
			declare integer memcpy in msvcrt.dll as	_FFC_MEMCPY2 string @, integer , integer
			lcFileName = repl(chr(0),nMaxFileName)
			_FFC_MEMCPY2(@lcFileName, lpFileName, nMaxFileName)
			nFileNameOffset = ctobin(substr(cMyStruct, 14*4+1, 2) + chr(0) + chr(0), 'RS')
		
		*  Check if user selected multiple files.
			if this.lAllowMultiSelect and nFileNameOffset > 1 and substr(lcFileName, nFileNameOffset, 1) = chr(0)
		*Now parse out to get multiple file names
				nCurrentFilePos = at(chr(0), lcFileName) + 1
				this.cFilePath = left(lcFileName, nCurrentFilePos - 2)
				nArraySize = 1
				do while .t.
					if substr(lcFileName, nCurrentFilePos, 1) = chr(0)
		* end of list.
						exit
					endif
					dimension this.aFileNames[nArraySize]
					nNextFilePos = at(chr(0), lcFileName, nArraySize + 1) + 1
					this.aFileNames[nArraySize] = substr(lcFileName, nCurrentFilePos, nNextFilePos - nCurrentFilePos - 1)
					nArraySize = nArraySize + 1
					nCurrentFilePos = nNextFilePos
				enddo
				this.nFileCount = nArraySize - 1
			else
		*  Didn't multiselect, so there's just one filename.
				lcFileName = left(lcFileName, at(chr(0), lcFileName) - 1)
				this.cFilePath = justpath(lcFileName)
				dimension this.aFileNames[1]
				this.aFileNames[1] = justfname(lcFileName)
				this.nFileCount = 1
			endif
		
			this.cFileName = left(lcFileName, at(chr(0), lcFileName) - 1)
		
			lcUserCustomFilter= repl(chr(0), nMaxCustomFilter)
			_FFC_MEMCPY2(@lcUserCustomFilter, lpUserCustomFilter, nMaxCustomFilter)
			this.cCustomFilter= left(lcUserCustomFilter, at(chr(0), lcUserCustomFilter) - 1)
		
			lcFileTitle = repl(chr(0), nMaxFileTitle)
			_FFC_MEMCPY2(@lcFileTitle, lpFileTitle, nMaxFileTitle)
			this.cFileTitle = left(lcFileTitle , at(chr(0), lcFileTitle ) - 1)
		
			this.nFilterIndex = ctobin(substr(cMyStruct, 6*4+1, 4), 'RS')
		endif
		
		_FFC_FREEMEM(lpMyFilter)
		_FFC_FREEMEM(lpUserCustomFilter)
		_FFC_FREEMEM(lpFileName)
		_FFC_FREEMEM(lpFileTitle)
		_FFC_FREEMEM(lpInitialDirectory)
		_FFC_FREEMEM(lpTitlebarText)
		_FFC_FREEMEM(lpDefExt)
		
		return nReturnVal
		
	ENDPROC

	PROCEDURE Init
		THIS.aFilterList[1,1] = "All Files (*.*)"
		THIS.aFilterList[1,2] = "*.*"
		
	ENDPROC

	PROTECTED PROCEDURE loaddlls
		DECLARE INTEGER GetSaveFileNameA IN comdlg32.dll AS _FFC_SAVEFILENAME STRING @
		DECLARE INTEGER GetOpenFileNameA IN comdlg32.dll AS _FFC_GETFILENAME STRING @
		DECLARE INTEGER malloc IN msvcrt.dll AS _FFC_MALLOC INTEGER
		DECLARE free in msvcrt.dll AS _FFC_FREEMEM INTEGER 
		
	ENDPROC

	PROCEDURE showdialog		&& Displays dialog with various options such as filters.
		local loFile, ;
			lcFilter, ;
			lnI, ;
			lcDescription, ;
			lcCurDir, ;
			llReturn
		with This
		
		* If we're supposed to, use the appropriate Ctl32 class and set its properties.
		
			if .lUseCtl32 and file('ctl32.vcx')
				loFile   = newobject(iif(.lSaveDialog, 'ctl32_SaveFileDialog', ;
					'ctl32_OpenFileDialog'), 'ctl32.vcx')
				lcFilter = ''
				for lnI = 1 to alen(.aFilterList, 1)
					lcDescription = .aFilterList[lnI, 1]
					if not empty(lcDescription)
						lcFilter = lcFilter + lcDescription + '|' + ;
							.aFilterList[lnI, 2] + '|'
					endif not empty(lcDescription)
				next lnI
				loFile.ctlFilter             = lcFilter
				loFile.ctlFilterIndex        = .nFilterIndex
				loFile.ctlTitle              = .cTitlebarText
				loFile.ctlInitialFileName    = icase(empty(.cFileName), '', ;
					'\' $ .cFileName, .cFileName, ;
					addbs(.cInitialDirectory) + .cFileName)
				loFile.ctlInitialFolder      = .cInitialDirectory
				loFile.ctlDefaultExt         = .cDefaultExtension
				loFile.ctlCheckFileExists    = .lFileMustExist
				loFile.ctlCheckPathExists    = .lPathMustExist
				loFile.ctlAutoUpgradeEnabled = .lNewExplorer
				loFile.ctlShowPlacesBar      = not .lNoPlacesBar
				loFile.ctlValidateNames      = not .lNoValidate
				loFile.ctlRestoreFolder      = .F.
					&& this is .F. because of a bug in ctl32_FileDialog._SetupOpenFileName
					&& that sets the initial folder to the current one if this is .T.
				if .lSaveDialog
					loFile.ctlOverwritePrompt = .lOverwritePrompt
				else
					loFile.ctlMultiSelect  = .lAllowMultiSelect
					loFile.ctlShowReadOnly = not .lHideReadOnly
				endif .lSaveDialog
		
		* Display the dialog and set the return properties appropriately.
		
				lcCurDir = sys(5) + curdir()
				if loFile.ctlShowDialog() = 0
					dimension .aFileNames[1]
					store '' to .cFilePath, .cFileTitle, .cFileName, .aFileNames
					.nFileCount = 0
				else
					.cFileName    = loFile.ctlFileName
					.cFilePath    = addbs(justpath(.cFileName))
					.cFileTitle   = justfname(.cFileName)
					.nFilterIndex = loFile.ctlFilterIndex
					.nFileCount   = loFile.ctlFileCount
					llReturn      = .T.
					dimension .aFileNames[.nFileCount]
					for lnI = 1 to loFile.ctlFileCount
						.aFileNames[lnI] = justfname(loFile.ctlFileNames[lnI])
					next lnI
				endif loFile.ctlShowDialog() = 0
				cd (lcCurDir)
			else
		
		* Use the common dialogs DLLs to do the work.
		
				store '' to .cFilePath, .cFileTitle
				.LoadDLLs()
				llReturn = .DialogHandler() = 1
				if llReturn
					.cFileName = addbs(.cFilePath) + .cFileTitle
				else
					store '' to .cFilePath, .cFileTitle, .cFileName
				endif llReturn
				.ClearDLLs()
			endif .lUseCtl32
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE
