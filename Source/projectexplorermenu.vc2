*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="projectexplorermenu.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS projectexplorerbar AS projectexplorercollection OF "projectexplorerctrls.vcx" 		&& A bar in a popup
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the submenu popup for this bar
		*m: addbars		&& Add bars to the submenu popup for this bar
		*m: addseparatorbar		&& Adds a separator bar to the submenu popup for this bar
		*m: allow		&& Determine if the bar is enabled
		*m: click		&& Called when the bar is chosen
		*m: define		&& Defines the bar
		*m: evaluatevisible		&& Determines if the bar is visible or not
		*m: findbarposition		&& Finds where the bar should be placed
		*m: hide		&& Hides the bar
		*m: lmarked_assign
		*m: lvisible_assign
		*m: refresh		&& Refreshes the bar
		*m: show		&& Displays the bar
		*p: cactiveformmethod		&& The method of the active form to execute
		*p: cappobjectmethod		&& The method of the application object to execute
		*p: cappobjectname		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
		*p: cbarposition		&& A "before" or "after" bar number clause
		*p: ccaption		&& The caption for the bar
		*p: cinstancename		&& The complete object path to this object starting from the menu object
		*p: ckey		&& The hotkey for the bar
		*p: ckeytext		&& The text for the hotkey
		*p: cmenuclauses		&& Other clauses for bar
		*p: conclickcommand		&& The command to execute when the bar is clicked
		*p: cpicturefile		&& The file name for the picture to use
		*p: cpictureresource		&& The system menu bar name for the picture to use
		*p: cpopupname		&& The name of the popup this bar belongs to
		*p: cpopupnamethis		&& The name of the popup this bar uses for submenus
		*p: cskipfor		&& The SKIP FOR clause for the bar
		*p: cstatusbartext		&& The text displayed in the status bar when this bar is highlighted
		*p: csystembar		&& The name of the VFP system menu bar if this is one of those
		*p: ldefined		&& .T. if the menu bar for this object has been defined
		*p: lenabled		&& .T. if the bar is enabled
		*p: linvert		&& .T. to make this an inverted bar
		*p: lmarked		&& .T. if the bar is marked
		*p: lmru		&& .T. to add an MRU bar at the bottom of the submenu
		*p: lspecified		&& .T. if the bar number is specified at a certain position
		*p: lvisible		&& .T. if the bar should be visible
		*p: nbarnumber		&& The number of the bar
		*p: nseparatorbarcount		&& The number of separator bars in the menu
		*p: oparent		&& A reference to the parent for this bar
	*</DefinedPropArrayMethod>

	PROTECTED cpopupname,cpopupnamethis,ldefined,lspecified,nseparatorbarcount
	cactiveformmethod = 		&& The method of the active form to execute
	cappobjectmethod = 		&& The method of the application object to execute
	cappobjectname = oApp		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
	cbarposition = 		&& A "before" or "after" bar number clause
	ccaption = 		&& The caption for the bar
	cinstancename = 		&& The complete object path to this object starting from the menu object
	ckey = 		&& The hotkey for the bar
	ckeytext = 		&& The text for the hotkey
	cmenuclauses = 		&& Other clauses for bar
	conclickcommand = 		&& The command to execute when the bar is clicked
	cpicturefile = 		&& The file name for the picture to use
	cpictureresource = 		&& The system menu bar name for the picture to use
	cpopupname = 		&& The name of the popup this bar belongs to
	cpopupnamethis = 		&& The name of the popup this bar uses for submenus
	cskipfor = not This.Allow()		&& The SKIP FOR clause for the bar
	cstatusbartext = 		&& The text displayed in the status bar when this bar is highlighted
	csystembar = 		&& The name of the VFP system menu bar if this is one of those
	ldefined = .F.		&& .T. if the menu bar for this object has been defined
	lenabled = .T.		&& .T. if the bar is enabled
	linvert = .F.		&& .T. to make this an inverted bar
	lmarked = .F.		&& .T. if the bar is marked
	lmru = .F.		&& .T. to add an MRU bar at the bottom of the submenu
	lspecified = .F.		&& .T. if the bar number is specified at a certain position
	lvisible = .T.		&& .T. if the bar should be visible
	Name = "projectexplorerbar"
	nbarnumber = 0		&& The number of the bar
	nseparatorbarcount = 0		&& The number of separator bars in the menu
	oparent = .NULL.		&& A reference to the parent for this bar
	_memberdata = <VFPData>
		<memberdata name="addbar" type="method" display="AddBar"/>
		<memberdata name="addbars" type="method" display="AddBars"/>
		<memberdata name="addseparatorbar" type="method" display="AddSeparatorBar"/>
		<memberdata name="allow" type="method" display="Allow" favorites="True"/>
		<memberdata name="cactiveformmethod" type="property" display="cActiveFormMethod" favorites="True"/>
		<memberdata name="cappobjectmethod" type="property" display="cAppObjectMethod" favorites="True"/>
		<memberdata name="cappobjectname" type="property" display="cAppObjectName"/>
		<memberdata name="cbarposition" type="property" display="cBarPosition"/>
		<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
		<memberdata name="cinstancename" type="property" display="cInstanceName"/>
		<memberdata name="ckey" type="property" display="cKey" favorites="True"/>
		<memberdata name="ckeytext" type="property" display="cKeyText" favorites="True"/>
		<memberdata name="click" type="method" display="Click" favorites="True"/>
		<memberdata name="cmenuclauses" type="property" display="cMenuClauses" favorites="True"/>
		<memberdata name="conclickcommand" type="property" display="cOnClickCommand" favorites="True"/>
		<memberdata name="cpicturefile" type="property" display="cPictureFile" favorites="True"/>
		<memberdata name="cpictureresource" type="property" display="cPictureResource" favorites="True"/>
		<memberdata name="cpopupname" type="property" display="cPopupName"/>
		<memberdata name="cpopupnamethis" type="property" display="cPopupNameThis"/>
		<memberdata name="cskipfor" type="property" display="cSkipFor" favorites="True"/>
		<memberdata name="cstatusbartext" type="property" display="cStatusBarText" favorites="True"/>
		<memberdata name="csystembar" type="property" display="cSystemBar" favorites="True"/>
		<memberdata name="define" type="method" display="Define"/>
		<memberdata name="evaluatevisible" type="method" display="EvaluateVisible" favorites="True"/>
		<memberdata name="findbarposition" type="method" display="FindBarPosition"/>
		<memberdata name="hide" type="method" display="Hide"/>
		<memberdata name="ldefined" type="property" display="lDefined"/>
		<memberdata name="lenabled" type="property" display="lEnabled"/>
		<memberdata name="linvert" type="property" display="lInvert"/>
		<memberdata name="lmarked" type="property" display="lMarked"/>
		<memberdata name="lmarked_assign" type="method" display="lMarked_Assign"/>
		<memberdata name="lmru" type="property" display="lMRU"/>
		<memberdata name="lspecified" type="property" display="lSpecified"/>
		<memberdata name="lvisible" type="property" display="lVisible"/>
		<memberdata name="lvisible_assign" type="method" display="lVisible_Assign"/>
		<memberdata name="nbarnumber" type="property" display="nBarNumber"/>
		<memberdata name="nseparatorbarcount" type="property" display="nSeparatorBarCount"/>
		<memberdata name="refresh" type="method" display="Refresh"/>
		<memberdata name="show" type="method" display="Show"/>
		<memberdata name="init" type="event" favorites="True"/>
		<memberdata name="oparent" type="property" display="oParent"/>
		</VFPData>
	
	PROCEDURE about
		* Thanks to Jim Slater for suggesting (and mostly implementing) the following
		* ideas:
		*
		* - Submenu support
		* - Support for specifying a bar by name rather than number in cBarPosition
		* - Support for the cAppObjectName property
		* - Support for multi-line code in cOnClickCommand
		* - Bug fixes
		
	ENDPROC

	PROCEDURE addbar		&& Adds a bar to the submenu popup for this bar
		lparameters tcClass, ;
			tcLibrary, ;
			tcName, ;
			tnBarNumber
		local lnBarNumber, ;
			llSpecified, ;
			loBar
		with This
		
		* Create a bar number if one wasn't passed.
		
			if vartype(tnBarNumber) = 'N' and tnBarNumber <> 0
				lnBarNumber = tnBarNumber
				llSpecified = .T.
			else
				lnBarNumber = .Count + 1
			endif vartype(tnBarNumber) = 'N' ...
		
		* Create the object as a member.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				loBar = createobject(tcClass, lnBarNumber, .cPopupNameThis, tcName, ;
					llSpecified)
			else
				loBar = newobject(tcClass, tcLibrary, '', lnBarNumber, ;
					.cPopupNameThis, tcName, llSpecified)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
			loBar.oParent = This
			.AddProperty(tcName, loBar)
		
		* Add the bar to the collection.
		
			.Add(loBar, tcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE addbars		&& Add bars to the submenu popup for this bar
		* Abstract method
		
	ENDPROC

	PROCEDURE addseparatorbar		&& Adds a separator bar to the submenu popup for this bar
		local lcName, ;
			loBar
		with This
			.nSeparatorBarCount = .nSeparatorBarCount + 1
			lcName = 'Separator' + transform(.nSeparatorBarCount)
			loBar  = .AddBar('ProjectExplorerSeparatorBar', 'ProjectExplorerMenu.vcx', ;
				lcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE allow		&& Determine if the bar is enabled
		* Abstract method
		
	ENDPROC

	PROCEDURE click		&& Called when the bar is chosen
		local lcMethod, ;
			lnPos, ;
			lcPadPath, ;
			lcBarPath, ;
			lcCommand
		with This
			do case
		
		* If a method of the application object was specified, call it.
		
				case not empty(.cAppObjectMethod)
					lcMethod = .cAppObjectMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type(.cAppObjectName + '.Name') = 'C' and ;
						pemstatus(evaluate(.cAppObjectName), lcMethod, 5)
						evaluate(.cAppObjectName + '.' + .cAppObjectMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type(.cAppObjectName + '.Name') = 'C' ...
		
		* If a method of the active form was specified, call it.
		
				case not empty(.cActiveFormMethod)
					lcMethod = .cActiveFormMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type('_screen.ActiveForm.Name') = 'C' and ;
						pemstatus(_screen.ActiveForm, lcMethod, 5)
						evaluate('_screen.ActiveForm.' + .cActiveFormMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type('_screen.ActiveForm.Name') = 'C' ...
		
		* If an command to execute was specified, call it.
		
				case not empty(.cOnClickCommand)
					lcPadPath = .oParent.cInstanceName + '.'
					lcBarPath = lcPadPath + .Name + '.'
					lcCommand = strtran(strtran(.cOnClickCommand, 'This.oParent.', ;
						lcPadPath), 'This.', lcBarPath)
					if ccCR $ lcCommand or ccCRLF $ lcCommand
						execscript(lcCommand)
					else
						&lcCommand
					endif ccCR $ lcCommand ...
			endcase
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE define		&& Defines the bar
		local lcPopupName, ;
			lcPadPath, ;
			lcBarPath, ;
			llSystemBar, ;
			lcBarNumber, ;
			lcSkipFor, ;
			lcBarPosition, ;
			lcBarName, ;
			lnI, ;
			loBar, ;
			lnBar, ;
			lcClauses, ;
			lcPopupNameThis
		with This
			if vartype(.oParent) = 'O'
				lcPopupName    = .cPopupName
				lcPadPath      = .oParent.cInstanceName + '.'
				.cInstanceName = lcPadPath + .Name
				lcBarPath      = .cInstanceName + '.'
		
		* Get the bar number based on whether we're a system bar or not.
		
				if empty(.cSystemBar)
					lcBarNumber = transform(.nBarNumber)
				else
					lcBarNumber = transform(evaluate(.cSystemBar))
					llSystemBar = .T.
				endif empty(.cSystemBar)
		
		* Create a default status bar text if we don't have one.
		
				if empty(.cStatusBarText)
					.cStatusBarText = strtran(strtran(.cCaption, '\<'), '\')
				endif empty(.cStatusBarText)
		
		* Set the SKIP FOR for the bar.
		
				lcSkipFor = 'not ' + lcBarPath + 'lEnabled'
				if not empty(.cSkipFor)
					lcSkipFor = lcSkipFor + ' or ' + ;
						strtran(strtran(.cSkipFor, 'This.oParent.', lcPadPath), ;
							'This.', lcBarPath)
				endif not empty(.cSkipFor)
		
		* If a bar position has been defined, it may have been defined by bar name
		* rather than number, so get the appropriate bar number.
		
				lcBarPosition = ''
				if not empty(.cBarPosition)
					lcBarName = alltrim(upper(substr(.cBarPosition, 7)))
					if val(lcBarName) = 0
						for lnI = 1 to .nBarNumber - 1
							loBar = .oParent.Item(lnI)
							do case
								case not upper(loBar.Name) == lcBarName
								case empty(loBar.cSystemBar)
									lcBarPosition = trim(left(.cBarPosition, 6)) + ;
										' ' + transform(loBar.nBarNumber)
									exit
								otherwise
									lcBarPosition = trim(left(.cBarPosition, 6)) + ;
										' ' + transform(evaluate(loBar.cSystemBar))
									exit
							endcase
						next lnI
					else
						lcBarPosition = .cBarPosition
					endif val(lcBarName) = 0
		
		* If the bar position wasn't defined, see if there's another bar in our
		* position. If so, we'll use the BEFORE clause to put ourselves before that
		* one. This is needed, for example, if you refresh a bar; it's removed from the
		* menu, then readded. Without the BEFORE clause, it would be added to the end
		* because we define popups with the RELATIVE clause.
		
				else
					try
						lnBar = getbar(lcPopupName, .nBarNumber)
					catch
						lnBar = .nBarNumber
					endtry
					if lnBar <> .nBarNumber
						lcBarPosition = 'before ' + transform(lnBar)
					endif lnBar <> .nBarNumber
				endif not empty(.cBarPosition)
		
		* Set the other clauses of the DEFINE BAR command.
		
				lcClauses = .cMenuClauses + iif(empty(.cMenuClauses), '', ' ') + ;
					lcBarPosition
				if not empty(.cKey)
					lcClauses = lcClauses + ' key ' + .cKey + ", '" + .cKeyText + "'"
				endif not empty(.cKey)
				if .lInvert
					lcClauses = lcClauses + ' invert'
				endif .lInvert
				do case
					case not empty(.cPictureResource)
						lcClauses = lcClauses + ' pictres ' + .cPictureResource
					case not empty(.cPicturefile)
						lcClauses = lcClauses + " picture '" + .cPicturefile + "'"
					case not empty(.cSystemBar)
						lcClauses = lcClauses + ' pictres ' + .cSystemBar
				endcase
		
		* Define the bar.
		
				define bar &lcBarNumber of &lcPopupName prompt .cCaption ;
					message .cStatusBarText skip for &lcSkipFor &lcClauses
		
		* Mark the bar if it's supposed to be.
		
				if .lMarked
					set mark of bar &lcBarNumber of &lcPopupName to .T.
				endif .lMarked
		
		* If this isn't a system bar, call the Click method when the bar's selected.
		
				if not llSystemBar
					on selection bar &lcBarNumber of &lcPopupName &lcBarPath.Click()
				endif not llSystemBar
		
		* If we have any bars in our submenu, create the popup for it.
		
				if .Count > 0
					lcPopupNameThis = .cPopupNameThis
					define popup (.cPopupNameThis) margin relative shadow ;
						color scheme 4
					on bar &lcBarNumber of &lcPopupName activate popup &lcPopupNameThis
		
		* Now add bars to the submenu.
		
					.AddBars()
		
		* If this is an MRU submenu, add an MRU bar at the end.
		
					if .lMRU
						.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
					endif .lMRU
				endif .Count > 0
		
		* Flag that the menu bar has been defined.
		
				.lDefined = .T.
			endif vartype(.oParent) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE evaluatevisible		&& Determines if the bar is visible or not
		* Abstract method.
		
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE findbarposition		&& Finds where the bar should be placed
		local lnBar, ;
			loBar, ;
			lcBarNumber, ;
			llFoundBar
		with This
		
		* We'll only do this if we don't already have a bar position.
		
			if empty(.cBarPosition)
		
		* See if there are any bars before this one that are currently visible.
		
				for lnBar = .nBarNumber - 1 to 1 step -1
					loBar = .oParent.Item(lnBar)
					if vartype(loBar) = 'O' and loBar.lVisible
						if empty(loBar.cSystemBar)
							lcBarNumber = transform(loBar.nBarNumber)
						else
							lcBarNumber = transform(evaluate(loBar.cSystemBar))
						endif empty(loBar.cSystemBar)
						.cBarPosition = 'after ' + lcBarNumber
						llFoundBar    = .T.
						exit
					endif vartype(loBar) = 'O' ...
				next lnBar
		
		* If we haven't found a bar to place this one after, see if there's one we can
		* place this before.
		
				if not llFoundBar
					for lnBar = .nBarNumber + 1 to .oParent.Count
						loBar = .oParent.Item(lnBar)
						if vartype(loBar) = 'O' and loBar.lVisible
							if empty(loBar.cSystemBar)
								lcBarNumber = transform(loBar.nBarNumber)
							else
								lcBarNumber = transform(evaluate(loBar.cSystemBar))
							endif empty(loBar.cSystemBar)
							.cBarPosition = 'before ' + lcBarNumber
							exit
						endif vartype(loBar) = 'O' ...
					next lnBar
				endif not llFoundBar
			endif empty(.cBarPosition)
		endwith
		
	ENDPROC

	PROCEDURE hide		&& Hides the bar
		local lnI, ;
			loBar, ;
			lcBarNumber, ;
			lcPopupName, ;
			lcPopupNameThis
		with This
			if .lDefined
		
		* Hide any bars in the submenu if there is one.
		
				for lnI = 1 to .Count
					loBar = .Item(lnI)
					loBar.Hide()
				next lnI
		
		* Hide the bar by releasing it.
		
				if empty(.cSystemBar)
					lcBarNumber = transform(.nBarNumber)
				else
					lcBarNumber = transform(evaluate(.cSystemBar))
				endif empty(.cSystemBar)
				lcPopupName = .cPopupName
				release bar &lcBarNumber of &lcPopupName
			endif .lDefined
		
		* Release our submenu popup if it exists.
		
			lcPopupNameThis = .cPopupNameThis
			if popup(lcPopupNameThis)
				release popup &lcPopupNameThis
			endif popup(lcPopupNameThis)
			.lDefined = .F.
		endwith
		
	ENDPROC

	PROCEDURE Init
		lparameters tnBarNumber, ;
			tcPopupName, ;
			tcName, ;
			tlSpecified
		with This
			dodefault()
			.nBarNumber = tnBarNumber
			.cPopupName = tcPopupName
			.lSpecified = tlSpecified
			.lVisible   = .EvaluateVisible()
		
		* If a name was specified, use it.
		
			if vartype(tcName) = 'C' and not empty(tcName)
				.Name = tcName
			endif vartype(tcName) = 'C' ...
		
		* Define the popup for this bar.
		
			if empty(.cPopupNameThis)
				.cPopupNameThis = .Name
			endif empty(.cPopupNameThis)
		endwith
		
	ENDPROC

	PROCEDURE lmarked_assign
		lparameters tlValue
		local lcSetting, ;
			lcBarNumber, ;
			lcPopupName
		with This
			assert vartype(tlValue) = 'L'
			lcSetting = iif(tlValue, '.T.', '.F.')
			.lMarked  = tlValue
			if empty(.cSystemBar)
				lcBarNumber = transform(.nBarNumber)
			else
				lcBarNumber = transform(evaluate(.cSystemBar))
			endif empty(.cSystemBar)
			lcPopupname = .cPopupName
			set mark of bar &lcBarNumber of &lcPopupName to &lcSetting
		endwith
		
	ENDPROC

	PROCEDURE lvisible_assign
		lparameters tlValue
		assert vartype(tlValue) = 'L'
		with This
			if tlValue <> .lVisible
				.lVisible   = tlValue
				.lSpecified = .T.	&& so when we show it, it appears in correct place
				do case
					case .CalledFromThisClass()
					case tlValue
						.Show()
					otherwise
						.Hide()
				endcase
			endif tlValue <> .lVisible
		endwith
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the bar
		* Refresh the bar by hiding it, re-evaluating lVisible, and showing it again.
		
		with This
			.Hide()
			.lVisible = .EvaluateVisible()
			.Show()
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Hide the bar by releasing it. Release each bar so our reference in it is
		* nuked and nuke our own parent reference.
		
		local lnI, ;
			loBar
		This.Hide()
		for lnI = This.Count to 1 step -1
			loBar = This.Item(lnI)
			loBar.Release()
		next lnI
		This.oParent = .NULL.
		
	ENDPROC

	PROCEDURE show		&& Displays the bar
		* If we're supposed to, call FindBarPosition to see where the bar should go,
		* then define it.
		
		local lnI, ;
			loBar
		with This
			if .lVisible and not .lDefined
				if .lSpecified or .lInvert
					.FindBarPosition()
				endif .lSpecified ...
				.Define()
			endif .lVisible ...
		
		* Display any bars in our submenu if there is one.
		
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				else
					loBar.Show()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorermenu AS projectexplorercollection OF "projectexplorerctrls.vcx" 		&& A menu
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addpad		&& Adds a pad to the menu
		*m: cinstancename_assign
		*m: definemenu		&& Defines the desired pads in the menu
		*m: refresh		&& Refreshes the display of the menu.
		*m: show		&& Displays the menu.
		*p: cformname		&& The name of a top-level form for a menu to be placed into
		*p: cinstancename		&& The name of the variable containing the reference for this object
		*p: cmenuname		&& The name of the menu
		*p: laddtosystemmenu		&& .T. to add to the VFP system menu or .F. to be a standalone menu
	*</DefinedPropArrayMethod>

	cformname = 		&& The name of a top-level form for a menu to be placed into
	cinstancename = 		&& The name of the variable containing the reference for this object
	cmenuname = _msysmenu		&& The name of the menu
	laddtosystemmenu = .F.		&& .T. to add to the VFP system menu or .F. to be a standalone menu
	Name = "projectexplorermenu"
	_memberdata = <VFPData>
		<memberdata name="addpad" type="method" display="AddPad"/>
		<memberdata name="cinstancename" type="property" display="cInstanceName"/>
		<memberdata name="cinstancename_assign" type="method" display="cInstanceName_Assign"/>
		<memberdata name="definemenu" type="method" display="DefineMenu"/>
		<memberdata name="refresh" type="method" display="Refresh"/>
		<memberdata name="show" type="method" display="Show"/>
		<memberdata name="cformname" type="property" display="cFormName"/>
		<memberdata name="cmenuname" type="property" display="cMenuName"/>
		<memberdata name="laddtosystemmenu" display="lAddToSystemMenu"/>
		</VFPData>
	
	PROCEDURE addpad		&& Adds a pad to the menu
		lparameters tcClass, ;
			tcLibrary, ;
			tcName
		local loPad, ;
			lnCount, ;
			loOtherPad
		with This
		
		* Add a pad of the desired class and name to the menu.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				loPad = createobject(tcClass, tcName)
			else
				loPad = newobject(tcClass, tcLibrary, '', tcName)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
			loPad.oParent = This
			.AddProperty(tcName, loPad)
		
		* Add the pad to the collection.
		
			.Add(loPad, tcName)
			lnCount = .Count
			do case
		
		* If this is the second item in the menu, tell the first item to display BEFORE
		* this item and this item to display AFTER that item.
		
				case lnCount = 2
					loOtherPad = .Item(1)
					loOtherPad.cPadPosition = 'before ' + tcName
					loPad.cPadPosition = 'after ' + loOtherPad.Name
		
		* If there are more than 2 items in the menu, this item will be displayed AFTER
		* the previous one.
		
				case lnCount > 2
					loOtherPad = .Item(lnCount - 1)
					loPad.cPadPosition = 'after ' + loOtherPad.Name
			endcase
		endwith
		return loPad
		
	ENDPROC

	PROCEDURE cinstancename_assign
		lparameters tuValue
		if This.CalledFromThisClass()
			This.cInstanceName = tuValue
		else
			error 1743, 'cInstanceName'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE definemenu		&& Defines the desired pads in the menu
		* Abstract method
		
	ENDPROC

	PROCEDURE Init
		* Save the name of the variable or property we're being instantiated into in
		* cInstanceName. We need this so we can reference the object path from a bar
		* all the way up to the menu properly.
		
		lparameter tcInstanceName
		This.cInstanceName = tcInstanceName
		dodefault()
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the display of the menu.
		* Refresh the menu by refreshing all pads and then activating it.
		
		local lnI, ;
			loPad
		with This
			for lnI = 1 to .Count
				loPad = .Item(lnI)
				loPad.Refresh()
			next lnI
			activate menu (.cMenuName) nowait
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Release each pad so our reference in it is nuked.
		
		local lnI, ;
			loPad
		for lnI = This.Count to 1 step -1
			loPad = This.Item(lnI)
			loPad.Release()
		next lnI
		
		* Clean up the menu. 
		
		if This.cMenuName = '_msysmenu'
			pop menu _MSYSMENU
		endif This.cMenuName = '_msysmenu'
		
	ENDPROC

	PROCEDURE show		&& Displays the menu.
		local lnI, ;
			loPad
		with This
		
		* If we're putting the menu in a top-level form, set cMenuName and define the
		* menu in the specified form. Otherwise, clear the old menu.
		
			if empty(.cFormName) 
				if not .lAddToSystemMenu
			    	set sysmenu to
				endif not .lAddToSystemMenu
				push menu _MSYSMENU
			else 
				if .cMenuName = '_msysmenu'
					.cMenuName = sys(2015)
				endif .cMenuName = '_msysmenu'
				.Clear()
				define menu (.cMenuName) bar in (.cFormName)
			endif empty(.cFormName) 
		
		* Define the menu if it hasn't already been.
		
			if .Count = 0
				.DefineMenu()
			endif .Count = 0
		
		* Show all the pads.
		
			for lnI = 1 to .Count
				loPad = .Item(lnI)
				loPad.Show()
			next lnI
		
		* Display the menu.
		
			set sysmenu automatic
			activate menu (.cMenuName) nowait
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorermrubar AS projectexplorerbar OF "projectexplorermenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	cmenuclauses = mru
	conclickcommand = This.oParent.MRUSelected()
	Name = "projectexplorermrubar"

ENDDEFINE

DEFINE CLASS projectexplorerpad AS projectexplorercollection OF "projectexplorerctrls.vcx" 		&& A pad in a menu
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the popup for this pad
		*m: addbars		&& Add bars to the popup attached to this pad
		*m: addseparatorbar		&& Adds a separator bar to the menu
		*m: define		&& Defines the pad
		*m: definepad		&& Define the pad
		*m: definepopup		&& Defines the popup for the pad
		*m: hide		&& Hide the pad
		*m: lvisible_assign
		*m: mruselected		&& Called when the MRU bar is clicked
		*m: refresh		&& Refreshes the pad
		*m: show		&& Shows the pad
		*p: ccaption		&& The caption for the menu pad
		*p: cinstancename		&& The complete object path to this object starting from the menu object
		*p: ckey		&& The hotkey for the pad
		*p: cmrubarclass		&& The class to use for the MRU bar
		*p: cmrubarlibrary		&& The library containing the class specified in cMRUBarClass
		*p: cpadposition		&& Optional 'before' or 'after' pad clause to use in defining the pad's location on the menu
		*p: cpopupname		&& The name of the popup attached to this pad
		*p: cskipfor		&& The logical expression used for the SKIP FOR clause
		*p: cstatusbartext		&& Text displayed in the status bar when this pad is highlighted
		*p: ldefined		&& .T. if the pad and popup for this object have been defined
		*p: lmru		&& .T. to add an MRU bar at the bottom of the menu
		*p: lpaddefined		&& .T. if the pad has been defined
		*p: lvisible		&& .T. if the pad is visible
		*p: nseparatorbarcount		&& The number of separator bars in the menu
		*p: oparent		&& A reference to the parent for this pad
	*</DefinedPropArrayMethod>

	PROTECTED cpopupname,ldefined,lpaddefined,nseparatorbarcount
	ccaption = 		&& The caption for the menu pad
	cinstancename = 		&& The complete object path to this object starting from the menu object
	ckey = 		&& The hotkey for the pad
	cmrubarclass = projectexplorerMRUBar		&& The class to use for the MRU bar
	cmrubarlibrary = projectexplorerMenu.vcx		&& The library containing the class specified in cMRUBarClass
	cpadposition = 		&& Optional 'before' or 'after' pad clause to use in defining the pad's location on the menu
	cpopupname = 		&& The name of the popup attached to this pad
	cskipfor = 		&& The logical expression used for the SKIP FOR clause
	cstatusbartext = 		&& Text displayed in the status bar when this pad is highlighted
	ldefined = .F.		&& .T. if the pad and popup for this object have been defined
	lmru = .F.		&& .T. to add an MRU bar at the bottom of the menu
	lpaddefined = .F.		&& .T. if the pad has been defined
	lvisible = .T.		&& .T. if the pad is visible
	Name = "projectexplorerpad"
	nseparatorbarcount = 0		&& The number of separator bars in the menu
	oparent = .NULL.		&& A reference to the parent for this pad
	_memberdata = <VFPData>
		<memberdata name="addbar" type="method" display="AddBar"/>
		<memberdata name="addbars" type="method" display="AddBars" favorites="True"/>
		<memberdata name="addseparatorbar" type="method" display="AddSeparatorBar"/>
		<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
		<memberdata name="cinstancename" type="property" display="cInstanceName"/>
		<memberdata name="ckey" type="property" display="cKey" favorites="True"/>
		<memberdata name="cmrubarclass" type="property" display="cMRUBarClass"/>
		<memberdata name="cmrubarlibrary" type="property" display="cMRUBarLibrary"/>
		<memberdata name="cpadposition" type="property" display="cPadPosition"/>
		<memberdata name="cpopupname" type="property" display="cPopupName"/>
		<memberdata name="cskipfor" type="property" display="cSkipFor" favorites="True"/>
		<memberdata name="cstatusbartext" type="property" display="cStatusBarText" favorites="True"/>
		<memberdata name="define" type="method" display="Define"/>
		<memberdata name="definepad" type="method" display="DefinePad"/>
		<memberdata name="definepopup" type="method" display="DefinePopup"/>
		<memberdata name="hide" type="method" display="Hide"/>
		<memberdata name="ldefined" type="property" display="lDefined"/>
		<memberdata name="lmru" type="property" display="lMRU" favorites="True"/>
		<memberdata name="lpaddefined" type="property" display="lPadDefined"/>
		<memberdata name="lvisible" type="property" display="lVisible"/>
		<memberdata name="lvisible_assign" type="method" display="lVisible_Assign"/>
		<memberdata name="mruselected" type="method" display="MRUSelected"/>
		<memberdata name="nseparatorbarcount" type="property" display="nSeparatorBarCount"/>
		<memberdata name="refresh" type="method" display="Refresh"/>
		<memberdata name="show" type="method" display="Show"/>
		<memberdata name="init" type="event" favorites="True"/>
		<memberdata name="oparent" type="property" display="oParent"/>
		</VFPData>
	
	PROCEDURE addbar		&& Adds a bar to the popup for this pad
		lparameters tcClass, ;
			tcLibrary, ;
			tcName, ;
			tnBarNumber
		local lnBarNumber, ;
			llSpecified, ;
			loBar
		with This
		
		* Create a bar number if one wasn't passed.
		
			if vartype(tnBarNumber) = 'N' and tnBarNumber <> 0
				lnBarNumber = tnBarNumber
				llSpecified = .T.
			else
				lnBarNumber = .Count + 1
			endif vartype(tnBarNumber) = 'N' ...
		
		* Create the object as a member.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				loBar = createobject(tcClass, lnBarNumber, .cPopupName, tcName, ;
					llSpecified)
			else
				loBar = newobject(tcClass, tcLibrary, '', lnBarNumber, .cPopupName, ;
					tcName, llSpecified)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
			loBar.oParent = This
			.AddProperty(tcName, loBar)
		
		* Add the bar to the collection.
		
			.Add(loBar, tcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE addbars		&& Add bars to the popup attached to this pad
		* Abstract method
		
	ENDPROC

	PROCEDURE addseparatorbar		&& Adds a separator bar to the menu
		local lcName, ;
			loBar
		with This
			.nSeparatorBarCount = .nSeparatorBarCount + 1
			lcName = 'Separator' + transform(.nSeparatorBarCount)
			loBar  = .AddBar('ProjectExplorerSeparatorBar', 'ProjectExplorerMenu.vcx', ;
				lcName)
		endwith
		return loBar
		
	ENDPROC

	PROTECTED PROCEDURE define		&& Defines the pad
		with This
		
		* Get the object path and the names of the pad, menu, and popup.
		
			.cInstanceName = .oParent.cInstanceName + '.' + .Name
		
		* Create a default status bar text if we don't have one.
		
			if empty(.cStatusBarText)
				.cStatusBarText = strtran(strtran(.cCaption, '\<'), '\')
			endif empty(.cStatusBarText)
		
		* Define the pad and popup if necessary, then add bars to the popup.
		
			if not .lPadDefined
				.DefinePopup()
				.DefinePad()
			endif not .lPadDefined
			.AddBars()
		
		* If this is an MRU menu, add an MRU bar at the end.
		
			if .lMRU
				.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
			endif .lMRU
		
		* Flag that the pad and popup have been defined.
		
			.lDefined = .T.
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE definepad		&& Define the pad
		* Define the pad.
		
		local lcObjectPath, ;
			lcPadName, ;
			lcPopupName, ;
			lcPosition, ;
			lcSkipFor, ;
			lcClauses
		with This
			lcObjectPath = .cInstanceName + '.'
			lcPadName    = .Name
			lcPopupName  = .cPopupName
			lcPosition   = alltrim(.cPadPosition)
		
		* Set the SKIP FOR for the pad.
		
			if empty(.cSkipFor)
				lcSkipFor = ''
			else
				lcSkipFor = 'skip for ' + strtran(.cSkipFor, 'This.', lcObjectPath)
			endif not empty(.cSkipFor)
		
		* Set the key clauses of the DEFINE PAD command.
		
			lcClauses = ''
			if not empty(.cKey)
				lcClauses = lcClauses + ' key ' + strtran(.cKey, '"', "'")
			endif not empty(.cKey)
		
		* Define the pad.
		
			define pad &lcPadName of (.oParent.cMenuName) prompt .cCaption ;
				color scheme 3 &lcPosition &lcSkipFor message .cStatusBarText ;
				negotiate left, right &lcClauses
			on pad &lcPadName of (.oParent.cMenuName) activate popup &lcPopupName
		
		* Flag that the pad has been defined.
		
			.lPadDefined = .T.
		endwith
		
	ENDPROC

	PROCEDURE definepopup		&& Defines the popup for the pad
		define popup (This.cPopupName) margin relative shadow color scheme 4
		
	ENDPROC

	PROCEDURE hide		&& Hide the pad
		* Hide the pad by releasing it and its popup.
		
		local lcPadName, ;
			lcPopupName
		with This
			.lVisible    = .F.
			.lPadDefined = .F.
			lcPadName    = .Name
			lcPopupName = .cPopupName
			release pad &lcPadName of (.oParent.cMenuName)
			release popup &lcPopupName
		endwith
		
	ENDPROC

	PROCEDURE Init
		* Define the popup for this pad if it hasn't been already.
		
		lparameters tcName
		with This
			dodefault()
			if vartype(tcName) = 'C' and not empty(tcName)
				.Name = tcName
			endif vartype(tcName) = 'C' ...
			if empty(.cPopupName)
				.cPopupName = sys(2015)
			endif empty(.cPopupName)
		endwith
		
	ENDPROC

	PROCEDURE lvisible_assign
		lparameters tlValue
		assert vartype(tlValue) = 'L'
		with This
			if tlValue <> .lVisible
				.lVisible = tlValue
				do case
					case .CalledFromThisClass()
					case tlValue
						.Show()
					otherwise
						.Hide()
				endcase
			endif tlValue <> .lVisible
		endwith
		
	ENDPROC

	PROCEDURE mruselected		&& Called when the MRU bar is clicked
		local lnI, ;
			loBar, ;
			lcPopupName
		with This
		
		* Hide the MRU bar, then show all inverted bars.
		
			.MRUBar.Hide()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Show()
				endif loBar.lInvert
			next lnI
		
		* Display the popup again.
		
			lcPopupName = .cPopupName
			activate popup &lcPopupName
		
		* Now that the popup is closed, show the MRU bar and hide all inverted bars.
		
			.MRUBar.Show()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the pad
		* Refresh the pad by releasing and redefining the popup and refreshing each
		* bar.
		
		local lnI, ;
			loBar
		with This
			.Hide()
			.DefinePopup()
			.DefinePad()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				loBar.Refresh()
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Hide the pad. Release each bar so our reference in it is nuked and nuke our
		* own parent reference.
		
		local lcPopupName, ;
			lnI, ;
			loBar
		This.Hide()
		lcPopupName = This.cPopupName
		if popup(lcPopupName)
			release popup &lcPopupName
		endif popup(lcPopupName)
		for lnI = This.Count to 1 step -1
			loBar = This.Item(lnI)
			loBar.Release()
		next lnI
		This.oParent = .NULL.
		
	ENDPROC

	PROCEDURE show		&& Shows the pad
		* Define the popup and show all bars (except inverted bars, which must be
		* hidden).
		
		local lnI, ;
			loBar
		with This
			do case
		
		* If the pad has never been defined, call Define.
		
				case not .lDefined
					.Define()
		
		* If the pad has been defined but then released, call DefinePopup and
		* DefinePad.
		
				case not .lPadDefined
					.DefinePopup()
					.DefinePad()
			endcase
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				else
					loBar.Show()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectexplorerseparatorbar AS projectexplorerbar OF "projectexplorermenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \-
	Name = "projectexplorerseparatorbar"

ENDDEFINE

DEFINE CLASS projectexplorershortcutmenu AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorerctrls.h"
	*<DefinedPropArrayMethod>
		*m: addmenubar		&& Adds new menu bar to shortcut menu.
		*m: addmenuseparator		&& Adds separator to shortcut menu.
		*m: clearmenu		&& Releases existing shortcut menu.
		*m: editmenubar		&& Changes any setting for the specified bar
		*m: findbar		&& Returns the bar number for the specified prompt
		*m: nbarcount_access
		*m: nbarcount_assign
		*m: newmenu		&& Creates new menu popup for shortcut menu.
		*m: showmenu		&& Displays a shortcut menu
		*p: conselection		&& Menu bar selection routine.
		*p: nbarcount		&& The number of bars defined
		*p: ncol		&& The column for the menu (leave 0 to use the default)
		*p: nrow		&& The row for the menu (leave 0 to use the default)
		*a: amenu[1,0]
	*</DefinedPropArrayMethod>

	conselection = 		&& Menu bar selection routine.
	Name = "projectexplorershortcutmenu"
	nbarcount = 0		&& The number of bars defined
	ncol = 0		&& The column for the menu (leave 0 to use the default)
	nrow = 0		&& The row for the menu (leave 0 to use the default)
	_memberdata = <VFPData>
		<memberdata name="addmenubar" type="method" display="AddMenuBar"/>
		<memberdata name="addmenuseparator" type="method" display="AddMenuSeparator"/>
		<memberdata name="amenu" type="property" display="aMenu"/>
		<memberdata name="clearmenu" type="method" display="ClearMenu"/>
		<memberdata name="conselection" type="property" display="cOnSelection"/>
		<memberdata name="editmenubar" type="method" display="EditMenuBar"/>
		<memberdata name="findbar" type="method" display="FindBar"/>
		<memberdata name="nbarcount" type="property" display="nBarCount"/>
		<memberdata name="nbarcount_access" type="method" display="nBarCount_Access"/>
		<memberdata name="nbarcount_assign" type="method" display="nBarCount_Assign"/>
		<memberdata name="ncol" type="property" display="nCol"/>
		<memberdata name="newmenu" type="method" display="NewMenu"/>
		<memberdata name="nrow" type="property" display="nRow"/>
		<memberdata name="showmenu" display="ShowMenu"/>
		</VFPData>
	
	PROCEDURE addmenubar		&& Adds new menu bar to shortcut menu.
		lparameters tcPrompt, ;
			tcOnSelection, ;
			tlDisabled, ;
			tcImage, ;
			tnElementNumber, ;
			tlMark, ;
			tlBold, ;
			tcClauses, ;
			tcSystemBar
		local lnIndex, ;
			lnMenuCount, ;
			lnElementNumber
		assert vartype(tcPrompt) = 'O' or not empty(tcPrompt) ;
			message 'ProjectExplorerShortcutMenu.AddMenuBar: invalid tcPrompt'
		with This
		
		* If we were passed a reference to another menu, we'll create a submenu from
		* it.
		
			if vartype(tcPrompt) = 'O'
				for lnIndex = 1 to alen(tcPrompt.aMenu, 1)
					.AddMenuBar(tcPrompt.aMenu[lnIndex, 1], ;
						tcPrompt.aMenu[lnIndex, 2], tcPrompt.aMenu[lnIndex, 3])
				next lnIndex
		
		* Find the next open spot in the menu array.
		
			else
				lnMenuCount = alen(.aMenu, 1)
				lnMenuCount = iif(lnMenuCount = 1 and empty(.aMenu[1]), 0, ;
					lnMenuCount) + 1
				lnIndex = lnMenuCount
				dimension .aMenu[lnIndex, 8]
		
		* If the menu item number was passed, we'll add the menu item at that spot in
		* the menu.
		
				if vartype(tnElementNumber) = 'N' and tnElementNumber > 0
					lnElementNumber = max(int(tnElementNumber), 1)
					if lnElementNumber < lnMenuCount
						if ains(.aMenu, lnElementNumber) = 1
							lnIndex = lnElementNumber
						endif ains(.aMenu, lnElementNumber) = 1
					endif lnElementNumber < lnMenuCount
				endif vartype(tnElementNumber) = 'N' ...
		
		* Put the menu item information into the array.
		
				.aMenu[lnIndex, 1] = tcPrompt
				.aMenu[lnIndex, 2] = tcOnSelection
				.aMenu[lnIndex, 3] = tcClauses
				.aMenu[lnIndex, 4] = transform(tlMark)
				.aMenu[lnIndex, 5] = transform(tlDisabled)
				.aMenu[lnIndex, 6] = transform(tlBold)
				.aMenu[lnIndex, 7] = tcImage
				.aMenu[lnIndex, 8] = tcSystemBar
			endif vartype(tcPrompt) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE addmenuseparator		&& Adds separator to shortcut menu.
		lparameters tnElementNumber
		This.AddMenuBar('\-', , , , tnElementNumber)
		
	ENDPROC

	PROCEDURE clearmenu		&& Releases existing shortcut menu.
		with This
			dimension .aMenu[1]
			.aMenu        = ''
			.cOnSelection = ''
		endwith
		
	ENDPROC

	PROCEDURE editmenubar		&& Changes any setting for the specified bar
		lparameters tnBar, ;
			tcPrompt, ;
			tcOnSelection, ;
			tcClauses, ;
			tcMark, ;
			tcDisabled, ;
			tcBold, ;
			tcImage, ;
			tcSystemBar
		local lcPrompt, ;
			lcOnSelection, ;
			lcClauses, ;
			lcMark, ;
			lcDisabled, ;
			lcBold, ;
			lcImage, ;
			lcSystemBar
		with This
			assert vartype(tnBar) $ 'NFIBY' and between(tnBar, 1, .nBarCount)
		
		* Get either the existing or the new value, depending on what was passed.
		
			lcPrompt      = iif(vartype(tcPrompt)      = 'C' and ;
				not empty(tcPrompt),      tcPrompt,      .aMenu[tnBar, 1])
			lcOnSelection = iif(vartype(tcOnSelection) = 'C' and ;
				not empty(tcOnSelection), tcOnSelection, .aMenu[tnBar, 2])
			lcClauses     = iif(vartype(tcClauses)     = 'C' and ;
				not empty(tcClauses),     tcClauses,     .aMenu[tnBar, 3])
			lcMark        = iif(vartype(tcMark)        = 'C' and ;
				not empty(tcMark),        tcMark,        .aMenu[tnBar, 4])
			lcDisabled    = iif(vartype(tcDisabled)    = 'C' and ;
				not empty(tcDisabled),    tcDisabled,    .aMenu[tnBar, 5])
			lcBold        = iif(vartype(tcBold)        = 'C' and ;
				not empty(tcBold),        tcBold,        .aMenu[tnBar, 6])
			lcImage       = iif(vartype(tcImage)       = 'C' and ;
				not empty(tcImage),       tcImage,       .aMenu[tnBar, 7])
			lcSystemBar   = iif(vartype(tcSystemBar)   = 'C' and ;
				not empty(tcSystemBar),   tcSystemBar,   .aMenu[tnBar, 8])
		
		* Put the values into the array
		
			.aMenu[tnBar, 1] = lcPrompt
			.aMenu[tnBar, 2] = lcOnSelection
			.aMenu[tnBar, 3] = lcClauses
			.aMenu[tnBar, 4] = lcMark
			.aMenu[tnBar, 5] = lcDisabled
			.aMenu[tnBar, 6] = lcBold
			.aMenu[tnBar, 7] = lcImage
			.aMenu[tnBar, 8] = lcSystemBar
		endwith
		
	ENDPROC

	PROCEDURE findbar		&& Returns the bar number for the specified prompt
		lparameters tcPrompt
		local lcPrompt, ;
			lnBar, ;
			lnI
		with This
			lcPrompt = upper(alltrim(tcPrompt))
			lnBar    = 0
			for lnI = 1 to .nBarCount
				if upper(strtran(strtran(.aMenu[lnI, 1], '\<'), '^')) == lcPrompt
					lnBar = lnI
					exit
				endif upper(strtran(strtran(.aMenu[lnI, 1], '\<'), '^')) == lcPrompt
			next lnI
		endwith
		return lnBar
		
	ENDPROC

	PROCEDURE Init
		* Start with an empty menu array.
		
		This.ClearMenu()
		
	ENDPROC

	PROCEDURE nbarcount_access
		return iif(empty(This.aMenu[1]) or isnull(This.aMenu[1]), 0, ;
			alen(This.aMenu, 1))
		
	ENDPROC

	PROCEDURE nbarcount_assign
		error 1743, 'nBarCount'
		
	ENDPROC

	PROCEDURE newmenu		&& Creates new menu popup for shortcut menu.
		lparameters toObject
		local loObject, ;
			lcClass, ;
			lcClassLibrary, ;
			lcBaseClass, ;
			loNewObject
		loObject       = iif(vartype(toObject) = 'O', toObject, This)
		lcClass        = lower(loObject.Class)
		lcClassLibrary = lower(loObject.ClassLibrary)
		lcBaseClass    = lower(loObject.BaseClass)
		if empty(lcClassLibrary)
			loNewObject = createobject(lcBaseClass)
		else
			loNewObject = newobject(lcClass, lcClassLibrary)
		endif empty(lcClassLibrary)
		return loNewObject
		
	ENDPROC

	PROCEDURE showmenu		&& Displays a shortcut menu
		lparameters tcParentMenu
		local lnMenuCount, ;
			loForm, ;
			lcWindow, ;
			lcWindowClause, ;
			lcMenu, ;
			llPosition, ;
			lnMRow, ;
			lnMCol, ;
			lnSkipCount, ;
			lnCount, ;
			lcMenuItem, ;
			luBar, ;
			llMacro, ;
			lcClauses, ;
			lcImage, ;
			llSetMark, ;
			lcMenu2, ;
			luMenuSelection
		with This
		
		* Get the number of bars in the menu. Only display the menu if it isn't empty.
		
			lnMenuCount = alen(.aMenu, 1)
			if vartype(.aMenu[1]) = 'C' and (lnMenuCount > 1 or not empty(.aMenu[1]))
		
		* Set the window to appear in.
		
				if type('_screen.ActiveForm.Name') = 'C'
					loForm = _screen.ActiveForm
				endif type('_screen.ActiveForm.Name') = 'C'
				if vartype(loForm) = 'O'
					lcWindow       = loForm.Name
					lcWindowClause = 'in window ' + lcWindow
				else
					lcWindow       = ''
					lcWindowClause = ''
				endif vartype(loForm) = 'O'
		
		* If we were passed the name of the parent menu, use it. Otherwise, create a
		* new menu name. Deactivate the menu and create a new popup if necessary.
		
				lcMenu = iif(empty(tcParentMenu), sys(2015), alltrim(tcParentMenu))
				deactivate popup (lcMenu)
				clear typeahead
				if empty(tcParentMenu)
					llPosition = .nRow <> 0 or .nCol <> 0
					if empty(lcWindow)
						lnMRow = iif(llPosition, .nRow, max(mrow(), 0))
						lnMCol = iif(llPosition, .nCol, max(mcol(), 0))
					else
						lnMRow = iif(llPosition, .nRow, max(mrow(lcWindow), 0))
						lnMCol = iif(llPosition, .nCol, max(mcol(lcWindow), 0))
					endif empty(lcWindow)
					define popup (lcMenu) from lnMRow, lnMCol &lcWindowClause margin ;
						shortcut
					on selection popup (lcMenu) deactivate menu (lcMenu)
				endif empty(tcParentMenu)
		
		* Add a bar for each menu item to the popup.
		
				lnSkipCount = 0
				for lnCount = 1 to lnMenuCount
					lcMenuItem = .aMenu[lnCount, 1]
					if left(lcMenuItem, 1) = '{'
						lcMenuItem = evaluate(substr(lcMenuItem, 2, len(lcMenuItem) - 2))
					endif left(lcMenuItem, 1) = '{'
		
		* If the item is empty or the first bar or last item is a separator, skip this
		* item.
		
					if vartype(lcMenuItem) <> 'C' or empty(lcMenuItem) or ;
						((lnCount = 1 or lnCount = lnMenuCount) and ;
						alltrim(lcMenuItem) = '\-')
						lnSkipCount = lnSkipCount + 1
						loop
					endif vartype(lcMenuItem) <> 'C' ...
		
		* Handle system bars.
		
					if not empty(.aMenu[lnCount, 8])
						luBar       = .aMenu[lnCount, 8]
						llMacro     = .T.
						lnSkipCount = lnSkipCount + 1
					else
						luBar   = lnCount - lnSkipCount
						llMacro = .F.
					endif not empty(.aMenu[lnCount, 8])
		
		* Set the clauses appropriately.
		
					if not empty(.aMenu[lnCount, 3])
						lcClauses = alltrim(.aMenu[lnCount, 3])
					else
						lcClauses = ''
					endif not empty(.aMenu[lnCount, 3])
		
		* Evaluate the mark expression (if there is one) and set the mark appropriately.
		
					if not empty(.aMenu[lnCount, 4]) and evaluate(.aMenu[lnCount, 4])
						lcMenuItem = '^' + lcMenuItem
					endif not empty(this.aMenu[lnCount, 4]) ...
		
		* Evaluate the SKIP FOR expression (if there is one) and set the clauses
		* appropriately.
		
					if not empty(.aMenu[lnCount, 5]) and evaluate(.aMenu[lnCount, 5])
						lcClauses = lcClauses + [ SKIP FOR .T.]
					endif not empty(.aMenu[lnCount, 6]) ...
		
		* Evaluate the "bold" expression (if there is one) and set the clauses
		* appropriately.
		
					if not empty(.aMenu[lnCount, 6]) and evaluate(.aMenu[lnCount, 6])
						lcClauses = lcClauses + [ STYLE "B"]
					endif not empty(.aMenu[lnCount, 6]) ...
		
		* Evaluate the image expression (if there is one) and set the clauses
		* appropriately.
		
					if not empty(.aMenu[lnCount, 7])
						lcImage = .aMenu[lnCount, 7]
						if lcImage = '_'
							lcClauses = lcClauses + ' pictres ' + lcImage
						else
							lcClauses = lcClauses + ' picture "' + lcImage + '"'
						endif lcImage = '_'
					endif not empty(.aMenu[lnCount, 7])
		
		* Handle the mark being turned on for the item.
		
					llSetMark = left(lcMenuItem,1) = '^'
					if llSetMark
						lcMenuItem = substr(lcMenuItem,2)
					endif llSetMark
		
		* Define the bar and set the mark if necessary.
		
					do case
						case empty(lcClauses) and llMacro
							define bar &luBar of (lcMenu) prompt (lcMenuItem)
						case empty(lcClauses)
							define bar luBar  of (lcMenu) prompt (lcMenuItem)
						case llMacro
							define bar &luBar of (lcMenu) prompt (lcMenuItem) ;
								&lcClauses
						otherwise
							define bar luBar  of (lcMenu) prompt (lcMenuItem) ;
								&lcClauses
					endcase
					if llSetMark
						set mark of bar luBar of (lcMenu) to .T.
					endif llSetMark
		
		* If this is a submenu, handle it.
		
					luMenuSelection = .aMenu[lnCount, 2]
					if vartype(luMenuSelection) = 'O'
						lcMenu2 = sys(2015)
						define popup (lcMenu2) margin shortcut
						on selection popup (lcMenu2) deactivate menu (lcMenu2)
						on bar lnBar of (lcMenu) activate popup (lcMenu2)
						if empty(luMenuSelection.cOnSelection)
							luMenuSelection.cOnSelection = .cOnSelection
						endif empty(luMenuSelection.cOnSelection)
						luMenuSelection.ShowMenu(lcMenu2)
						loop
					endif vartype(luMenuSelection) = 'O'
		
		* If no action was specified, use the overall one for the menu.
		
					luMenuSelection = iif(empty(luMenuSelection), ;
						alltrim(.cOnSelection), luMenuSelection)
					do case
						case empty(luMenuSelection)
						case llMacro
							on selection bar &luBar of (lcMenu) &luMenuSelection
						otherwise
							on selection bar luBar  of (lcMenu) &luMenuSelection
					endcase
				next lnCount
		
		* If there are no menu items, we're done. Otherwise, activate the menu.
		
				if lnSkipCount < lnMenuCount and empty(tcParentMenu)
					activate popup (lcMenu)
					if not empty(lcMenu)
						deactivate popup (lcMenu)
						release popup (lcMenu) extended
					endif not empty(lcMenu)
				endif lnSkipCount < lnMenuCount ...
			endif vartype(.aMenu[1]) = 'C' ...
		endwith
		
	ENDPROC

ENDDEFINE
