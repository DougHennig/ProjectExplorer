*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="projectexploreritems.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS projectitem AS projectexplorercustom OF "projectexplorerctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	*<DefinedPropArrayMethod>
		*m: canedit_access
		*m: canrun_access
		*m: clone		&& Creates a clone of the object
		*m: designercaption_access
		*m: edititem		&& Edits the item
		*m: executefile		&& Opens a file in the application it's associated with
		*m: getproperties		&& Gets the properties for the item
		*m: hasdescription_access
		*m: isbinary_access
		*m: isnamevalid		&& Returns .T. if the name of the item is valid
		*m: newitem		&& Creates a new item of this type
		*m: removeitem		&& Removes the item
		*m: renameitem		&& Renames the item
		*m: runitem		&& Runs the item
		*m: saveitem		&& Saves the item's properties
		*m: treeviewimage_access
		*m: updatefromclone		&& Updates the properties of this object from the specified clone
		*p: canedit		&& .T. if the item can be edited
		*p: caninclude		&& .T. if the item can be included in the project
		*p: canremove		&& .T. if the item can be removed
		*p: canrename		&& .T. if the item can be renamed
		*p: canrun		&& .T. if the item can be run
		*p: cansetmain		&& .T. if the item can be the main file in a project
		*p: categoryid		&& The category ID for the item
		*p: categoryname		&& The category name for the item
		*p: changeswritten		&& .T. if changes were written to the file when SaveItem is called (that is, the item's properties were different than the file)
		*p: checksum		&& The checksum for the file contents before it's edited
		*p: classchanged		&& .T. if a property of a class changed
		*p: codepage		&& The code page for the file
		*p: defaulttags		&& The default tags to use for this item
		*p: description		&& The item description
		*p: designercaption		&& The caption of the item's designer
		*p: exclude		&& .T. if the item is excluded from the project
		*p: haschildren		&& .T. if the item has child items
		*p: hasdescription		&& .T. if the item has a description
		*p: hasparent		&& .T. if the item has a parent item
		*p: hasuser		&& .T. if the item has User information
		*p: icon		&& A custom icon for a class
		*p: includefile		&& The include file for the item
		*p: isbinary		&& .T. if this is a VFP binary file
		*p: isfile		&& .T. if the item is a file
		*p: itembaseclass		&& The base class of the item
		*p: itemclass		&& The class a form is based on
		*p: itemlibrary		&& The library containing the class specified in ItemClass
		*p: itemname		&& The name of the item
		*p: itemparentclass		&& The parent class for the item
		*p: itemparentlibrary		&& The library containing the class specified in ItemParentClass
		*p: key		&& The key for this item in the meta data table
		*p: lastmodified		&& When the item was last modified
		*p: mainfile		&& .T. if this is the main file in the project
		*p: new		&& .T. if this is a new item
		*p: olepublic		&& .T. if the class is OLEPublic
		*p: originaldescription		&& The item description before it was edited
		*p: originalexclude		&& The value of Exclude before it was edited
		*p: originalmainfile		&& The value of MainFile before it was edited
		*p: originaluser		&& The value of User before it was edited
		*p: parentkey		&& The key of the parent item for this item
		*p: parentpath		&& The path for the database if applicable
		*p: parenttype		&& The type of the parent object for this item
		*p: path		&& The path for the file
		*p: project		&& The project the item belongs to
		*p: readonly		&& .T. if the file is read-only
		*p: reloadafteredit		&& .T. if the item needs to be reloaded after editing
		*p: removeprompt		&& The prompt when removing the item
		*p: scalemode		&& The scale mode of a class
		*p: tags		&& A comma-delimited list of tags for the item
		*p: toolbaricon		&& The toolbar icon for a class
		*p: treeviewimage		&& The image to use in the TreeView
		*p: type		&& The type of item
		*p: typename		&& The descriptive name for the type
		*p: user		&& User-defined information for the item
		*p: versioncontrolstatus		&& The version control status
	*</DefinedPropArrayMethod>

	canedit = .F.		&& .T. if the item can be edited
	caninclude = .F.		&& .T. if the item can be included in the project
	canremove = .F.		&& .T. if the item can be removed
	canrename = .F.		&& .T. if the item can be renamed
	canrun = .F.		&& .T. if the item can be run
	cansetmain = .F.		&& .T. if the item can be the main file in a project
	categoryid = 0		&& The category ID for the item
	categoryname = 		&& The category name for the item
	changeswritten = .F.		&& .T. if changes were written to the file when SaveItem is called (that is, the item's properties were different than the file)
	checksum = 		&& The checksum for the file contents before it's edited
	classchanged = .F.		&& .T. if a property of a class changed
	codepage = 		&& The code page for the file
	defaulttags = 		&& The default tags to use for this item
	description = 		&& The item description
	designercaption = 		&& The caption of the item's designer
	exclude = .F.		&& .T. if the item is excluded from the project
	haschildren = .F.		&& .T. if the item has child items
	hasdescription = .T.		&& .T. if the item has a description
	hasparent = .F.		&& .T. if the item has a parent item
	hasuser = .F.		&& .T. if the item has User information
	icon = 		&& A custom icon for a class
	includefile = 		&& The include file for the item
	isbinary = .F.		&& .T. if this is a VFP binary file
	isfile = .F.		&& .T. if the item is a file
	itembaseclass = 		&& The base class of the item
	itemclass = 		&& The class a form is based on
	itemlibrary = 		&& The library containing the class specified in ItemClass
	itemname = 		&& The name of the item
	itemparentclass = 		&& The parent class for the item
	itemparentlibrary = 		&& The library containing the class specified in ItemParentClass
	key = 		&& The key for this item in the meta data table
	lastmodified = {}		&& When the item was last modified
	mainfile = .F.		&& .T. if this is the main file in the project
	Name = "projectitem"
	new = .F.		&& .T. if this is a new item
	olepublic = .F.		&& .T. if the class is OLEPublic
	originaldescription = 		&& The item description before it was edited
	originalexclude = .F.		&& The value of Exclude before it was edited
	originalmainfile = .F.		&& The value of MainFile before it was edited
	originaluser = 		&& The value of User before it was edited
	parentkey = 		&& The key of the parent item for this item
	parentpath = 		&& The path for the database if applicable
	parenttype = 		&& The type of the parent object for this item
	path = 		&& The path for the file
	project = 		&& The project the item belongs to
	readonly = .F.		&& .T. if the file is read-only
	reloadafteredit = .F.		&& .T. if the item needs to be reloaded after editing
	removeprompt = 		&& The prompt when removing the item
	scalemode = 		&& The scale mode of a class
	tags = 		&& A comma-delimited list of tags for the item
	toolbaricon = 		&& The toolbar icon for a class
	treeviewimage = 		&& The image to use in the TreeView
	type = 		&& The type of item
	typename = 		&& The descriptive name for the type
	user = 		&& User-defined information for the item
	versioncontrolstatus = 		&& The version control status
	_memberdata = <VFPData>
		<memberdata name="description" type="property" display="Description"/>
		<memberdata name="type" type="property" display="Type"/>
		<memberdata name="itemname" type="property" display="ItemName"/>
		<memberdata name="itembaseclass" type="property" display="ItemBaseClass"/>
		<memberdata name="path" type="property" display="Path"/>
		<memberdata name="key" type="property" display="Key"/>
		<memberdata name="itemclass" type="property" display="ItemClass"/>
		<memberdata name="itemlibrary" type="property" display="ItemLibrary"/>
		<memberdata name="exclude" type="property" display="Exclude"/>
		<memberdata name="lastmodified" type="property" display="LastModified"/>
		<memberdata name="isfile" type="property" display="IsFile"/>
		<memberdata name="tags" type="property" display="Tags"/>
		<memberdata name="itemparentclass" type="property" display="ItemParentClass"/>
		<memberdata name="itemparentlibrary" type="property" display="ItemParentLibrary"/>
		<memberdata name="includefile" display="IncludeFile"/>
		<memberdata name="olepublic" display="OLEPublic"/>
		<memberdata name="parenttype" display="ParentType"/>
		<memberdata name="caninclude" display="CanInclude"/>
		<memberdata name="hasdescription" display="HasDescription"/>
		<memberdata name="canrename" display="CanRename"/>
		<memberdata name="mainfile" display="MainFile"/>
		<memberdata name="originaldescription" display="OriginalDescription"/>
		<memberdata name="cansetmain" display="CanSetMain"/>
		<memberdata name="canedit" display="CanEdit"/>
		<memberdata name="canedit_access" display="CanEdit_Access"/>
		<memberdata name="canrun" display="CanRun"/>
		<memberdata name="parentpath" display="ParentPath"/>
		<memberdata name="user" display="User"/>
		<memberdata name="originaluser" display="OriginalUser"/>
		<memberdata name="versioncontrolstatus" display="VersionControlStatus"/>
		<memberdata name="icon" display="Icon"/>
		<memberdata name="toolbaricon" display="ToolbarIcon"/>
		<memberdata name="icon_assign" display="Icon_Assign"/>
		<memberdata name="classchanged" display="ClassChanged"/>
		<memberdata name="canremove" display="CanRemove"/>
		<memberdata name="clone" display="Clone"/>
		<memberdata name="updatefromclone" display="UpdateFromClone"/>
		<memberdata name="treeviewimage" display="TreeViewImage"/>
		<memberdata name="treeviewimage_access" display="TreeViewImage_Access"/>
		<memberdata name="removeitem" display="RemoveItem"/>
		<memberdata name="runitem" display="RunItem"/>
		<memberdata name="canrun_access" display="CanRun_Access"/>
		<memberdata name="edititem" display="EditItem"/>
		<memberdata name="executefile" display="ExecuteFile"/>
		<memberdata name="designercaption" display="DesignerCaption"/>
		<memberdata name="designercaption_access" display="DesignerCaption_Access"/>
		<memberdata name="removeprompt" display="RemovePrompt"/>
		<memberdata name="defaulttags" display="DefaultTags"/>
		<memberdata name="saveitem" display="SaveItem"/>
		<memberdata name="originalmainfile" display="OriginalMainFile"/>
		<memberdata name="getproperties" display="GetProperties"/>
		<memberdata name="project" display="Project"/>
		<memberdata name="hasdescription_access" display="HasDescription_Access"/>
		<memberdata name="codepage" display="CodePage"/>
		<memberdata name="readonly" display="ReadOnly"/>
		<memberdata name="newitem" display="NewItem"/>
		<memberdata name="new" display="New"/>
		<memberdata name="haschildren" display="HasChildren"/>
		<memberdata name="reloadafteredit" display="ReloadAfterEdit"/>
		<memberdata name="parentkey" display="ParentKey"/>
		<memberdata name="hasparent" display="HasParent"/>
		<memberdata name="typename" display="TypeName"/>
		<memberdata name="originalexclude" display="OriginalExclude"/>
		<memberdata name="hasuser" display="HasUser"/>
		<memberdata name="scalemode" display="ScaleMode"/>
		<memberdata name="isnamevalid" display="IsNameValid"/>
		<memberdata name="renameitem" display="RenameItem"/>
		<memberdata name="isbinary" display="IsBinary"/>
		<memberdata name="isbinary_access" display="IsBinary_Access"/>
		<memberdata name="checksum" display="Checksum"/>
		<memberdata name="changeswritten" display="ChangesWritten"/>
		<memberdata name="categoryname" display="CategoryName"/>
		<memberdata name="categoryid" display="CategoryID"/>
		</VFPData>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ProjectItem
		* Based On:						ProjectExplorerCustom
		* Purpose:						Contains properties for an item in a project
		* Author:						Doug Hennig
		* Last revision:				12/08/2017
		* Include file:					ProjectExplorer.h
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	About:						provides documentation for the class
		*	Init:						sets up the object
		*	ReleaseMembers:				nukes the oProject member
		*
		* Custom public properties added:
		*	CanEdit:					.T. if the item can be edited (has Access
		*								method)
		*	CanInclude:					.T. if the item can be included in the project
		*	CanRename:					.T. if the item can be renamed
		*	CanRemove:					.T. if the item can be removed
		*	CanRun:						.T. if the item can be run (has Access method)
		*	CanSetMain:					.T. if the item can be the main file in a
		*								project
		*	CategoryID:					The category ID for the item
		*	CategoryName:				The category name for the item
		*	ChangesWritten:				.T. if changes were written to the file when
		*								SaveItem is called (that is, the item's
		*								properties were different than the file)
		*	Checksum:					The checksum for the file contents before it's
		*								edited
		*	ClassChanged:				.T. if a property of a class changed
		*	CodePage:					The code page for the file
		*	DefaultTags:				The default tags to use for this item
		*	Description:				The item description
		*	DesignerCaption:			The caption of the item's designer (has Access
		*								method)
		*	Exclude:					.T. if the item is excluded from the project
		*	HasChildren:				.T. if the item has child items
		*	HasDescription:				.T. if the item has a description (has Access
		*								method)
		*	HasParent:					.T. if the item has a parent item
		*	HasUser:					.T. if the item has User information
		*	Icon:						A custom icon for a class
		*	IncludeFile:				The include file for the item
		*	IsBinary:					.T. if this is a VFP binary file
		*	IsFile:						.T. if the item is a file
		*	ItemBaseClass:				The base class of the item
		*	ItemClass:					The class a form is based on
		*	ItemLibrary:				The library containing the class specified in
		*								ItemClass
		*	ItemName:					The name of the item
		*	ItemParentClass:			The parent class for the item
		*	ItemParentLibrary:			The library containing the class specified in
		*								ItemParentClass
		*	Key:						The key for this item in the meta data table
		*	LastModified:				When the item was last modified
		*	MainFile:					.T. if this is the main file in the project
		*	New:						.T. if this is a new item
		*	OLEPublic:					.T. if the class is OLEPublic
		*	OriginalDescription:		The item description before it was edited
		*	OriginalExclude:			The value of Exclude before it was edited
		*	OriginalMainFile:			The value of MainFile before it was edited
		*	OriginalUser:				The value of User before it was edited
		*	ParentKey:					The key of the parent object for this item
		*	ParentPath:					The path for the database if applicable
		*	ParentType:					The type of the parent object for this item
		*	Path:						The path for the file
		*	Project:					The project the item belongs to
		*	ReadOnly:					.T. if the file is read-only
		*	ReloadAfterEdit:			.T. if the item needs to be reloaded after
		*								editing
		*	RemovePrompt:				The prompt when removing the item
		*	ScaleMode:					The scale mode of a class
		*	Tags:						A comma-delimited list of tags for the item
		*	ToolbarIcon:				The toolbar icon for a class
		*	TreeViewImage:				The image to use in the TreeView
		*	Type:						The type of item
		*	TypeName:					The descriptive name for the type
		*	User:						User-defined information for the item
		*	VersionControlStatus:		The version control status:
		*									I = ignored
		*									M = modified
		*									A = added
		*									R = removed
		*									C = clean
		*									! = missing
		*									? = not tracked
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	Clone:						Creates a clone of the object
		*	EditItem:					Edits the item
		*	ExecuteFile:				Opens a file in the application it's associated
		*								with
		*	GetProperties:				Gets the properties for the item
		*	IsNameValid:				Returns .T. if the name of the item is valid
		*	NewItem:					Creates a new item of this type
		*	RemoveItem:					Removes the item
		*	RenameItem:					Renames the item
		*	RunItem:					Runs the item
		*	SaveItem:					Saves the item's properties
		*	UpdateFromClone:			Updates the properties of this object from the
		*								specified clone
		*
		* Custom protected methods added:
		*	none
		*==============================================================================
		
	ENDPROC

	PROCEDURE canedit_access
		return This.CanEdit
		
	ENDPROC

	PROCEDURE canrun_access
		return This.CanRun
		
	ENDPROC

	PROCEDURE clone		&& Creates a clone of the object
		*==============================================================================
		* Method:			Clone
		* Status:			Public
		* Purpose:			Creates a clone of the object
		* Author:			Doug Hennig
		* Last Revision:	12/08/2017
		* Parameters:		none
		* Returns:			a clone of this object
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local loItem
		loItem = newobject(This.Class, This.ClassLibrary)
		CopyProperties(This, loItem)
		return loItem
		 
	ENDPROC

	PROCEDURE designercaption_access
		return This.DesignerCaption
		
	ENDPROC

	PROCEDURE edititem		&& Edits the item
		*==============================================================================
		* Method:			EditItem
		* Status:			Public
		* Purpose:			Edits the item
		* Author:			Doug Hennig
		* Last Revision:	03/20/2017
		* Parameters:		toProject - a reference to the project
		* Returns:			.T. if it succeeded
		* Environment in:	depends on the specific item
		* Environment out:	depends on the specific item
		*==============================================================================
		
		* Abstract method.
		
		lparameters toProject
		
	ENDPROC

	PROCEDURE executefile		&& Opens a file in the application it's associated with
		*==============================================================================
		* Method:			ExecuteFile
		* Status:			Public
		* Purpose:			Opens a file in the application it's associated with
		* Author:			Doug Hennig
		* Last Revision:	03/20/2017
		* Parameters:		tcFileName   - the filename to open
		*					tcOperation  - the operation to perform (optional: if it
		*						isn't specified, "Open" is used)
		* Returns:			see ExecuteFile.prg
		* Environment in:	see ExecuteFile.prg
		* Environment out:	see ExecuteFile.prg
		*==============================================================================
		
		lparameters tcFileName, ;
			tcOperation
		return ExecuteFile(tcFileName, tcOperation)
		
	ENDPROC

	PROCEDURE getproperties		&& Gets the properties for the item
		*==============================================================================
		* Method:			GetProperties
		* Status:			Public
		* Purpose:			Gets the properties for the item
		* Author:			Doug Hennig
		* Last Revision:	03/21/2017
		* Parameters:		depends on the specific item
		* Returns:			.T. if it succeeded
		* Environment in:	depends on the specific item
		* Environment out:	depends on the specific item
		*==============================================================================
		
		* Abstract method.
		
		lparameters toProject
		
	ENDPROC

	PROCEDURE hasdescription_access
		return This.HasDescription
		
	ENDPROC

	PROCEDURE isbinary_access
		return This.IsBinary
		
	ENDPROC

	PROCEDURE isnamevalid		&& Returns .T. if the name of the item is valid
		*==============================================================================
		* Method:			IsNameValid
		* Status:			Public
		* Purpose:			Returns .T. if the name of the item is valid
		* Author:			Doug Hennig
		* Last Revision:	04/18/2017
		* Parameters:		tcName - the name to use for the item
		* Returns:			.T. if the name if valid
		* Environment in:	depends on the specific item
		* Environment out:	depends on the specific item
		*==============================================================================
		
		* Abstract method.
		
		lparameters tcName
		
	ENDPROC

	PROCEDURE newitem		&& Creates a new item of this type
		*==============================================================================
		* Method:			NewItem
		* Status:			Public
		* Purpose:			Creates a new item of this type
		* Author:			Doug Hennig
		* Last Revision:	03/24/2017
		* Parameters:		none
		* Returns:			none
		* Environment in:	depends on the specific item
		* Environment out:	depends on the specific item
		*==============================================================================
		
		* Abstract method.
		
	ENDPROC

	PROCEDURE removeitem		&& Removes the item
		*==============================================================================
		* Method:			RemoveItem
		* Status:			Public
		* Purpose:			Removes the item
		* Author:			Doug Hennig
		* Last Revision:	03/20/2017
		* Parameters:		toProject - a reference to the project
		*					tlDelete  - .T. to delete the file
		* Returns:			.T. if it succeeded
		* Environment in:	depends on the specific item
		* Environment out:	depends on the specific item
		*==============================================================================
		
		* Abstract method.
		
		lparameters toProject, ;
			tlDelete
		
	ENDPROC

	PROCEDURE renameitem		&& Renames the item
		*==============================================================================
		* Method:			RenameItem
		* Status:			Public
		* Purpose:			Renames the item
		* Author:			Doug Hennig
		* Last Revision:	04/18/2017
		* Parameters:		toProject - a reference to the project
		*					tcNewName - the new name for the item
		* Returns:			.T. if it succeeded
		* Environment in:	depends on the specific item
		* Environment out:	depends on the specific item
		*==============================================================================
		
		* Abstract method.
		
		lparameters toProject, ;
			tcNewName
		
	ENDPROC

	PROCEDURE runitem		&& Runs the item
		\*==============================================================================
		* Method:			RunItem
		* Status:			Public
		* Purpose:			Runs the item
		* Author:			Doug Hennig
		* Last Revision:	03/20/2017
		* Parameters:		toProject - a reference to the project
		* Returns:			.T. if it succeeded
		* Environment in:	depends on the specific item
		* Environment out:	depends on the specific item
		*==============================================================================
		
		* Abstract method.
		
		lparameters toProject
		
	ENDPROC

	PROCEDURE saveitem		&& Saves the item's properties
		*==============================================================================
		* Method:			SaveItem
		* Status:			Public
		* Purpose:			Saves the item's properties
		* Author:			Doug Hennig
		* Last Revision:	03/20/2017
		* Parameters:		toProject - a reference to the project
		* Returns:			.T. if it succeeded
		* Environment in:	depends on the specific item
		* Environment out:	depends on the specific item
		*==============================================================================
		
		* Abstract method.
		
		lparameters toProject
		
	ENDPROC

	PROCEDURE treeviewimage_access
		return This.TreeViewImage
		
	ENDPROC

	PROCEDURE updatefromclone		&& Updates the properties of this object from the specified clone
		*==============================================================================
		* Method:			UpdateFromClone
		* Status:			Public
		* Purpose:			Updates the properties of this object from the specified
		*						clone
		* Author:			Doug Hennig
		* Last Revision:	12/08/2017
		* Parameters:		toItem - the clone to copy properties from
		* Returns:			.T. if it succeeded
		* Environment in:	none
		* Environment out:	this object's properties have the same values as the
		*						clone's
		*==============================================================================
		
		lparameters toItem
		
		* Ensure a valid object was passed.
		
		if type('toItem.Class') <> 'C' or not toItem.Class == This.Class
			This.cErrorMessage = 'Invalid item passed.'
			return .F.
		endif type('toItem.Class') <> 'C' ...
		
		* Copy the properties.
		
		This.cErrorMessage = ''
		CopyProperties(toItem, This)
		return .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemapplication AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	caninclude = .F.
	canrun = .T.
	defaulttags = Code
	Name = "projectitemapplication"
	treeviewimage = application
	
	PROCEDURE canedit_access
		local lcProject
		lcProject = forceext(This.Path, 'pjx')
		return file(lcProject)
		
	ENDPROC

	PROCEDURE edititem		&& Edits the item
		lparameters toProject
		local lcFileName, ;
			loFile, ;
			loExplorer, ;
			lcProject, ;
			llReturn
		if This.CanEdit
			lcFileName = This.Path
			loFile     = toProject.Files.Item(lcFileName)
			toProject.ProjectHook.QueryModifyFile(loFile)
			loExplorer = _screen.oProjectExplorers.Item(1)
			lcProject  = forceext(lcFileName, 'pjx')
			do (loExplorer.cMainFolder + 'ProjectExplorer') with lcProject
			llReturn = .T.
		else
			llReturn = .F.
		endif This.CanEdit
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_APPLICATION
		This.TypeName = DESC_APPLICATION
		
	ENDPROC

	PROCEDURE runitem		&& Runs the item
		* For some reason, using Run() on most things from code doesn't run it, so
		* let's do it manually.
		
		lparameters toProject
		local llReturn, ;
			lcFileName, ;
			loFile, ;
			loException as Exception
		This.cErrorMessage = ''
		llReturn = dodefault(toProject)
		if llReturn
			lcFileName = This.Path
			try
				loFile = toProject.Files.Item(lcFileName)
				toProject.ProjectHook.QueryRunFile(loFile)
				if lower(justext(lcFileName)) = 'app'
					do (lcFileName)
				else
					This.ExecuteFile(lcFileName)
				endif lower(justext(lcFileName)) = 'app'
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif llReturn
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemclass AS projectitem OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	*<DefinedPropArrayMethod>
		*m: copyitem		&& Copies the class to a new one
	*</DefinedPropArrayMethod>

	canedit = .T.
	canremove = .T.
	canrename = .T.
	defaulttags = Classes
	hasparent = .T.
	hasuser = .T.
	Name = "projectitemclass"
	removeprompt = Are you sure you want to remove the class from the class library?
	_memberdata = <VFPData>
		<memberdata name="copyitem" display="CopyItem"/>
		</VFPData>
	
	PROCEDURE canrun_access
		return not inlist(lower(This.ItemBaseClass), 'collection', 'separator') and ;
			not lower(This.ItemBaseClass) == 'page'
			&& check for page separately so doesn't match pageframe
		
	ENDPROC

	PROCEDURE copyitem		&& Copies the class to a new one
		local lcClass, ;
			lcSource, ;
			lcTarget, ;
			lcNewName, ;
			lcTemp, ;
			lnSelect, ;
			llReturn, ;
			loException as Exception
		lcClass   = This.ItemClass
		lcSource  = This.ItemLibrary
		lcTarget  = This.Path
		lcNewName = This.ItemName
		try
		
		* If the source and target VCXs are the same, we need to use an intermediary
		* VCX for copying.
		
			if lcSource == lcTarget
				lcTemp = addbs(sys(2023)) + sys(2015) + '.vcx'
				create classlib (lcTemp)
				add class (lcClass) of (lcSource) to (lcTemp)
				rename class (lcClass) of (lcTemp) to (lcNewName)
				add class (lcNewName) of (lcTemp) to (lcTarget)
				clear classlib (lcTemp)
				erase (lcTemp)
				erase (forceext(lcTemp, 'VCT'))
			else
				add class (lcClass) of (lcSource) to (lcTarget)
				rename class (lcClass) of (lcTarget) to (lcNewName)
			endif lcSource == lcTarget
		
		* Modify the new class.
		
			modify class (lcNewName) of (lcTarget) nowait
		
		* Blank ItemClass and ItemLibrary since they were only temporarily used when
		* copying a class.
		
			This.ItemClass   = ''
			This.ItemLibrary = ''
		
		* We need to assign new UNIQUEID values to the class and its members.
		
			lnSelect = select()
			use (lcTarget)
			locate for PLATFORM = 'WINDOWS' and OBJNAME == lower(lcNewName)
			replace rest UNIQUEID with sys(2015) for UNIQUEID <> 'RESERVED'
			use
			select (lnSelect)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE designercaption_access
		return ccTITLE_CLASS_DESIGNER + lower(justfname(This.Path)) + ' (' + ;
			lower(This.ItemName) + ')'
		
	ENDPROC

	PROCEDURE edititem
		lparameters toProject
		local loFile, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			loFile   = toProject.Files.Item(This.Path)
			llReturn = loFile.Modify(This.ItemName)
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE getproperties
		* Get the classes in this item's VCX, open the VCX so we can read the
		* timestamp, and fill in the properties.
		
		lparameters taClasses, ;
			tcAlias
		local lnSelect, ;
			lcClass, ;
			lcVCX, ;
			lnClasses, ;
			lcAlias, ;
			llOpened, ;
			llReturn, ;
			loException as Exception, ;
			lnClass
		This.cErrorMessage = ''
		lnSelect = select()
		lcClass  = This.ItemName
		
		* If we weren't passed an array of classes in the VCX or the alias of the open
		* VCX, get the array and open the VCX.
		
		if vartype(tcAlias) <> 'C'
			local taClasses[1]
			lcVCX     = This.Path
			lnClasses = avcxclasses(taClasses, lcVCX)
			lcAlias   = sys(2015)
			select 0
			try
				use (lcVCX) again shared alias (lcAlias)
				llOpened = .T.
				llReturn = .T.
			catch to loException
				This.cErrorMessage = loException.Message
			endtry
		else
			llReturn = .T.
			select (tcAlias)
		endif vartype(tcAlias) <> 'C'
		
		* Find the class in the VCX and the classes array and get the properties.
		
		if llReturn
			locate for PLATFORM = 'WINDOWS' and OBJNAME == lcClass and PARENT = ''
			lnClass = ascan(taClasses, lcClass, -1, -1, 1, 15)
			if lnClass > 0
				This.ItemBaseClass     = taClasses[lnClass,  2]
				This.ItemParentClass   = taClasses[lnClass,  3]
				This.ItemParentLibrary = taClasses[lnClass,  4]
				This.ToolbarIcon       = taClasses[lnClass,  5]
				This.Icon              = taClasses[lnClass,  6]
				This.ScaleMode         = taClasses[lnClass,  7]
				This.IncludeFile       = taClasses[lnClass,  9]
				This.OLEPublic         = taClasses[lnClass, 11]
				This.LastModified      = GetDateTimeFromTimeStamp(TIMESTAMP)
				if not empty(This.ItemParentLibrary)
					This.ItemParentLibrary = GetProperFileCase(fullpath(This.ItemParentLibrary, ;
						This.Path))
				endif not empty(This.ItemParentLibrary)
				if not empty(This.IncludeFile)
					This.IncludeFile = GetProperFileCase(fullpath(This.IncludeFile, ;
						This.Path))
				endif not empty(This.IncludeFile)
				store taClasses[lnClass,  8] to This.Description, ;
					This.OriginalDescription
				store taClasses[lnClass, 10] to This.User, This.OriginalUser
			endif lnClass > 0
		endif llReturn
		if llOpened
			use in select(lcAlias)
		endif llOpened
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type       = FILETYPE_CLASS
		This.TypeName   = DESC_CLASS
		This.ParentType = FILETYPE_CLASSLIB
		
	ENDPROC

	PROCEDURE isnamevalid
		lparameters tcName
		local laClasses[1]
		avcxclasses(laClasses, This.Path)
		return ascan(laClasses, tcName, -1, -1, 1, 15) = 0
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		
		* If ItemClass, which is normally not used for classes, is filled in, we are
		* copying rather subclassing.
		
		if not empty(This.ItemClass)
			llReturn = This.CopyItem()
		else
			try
				create class (This.ItemName) of (This.Path) as ;
					(This.ItemParentClass) from (This.ItemParentLibrary) nowait
				llReturn = .T.
			catch to loException
				This.cErrorMessage = loException.Message
			endtry
		endif not empty(This.ItemClass)
		return llReturn
		
	ENDPROC

	PROCEDURE removeitem
		* Remove the class from the class library. Manually call the QueryRemoveFile
		* method of any projecthook for the project because that's what happens in the
		* Project Manager.
		
		lparameters toProject, ;
			tlDelete
		local lcClass, ;
			lcFileName, ;
			llRemove, ;
			loFile, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		lcClass    = This.ItemName
		lcFileName = This.Path
		try
			llRemove = .T.
			if vartype(toProject.ProjectHook) = 'O'
				loFile   = toProject.Files.Item(lcFileName)
				llRemove = toProject.ProjectHook.QueryRemoveFile(loFile, lcClass, ;
					tlDelete)
			endif vartype(toProject.ProjectHook) = 'O'
			if llRemove
				remove class (lcClass) of (lcFileName)
				llReturn = .T.
			endif llRemove
		catch to loException
			This.cErrorMessage = loException.Message
			llRemove = .F.
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE renameitem
		lparameters toProject, ;
			tcNewName
		local lcPath, ;
			llReturn, ;
			loException as Exception
		try
			rename class (This.ItemName) of (This.Path) to (tcNewName)
			This.ItemName = tcNewName
			llReturn      = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE runitem
		lparameters toProject
		local lcName, ;
			loForm, ;
			loException
		try
			lcName = sys(2015)
			if lower(This.ItemBaseClass) = 'form'
				loForm = newobject(This.ItemName, This.Path)
				addproperty(_screen, lcName, loForm)
				loForm.Show()
			else
				_screen.NewObject(lcName, This.ItemName, This.Path)
				_screen.&lcName..Visible = .T.
			endif lower(This.ItemBaseClass) = 'form'
		catch to loException
			This.cErrorMessage = 'Cannot add this class to _SCREEN:' + ccCRLF + ;
				ccCRLF + loException.Message
		endtry
		
	ENDPROC

	PROCEDURE saveitem
		* Handle the properties of a class. Note that we don't support changes to some
		* things normally changed in the Class Designer: IncludeFile and ScaleMode.
		
		lparameters toProject
		local llReturn, ;
			lnSelect, ;
			lcIncludeFile, ;
			loException as Exception
		This.cErrorMessage  = ''
		This.ChangesWritten = .F.
		llReturn            = .T.
		lnSelect            = select()
		select 0
		try
			use (This.Path) again shared
			locate for PLATFORM = 'WINDOWS' and OBJNAME == This.ItemName and ;
				PARENT = ''
			if not This.Description == RESERVED7
				replace RESERVED7 with This.Description
				This.OriginalDescription = This.Description
				This.ChangesWritten      = .T.
			endif not This.Description == RESERVED7
			if not This.User == USER
				replace USER with This.User
				This.OriginalUser   = This.User
				This.ChangesWritten = .T.
			endif not This.Description == USER
			if not This.ToolbarIcon == RESERVED4
				replace RESERVED4 with This.ToolbarIcon
				This.ChangesWritten = .T.
			endif not This.ToolbarIcon == RESERVED4
			if not This.Icon == RESERVED5
				replace RESERVED5 with This.Icon
				This.ChangesWritten = .T.
			endif not This.Icon == RESERVED5
			lcIncludeFile = GetRelativePath(This.IncludeFile, This.Path)
			if not lower(lcIncludeFile) == lower(RESERVED8)
				replace RESERVED8 with lcIncludeFile
				This.ChangesWritten = .T.
			endif not lower(lcIncludeFile) == lower(RESERVED8)
			locate for PLATFORM = 'COMMENT' and UNIQUEID = 'RESERVED' and ;
				OBJNAME == This.ItemName
			do case
				case This.OLEPublic and empty(RESERVED2)
					replace RESERVED2 with 'OLEPublic'
					This.ChangesWritten = .T.
				case not This.OLEPublic and not empty(RESERVED2)
					replace RESERVED2 with ''
					This.ChangesWritten = .T.
			endcase
			use
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
			llReturn = .F.
		endtry
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE treeviewimage_access
		* Use the base class name as the image name.
		
		return This.ItemBaseClass
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemclasslib AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	defaulttags = Classes
	haschildren = .T.
	isbinary = .T.
	Name = "projectitemclasslib"
	treeviewimage = classlib
	
	PROCEDURE designercaption_access
		return lower(justfname(This.Path)) + ' (' + lower(This.Path) + ')' + ;
			ccTITLE_CLASS_BROWSER
		
	ENDPROC

	PROCEDURE edititem
		* Use the Class Browser to modify a VCX. Since that isn't the usual behavior
		* for the Modify method of a project file, we'll manually call the
		* QueryModifyFile method of any projecthook for the project.
		
		lparameters toProject
		local lcFileName, ;
			loFile, ;
			llReturn, ;
			loException as Exception
		lcFileName = This.Path
		This.cErrorMessage = ''
		try
			if vartype(toProject.ProjectHook) = 'O'
				loFile = toProject.Files.Item(lcFileName)
				toProject.ProjectHook.QueryModifyFile(loFile)
			endif vartype(toProject.ProjectHook) = 'O'
			do (_browser) with lcFileName
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_CLASSLIB
		This.TypeName = DESC_CLASSLIB
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			create classlib (This.Path)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemconnection AS projectitem OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canedit = .T.
	canremove = .T.
	canrename = .T.
	defaulttags = Data
	hasparent = .T.
	Name = "projectitemconnection"
	removeprompt = Are you sure you want to remove the connection from the database?
	treeviewimage = connection
	
	PROCEDURE designercaption_access
		return ccTITLE_CONNECTION_DESIGNER + lower(This.ItemName)
		
	ENDPROC

	PROCEDURE edititem
		lparameters toProject
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			modify connection (This.ItemName)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE getproperties
		lparameters toProject
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			store dbgetprop(This.ItemName, 'Connection', 'Comment') to This.Description, ;
				This.OriginalDescription
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type       = FILETYPE_CONNECTION
		This.TypeName   = DESC_CONNECTION
		This.ParentType = FILETYPE_DATABASE
		
	ENDPROC

	PROCEDURE isnamevalid
		lparameters tcName
		local laObjects[1], ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			adbobjects(laObjects, 'Connection')
			llReturn = ascan(laObjects, tcName, -1, -1, 1, 15) = 0
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			create connection (This.ItemName)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE removeitem
		lparameters toProject, ;
			tlDelete
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			delete connection (This.ItemName)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE renameitem
		lparameters toProject, ;
			tcNewName
		local lnPos, ;
			llReturn, ;
			loException as Exception
		try
			open database (This.ParentPath) shared
			rename connection (This.ItemName) to (tcNewName)
			This.ItemName = tcNewName
			lnPos         = at(ccKEY_SEPARATOR, This.Key)
			This.Key      = left(This.Key, lnPos) + tcNewName
			llReturn      = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE saveitem
		lparameters toProject
		local llReturn, ;
			lcDatabase, ;
			loException as Exception
		This.cErrorMessage  = ''
		This.ChangesWritten = .F.
		llReturn = .T.
		if not This.Description == This.OriginalDescription
			try
				open database (This.ParentPath) shared
				dbsetprop(This.ItemName, 'Connection', 'Comment', This.Description)
				This.OriginalDescription = This.Description
				This.ChangesWritten      = .T.
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif not toItem.Description == toItem.OriginalDescription
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemdatabase AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canrename = .F.
	defaulttags = Data
	haschildren = .T.
	isbinary = .T.
	Name = "projectitemdatabase"
	reloadafteredit = .T.
	removeprompt = Do you want to remove the database from the project or delete it from the disk?
	treeviewimage = database
	
	PROCEDURE designercaption_access
		return ccTITLE_DATABASE_DESIGNER + proper(juststem(This.Path))
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_DATABASE
		This.TypeName = DESC_DATABASE
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			modify database (This.Path) nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemfield AS projectitem OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canedit = .T.
	canrun = .T.
	defaulttags = Data
	hasparent = .T.
	Name = "projectitemfield"
	treeviewimage = field
	
	PROCEDURE edititem
		lparameters toProject
		local lnSelect, ;
			lcFileName, ;
			lcDatabase, ;
			llReturn, ;
			lcAlias, ;
			loFile, ;
			loException as Exception
		This.cErrorMessage = ''
		lnSelect   = select()
		lcFileName = This.Path
		lcDatabase = This.ParentPath
		lcAlias    = juststem(lcFileName)
		try
			do case
		
		* Modify the view this field belongs to.
		
				case inlist(This.ParentType, FILETYPE_REMOTE_VIEW, FILETYPE_LOCAL_VIEW)
					open database (lcDatabase) shared
					modify view (lcFileName) nowait
					llReturn = .T.
		
		* Modify the table in a DBC this field belongs to.
		
				case This.ParentType = FILETYPE_TABLE_IN_DBC
					use in select(lcAlias)
					open database (lcDatabase) shared
					select 0
					use (lcFileName) exclusive
					modify structure
					llReturn = .T.
		
		* Modify the free table this field belongs to.
		
				otherwise
					loFile   = toProject.Files.Item(lcFileName)
					llReturn = loFile.Modify()
			endcase
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE getproperties
		lparameters toProject
		local llReturn, ;
			lnPos, ;
			lcTable, ;
			loException as Exception
		This.cErrorMessage = ''
		llReturn = .T.
		if This.HasDescription
			lnPos   = at(ccKEY_SEPARATOR, This.ParentKey)
			lcTable = substr(This.ParentKey, lnPos + 1)
			try
				open database (This.ParentPath) shared
				store dbgetprop(lcTable + '.' + This.ItemName, 'Field', 'Comment') to ;
					This.Description, This.OriginalDescription
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif This.HasDescription
		return llReturn
		
	ENDPROC

	PROCEDURE hasdescription_access
		return inlist(This.ParentType, FILETYPE_TABLE_IN_DBC, FILETYPE_REMOTE_VIEW, ;
			FILETYPE_LOCAL_VIEW)
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_FIELD
		This.TypeName = DESC_FIELD
		
	ENDPROC

	PROCEDURE runitem
		lparameters toProject
		local lcFileName, ;
			lcDatabase, ;
			lcAlias, ;
			lnSelect, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		lcFileName = This.Path
		lcDatabase = This.ParentPath
		lcAlias    = juststem(lcFileName)
		lnSelect   = select()
		try
			if not empty(lcDatabase)
				open database (lcDatabase) shared
			endif not empty(lcDatabase)
			use in select(lcAlias)
			select 0
			use (lcFileName) shared
			browse last nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE saveitem
		lparameters toProject
		local llReturn, ;
			lnPos, ;
			lcTable, ;
			loException as Exception
		This.cErrorMessage  = ''
		This.ChangesWritten = .F.
		llReturn            = .T.
		if not This.Description == This.OriginalDescription and This.HasDescription
			lnPos   = at(ccKEY_SEPARATOR, This.ParentKey)
			lcTable = substr(This.ParentKey, lnPos + 1)
			try
				open database (This.ParentPath) shared
				dbsetprop(lcTable + '.' + This.ItemName, 'Field', 'Comment', ;
					This.Description)
				This.OriginalDescription = This.Description
				This.ChangesWritten      = .T.
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif not toItem.Description == toItem.OriginalDescription ...
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemfile AS projectitem OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canedit = .T.
	caninclude = .T.
	canremove = .T.
	canrename = .T.
	hasuser = .T.
	isfile = .T.
	Name = "projectitemfile"
	removeprompt = Do you want to remove the file from the project or delete it from the disk?
	
	PROCEDURE edititem
		lparameters toProject
		local loFile, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		if This.CanEdit
			try
				loFile   = toProject.Files.Item(This.Path)
				llReturn = loFile.Modify()
			catch to loException
				This.cErrorMessage = loException.Message
			endtry
		endif This.CanEdit
		return llReturn
		
	ENDPROC

	PROCEDURE getproperties
		lparameters toProject
		local lcItem, ;
			loFile, ;
			llReturn, ;
			loException as Exception
		lcItem = This.Path
		try
			loFile            = toProject.Files.Item(lcItem)
			This.Exclude      = loFile.Exclude
			This.LastModified = loFile.LastModified
			This.CodePage     = loFile.CodePage
			This.ReadOnly     = loFile.ReadOnly
			store loFile.Description to This.Description, This.OriginalDescription
			store upper(This.Path) == upper(toProject.MainFile) and ;
				This.Type <> FILETYPE_CLASSLIB to This.MainFile, ;
				This.OriginalMainFile
				&& check for VCX because the Project Manager has a bug that sets
				&& MainFile to a newly added VCX when there is no main file
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE isnamevalid
		lparameters tcName
		return not file(ChangeFileName(This.Path, tcName))
		
	ENDPROC

	PROCEDURE removeitem
		lparameters toProject, ;
			tlDelete
		local loFile, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			loFile   = toProject.Files.Item(This.Path)
			llReturn = loFile.Remove(tlDelete)
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE renameitem
		lparameters toProject, ;
			tcNewName
		local lcPath, ;
			lcOther, ;
			lcNewFile, ;
			loFile, ;
			llReturn, ;
			loException as Exception
		lcPath = ChangeFileName(This.Path, tcNewName)
		try
		
		* Rename the file and any associated files in the case of a VFP binary file.
		
			if file(This.Path)
				rename (This.Path) to (lcPath)
			endif file(This.Path)
			lcOther = GetVFPBinaryOtherFile(This.Path)
			if not empty(lcOther)
				lcNewFile = ChangeFileName(lcOther, tcNewName)
				rename (lcOther) to (lcNewFile)
				lcOther = GetVFPBinaryOtherFile(This.Path, .T.)
				if not empty(lcOther)
					lcNewFile = ChangeFileName(lcOther, tcNewName)
					rename (lcOther) to (lcNewFile)
				endif not empty(lcOther)
			endif not empty(lcOther)
			lcPath = GetProperFileCase(lcPath)
		
		* We have to manually change the filename in the PJX since the Name property of
		* a file object is read-only and there's no Rename method.
		
			lnSelect = select()
			select 0
			use (toProject.Name) again shared
			locate for NAME == lower(sys(2014, This.Path, toProject.Name)) + ccNULL
			replace NAME with lower(sys(2014, lcPath, toProject.Name)) + ccNULL, ;
				KEY with upper(tcNewName)
			use
			select (lnSelect)
		
		* Change the related properties.
		
			This.ItemName = tcNewName
			This.Path     = lcPath
			llReturn      = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE runitem
		lparameters toProject
		local loFile, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		if This.CanRun
			try
				loFile   = toProject.Files.Item(This.Path)
				llReturn = loFile.Run()
			catch to loException
				This.cErrorMessage = loException.Message
			endtry
		endif This.CanRun
		return llReturn
		
	ENDPROC

	PROCEDURE saveitem
		lparameters toProject
		local lcItem, ;
			lnSelect, ;
			llReturn, ;
			loFile, ;
			lcFileName, ;
			loException as Exception
		This.cErrorMessage  = ''
		This.ChangesWritten = .F.
		lcItem              = This.Path
		lnSelect            = select()
		llReturn            = .T.
		try
			loFile = toProject.Files.Item(lcItem)
			if not loFile.Description == This.Description
				loFile.Description       = This.Description
				This.ChangesWritten      = .T.
				This.OriginalDescription = This.Description
			endif not loFile.Description == This.Description
		
		* If this file is the main file and it wasn't before, set it. If it isn't but
		* it was before, clear it. Note that we have to hack the PJX file; calling
		* toProject.SetMain('') works but doesn't clear toProject.MainFile until close
		* and reopen the project.
		
			lcFileName = lower(lcItem)
			do case
				case This.MainFile and not This.OriginalMainFile
					store .F. to loFile.Exclude, This.Exclude
					llReturn = toProject.SetMain(loFile.Name)
					if not llReturn
						This.cErrorMessage = 'Cannot set the main file for the ' + ;
							'project to ' + lcItem
					endif not llReturn
					This.ChangesWritten = llReturn
				case not This.MainFile and This.OriginalMainFile
					select 0
					use (toProject.Name) again shared
					locate for DEVINFO = This.Key
					replace MAINPROG with .F.
					use
					select (lnSelect)
					This.ChangesWritten = .T.
			endcase
		
		* Save Exclude (we have to do this after handling MainFile).
		
			if loFile.Exclude <> This.Exclude
				loFile.Exclude      = This.Exclude
				This.ChangesWritten = .T.
			endif loFile.Exclude <> This.Exclude
		
		* If the value of User changed, save it to the appropriate record in the PJX.
		
			if not This.User == This.OriginalUser
				select 0
				use (toProject.Name) again shared
				locate for DEVINFO = This.Key
				if found() and not USER == This.User
					replace USER with This.User
				endif found() ...
				use
				This.OriginalUser   = This.User
				This.ChangesWritten = .T.
				select (lnSelect)
			endif not This.User == This.OriginalUser
		catch to loException
			This.cErrorMessage = loException.Message
			llReturn = .F.
		endtry
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemform AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canrun = .T.
	cansetmain = .T.
	defaulttags = Documents
	isbinary = .T.
	itembaseclass = Form
	Name = "projectitemform"
	treeviewimage = form
	
	PROCEDURE designercaption_access
		return ccTITLE_FORM_DESIGNER + lower(justfname(This.Path))
		
	ENDPROC

	PROCEDURE getproperties
		lparameters toProject
		local llReturn, ;
			lcItem, ;
			loFile, ;
			lnSelect
		llReturn = dodefault(toProject)
		if llReturn
			lcItem         = This.Path
			loFile         = toProject.Files.Item(lcItem)
			This.ItemClass = loFile.FileClass
			if empty(loFile.FileClassLibrary)
				This.ItemLibrary = ''
			else
				This.ItemLibrary = GetProperFileCase(fullpath(loFile.FileClassLibrary, ;
					toProject.Name))
			endif empty(loFile.FileClassLibrary)
			try
				lnSelect = select()
				select 0
				use (lcItem) again shared
				This.IncludeFile = RESERVED8
				if not empty(This.IncludeFile)
					This.IncludeFile = GetProperFileCase(fullpath(This.IncludeFile, ;
						This.Path))
				endif not empty(This.IncludeFile)
				use
				select (lnSelect)
			catch
			endtry
		endif llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_FORM
		This.TypeName = DESC_FORM
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		try
			if empty(This.ItemClass) or empty(This.ItemLibrary)
				modify form (This.Path) nowait
			else
				create form (This.Path) as (This.ItemClass) from (This.ItemLibrary) ;
					nowait
			endif empty(This.ItemClass) ...
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE runitem
		* For some reason, using Run() on most things from code doesn't run it, so
		* let's do it manually.
		
		lparameters toProject
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		llReturn = dodefault(toProject)
		if llReturn
			try
				do form (This.Path)
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif llReturn
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemfreetable AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canrun = .T.
	defaulttags = Data
	haschildren = .T.
	isbinary = .T.
	Name = "projectitemfreetable"
	reloadafteredit = .T.
	removeprompt = Do you want to remove the table from the project or delete it from the disk?
	treeviewimage = table
	
	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_FREETABLE
		This.TypeName = DESC_FREETABLE
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			set database to
			create (This.Path)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemindex AS projectitemfield OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canedit = .T.
	canrun = .T.
	defaulttags = Data
	Name = "projectitemindex"
	treeviewimage = index
	
	PROCEDURE getproperties
		lparameters toProject
		local llReturn, ;
			lnPos, ;
			lcTable, ;
			lcAlias, ;
			lnSelect, ;
			lnID, ;
			loException as Exception
		This.cErrorMessage = ''
		llReturn = .T.
		if This.HasDescription
			lnPos      = at(ccKEY_SEPARATOR, This.ParentKey)
			lcTable    = substr(This.ParentKey, lnPos + 1)
			lcAlias    = sys(2015)
			lnSelect   = select()
			select 0
			try
				use (This.ParentPath) again shared alias (lcAlias)
				locate for OBJECTTYPE = 'Table' and trim(OBJECTNAME) == lower(lcTable)
				lnID = OBJECTID
				locate for PARENTID = lnID and OBJECTTYPE = 'Index' and ;
					trim(OBJECTNAME) == lower(This.ItemName)
				store strextract(PROPERTY, chr(7), chr(0)) to This.Description, ;
					This.OriginalDescription
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
			use in select(lcAlias)
			select (lnSelect)
		endif This.HasDescription
		return llReturn
		
	ENDPROC

	PROCEDURE hasdescription_access
		return inlist(This.ParentType, FILETYPE_TABLE_IN_DBC, FILETYPE_REMOTE_VIEW, ;
			FILETYPE_LOCAL_VIEW)
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_INDEX
		This.TypeName = DESC_INDEX
		
	ENDPROC

	PROCEDURE saveitem
		lparameters toProject
		local llReturn, ;
			lnPos, ;
			lcTable, ;
			lcAlias, ;
			lnSelect, ;
			lnID, ;
			loException as Exception
		This.cErrorMessage  = ''
		This.ChangesWritten = .F.
		llReturn            = .T.
		if not This.Description == This.OriginalDescription and This.HasDescription
			lnPos      = at(ccKEY_SEPARATOR, This.ParentKey)
			lcTable    = substr(This.ParentKey, lnPos + 1)
			lcAlias    = sys(2015)
			lnSelect   = select()
			select 0
			try
				use (This.ParentPath) again shared alias (lcAlias)
				locate for OBJECTTYPE = 'Table' and trim(OBJECTNAME) == lower(lcTable)
				lnID = OBJECTID
				locate for PARENTID = lnID and OBJECTTYPE = 'Index' and ;
					trim(OBJECTNAME) == lower(This.ItemName)
				do PUTPROP with 7, This.Description
				This.OriginalDescription = This.Description
				This.ChangesWritten      = .T.
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
			use in select(lcAlias)
			select (lnSelect)
		endif not This.Description == This.OriginalDescription ...
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemlabel AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canrun = .T.
	defaulttags = Documents
	isbinary = .T.
	Name = "projectitemlabel"
	treeviewimage = labels
	
	PROCEDURE designercaption_access
		return ccTITLE_LABEL_DESIGNER + lower(justfname(This.Path))
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_LABEL
		This.TypeName = DESC_LABEL
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			modify label (This.Path) nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemlibrary AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canedit = .F.
	caninclude = .F.
	defaulttags = Code
	Name = "projectitemlibrary"
	treeviewimage = library
	
	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_APILIB
		This.TypeName = DESC_APILIB
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemlocalview AS projectitem OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canedit = .T.
	canremove = .T.
	canrename = .T.
	canrun = .T.
	defaulttags = Data
	haschildren = .T.
	hasparent = .T.
	Name = "projectitemlocalview"
	removeprompt = Are you sure you want to remove the view from the database?
	treeviewimage = LocalView
	
	PROCEDURE edititem
		lparameters toProject
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			modify view (This.ItemName) nowait
			This.DesignerCaption = ccTITLE_VIEW_DESIGNER + lower(This.ItemName)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE getproperties
		lparameters toProject
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			store dbgetprop(This.ItemName, 'View', 'Comment') to This.Description, ;
				This.OriginalDescription
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type       = FILETYPE_LOCAL_VIEW
		This.TypeName   = DESC_LOCAL_VIEW
		This.ParentType = FILETYPE_DATABASE
		
	ENDPROC

	PROCEDURE isnamevalid
		lparameters tcName
		local laObjects[1], ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			adbobjects(laObjects, 'View')
			llReturn = ascan(laObjects, tcName, -1, -1, 1, 15) = 0
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			create sql view (This.ItemName)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE removeitem
		lparameters toProject, ;
			tlDelete
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			delete view (This.ItemName)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE renameitem
		lparameters toProject, ;
			tcNewName
		local lnPos, ;
			llReturn, ;
			loException as Exception
		try
			open database (This.ParentPath) shared
			rename view (This.ItemName) to (tcNewName)
			This.ItemName = tcNewName
			This.Path     = tcNewName
			lnPos         = at(ccKEY_SEPARATOR, This.Key)
			This.Key      = left(This.Key, lnPos) + tcNewName
			llReturn      = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE runitem
		lparameters toProject
		local lcAlias, ;
			lnSelect, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		lcAlias  = This.ItemName
		lnSelect = select()
		try
			open database (This.ParentPath) shared
			use in select(lcAlias)
			select 0
			use (lcAlias) shared
			browse last nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE saveitem
		lparameters toProject
		local llReturn, ;
			lcDatabase, ;
			loException as Exception
		This.cErrorMessage  = ''
		This.ChangesWritten = .F.
		llReturn            = .T.
		if not This.Description == This.OriginalDescription
			try
				open database (This.ParentPath) shared
				dbsetprop(This.ItemName, 'View', 'Comment', This.Description)
				This.OriginalDescription = This.Description
				This.ChangesWritten      = .T.
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif not toItem.Description == toItem.OriginalDescription
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemmenu AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canrun = .T.
	defaulttags = Other
	isbinary = .T.
	Name = "projectitemmenu"
	treeviewimage = menu
	
	PROCEDURE designercaption_access
		return ccTITLE_MENU_DESIGNER + lower(justfname(This.Path))
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_MENU
		This.TypeName = DESC_MENU
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			modify menu (This.Path) nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE runitem
		* For some reason, using Run() on most things from code doesn't run it, so
		* let's do it manually.
		
		lparameters toProject
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		llReturn = dodefault(toProject)
		if llReturn
			try
				do (forceext(This.Path, 'mpr'))
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif llReturn
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemother AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	defaulttags = Other
	Name = "projectitemother"
	treeviewimage = other
	
	PROCEDURE canedit_access
		return inlist(lower(justext(This.Path)), 'bmp', 'msk', 'gif', 'jpg', 'jpeg', ;
			'ico', 'png', 'tif', 'tiff')
		
	ENDPROC

	PROCEDURE edititem
		* For image files, use the default application. Manually call the
		* QueryModifyFile method of any project hook.
		
		lparameters toProject
		local lcFileName, ;
			loFile, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		if This.CanEdit
			lcFileName = This.Path
			try
				if vartype(toProject.ProjectHook) = 'O'
					loFile = toProject.Files.Item(lcFileName)
					toProject.ProjectHook.QueryModifyFile(loFile)
				endif vartype(toProject.ProjectHook) = 'O'
				This.ExecuteFile(lcFileName, 'Edit')
				llReturn = .T.
			catch to loException
				This.cErrorMessage = loException.Message
			endtry	
		else
			llReturn = .F.
		endif This.CanEdit
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_OTHER
		This.TypeName = DESC_OTHER
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemprogram AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canrun = .T.
	cansetmain = .T.
	defaulttags = Code
	Name = "projectitemprogram"
	treeviewimage = code
	
	PROCEDURE designercaption_access
		return lower(justfname(This.Path))
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_PROGRAM
		This.TypeName = DESC_PROGRAM
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			modify command (This.Path) nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE runitem
		* For some reason, using Run() on most things from code doesn't run it, so
		* let's do it manually.
		
		lparameters toProject
		local llReturn, ;
			loException as Exception
		private plInsideTry
		This.cErrorMessage = ''
		llReturn = dodefault(toProject)
		if llReturn
			try
				plInsideTry = .T.
					&& flag that an error handler can check when deciding if it can use
					&& RETURN TO or not
				set datasession to 1
				do (This.Path)
			catch to loException
				This.cErrorMessage = 'Error #' + transform(loException.ErrorNo) + ;
					' occurred in line ' + transform(loException.LineNo) + ' of ' + ;
					loException.Procedure + ':' + ccCRLF + ccCRLF + ;
					loException.Message + ccCRLF + ccCRLF + loException.LineContents
				llReturn = .F.
			endtry
		endif llReturn
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemquery AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canrun = .T.
	defaulttags = Data
	Name = "projectitemquery"
	treeviewimage = query
	
	PROCEDURE designercaption_access
		return ccTITLE_QUERY_DESIGNER + This.ItemName
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_QUERY
		This.TypeName = DESC_QUERY
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			modify query (This.Path) nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE runitem
		* For some reason, using Run() on most things from code doesn't run it, so
		* let's do it manually.
		
		lparameters toProject
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		llReturn = dodefault(toProject)
		if llReturn
			try
				do (This.Path)
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif llReturn
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemremoteview AS projectitemlocalview OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	defaulttags = Data
	Name = "projectitemremoteview"
	treeviewimage = RemoteView
	
	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_REMOTE_VIEW
		This.TypeName = DESC_REMOTE_VIEW
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			create sql view (This.ItemName) remote
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemreport AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canrun = .T.
	defaulttags = Documents
	isbinary = .T.
	Name = "projectitemreport"
	treeviewimage = report
	
	PROCEDURE designercaption_access
		return ccTITLE_REPORT_DESIGNER + lower(justfname(This.Path))
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_REPORT
		This.TypeName = DESC_REPORT
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			modify report (This.Path) nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemstoredproc AS projectitem OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canedit = .T.
	defaulttags = Data
	hasdescription = .F.
	hasparent = .T.
	Name = "projectitemstoredproc"
	treeviewimage = code
	
	PROCEDURE designercaption_access
		return ccTITLE_STORED_PROCS + proper(juststem(This.ParentPath))
		
	ENDPROC

	PROCEDURE edititem
		lparameters toProject
		local llReturn, ;
			loException
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			modify procedure nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type       = FILETYPE_STORED_PROCEDURE
		This.TypeName   = DESC_STORED_PROCEDURE
		This.ParentType = FILETYPE_DATABASE
		
	ENDPROC

	PROCEDURE newitem
		This.EditItem()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemtableindbc AS projectitem OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	canedit = .T.
	caninclude = .T.
	canremove = .T.
	canrename = .T.
	canrun = .T.
	defaulttags = Data
	haschildren = .T.
	hasparent = .T.
	isbinary = .T.
	isfile = .T.
	Name = "projectitemtableindbc"
	removeprompt = Do you want to remove the table from the database or delete it from the disk?
	treeviewimage = table
	
	PROCEDURE edititem
		lparameters toProject
		local lnSelect, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		lnSelect = select()
		try
			lnDataSession = set('DATASESSION')
			set datasession to 1
			open database (This.ParentPath) shared
			CloseFile(This.ItemName)
			select 0
			use (This.Path) exclusive
			modify structure
			set datasession to lnDataSession
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE getproperties
		lparameters toProject
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			store dbgetprop(This.ItemName, 'Table', 'Comment') to This.Description, ;
				This.OriginalDescription
		
		* If this table is included, it'll have its own record in the PJX.
		
			store type('toProject.Files[lower(This.Path)]') <> 'O' to This.Exclude, ;
				This.OriginalExclude
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type       = FILETYPE_TABLE_IN_DBC
		This.TypeName   = DESC_TABLE_IN_DBC
		This.ParentType = FILETYPE_DATABASE
		
	ENDPROC

	PROCEDURE isnamevalid
		lparameters tcName
		local laObjects[1], ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			adbobjects(laObjects, 'Table')
			llReturn = ascan(laObjects, tcName, -1, -1, 1, 15) = 0 and ;
				not file(forcepath(tcName, justpath(This.Path)))
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			open database (This.ParentPath) shared
			create (This.Path)
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE removeitem
		lparameters toProject, ;
			tlDelete
		local lcName, ;
			lcDelete, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			lcName = This.ItemName
			open database (This.ParentPath) shared
			CloseFile(lcName)
			lcDelete = iif(tlDelete, 'delete recycle', '')
			remove table (lcName) &lcDelete
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE renameitem
		lparameters toProject, ;
			tcNewName
		local lcFile, ;
			lcOther, ;
			lnSelect, ;
			lcAlias, ;
			lnPos, ;
			llReturn, ;
			loException as Exception
		try
		
		* Change the table name.
		
			open database (This.ParentPath) shared
			rename table (This.ItemName) to (tcNewName)
		
		* Rename the DBF, CDX, and FPT files.
		
			lcFile = ChangeFileName(This.Path, tcNewName)
			rename (This.Path) to (lcFile)
			lcOther = forceext(This.Path, 'cdx')
			if file(lcOther)
				rename (lcOther) to (ChangeFileName(lcOther, tcNewName))
			endif file(lcOther)
			lcOther = forceext(This.Path, 'fpt')
			if file(lcOther)
				rename (lcOther) to (ChangeFileName(lcOther, tcNewName))
			endif file(lcOther)
		
		* Fix the path to the table in the DBC.
		
			lnSelect = select()
			lcAlias  = sys(2015)
			select 0
			use (This.ParentPath) again shared alias (lcAlias)
			locate for OBJECTTYPE = 'Table' and trim(OBJECTNAME) == lower(tcNewName)
			do PUTPROP with 1, lower(sys(2014, lcFile, This.ParentPath))
			use
			select (lnSelect)
		
		* Change the properties.
		
			This.Path     = lcFile
			This.ItemName = tcNewName
			lnPos         = at(ccKEY_SEPARATOR, This.Key)
			This.Key      = left(This.Key, lnPos) + tcNewName
			llReturn      = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

	PROCEDURE runitem
		lparameters toProject
		local lnSelect, ;
			lnDataSession, ;
			llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		lnSelect = select()
		try
			lnDataSession = set('DATASESSION')
			set datasession to 1
			open database (This.ParentPath) shared
			CloseFile(This.ItemName)
			select 0
			use (This.Path) shared
			browse last nowait in screen
			set datasession to lnDataSession
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		select (lnSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE saveitem
		lparameters toProject
		local llReturn, ;
			lnSelect, ;
			lcPath, ;
			lnID, ;
			loException as Exception
		This.cErrorMessage  = ''
		This.ChangesWritten = .F.
		llReturn            = .T.
		
		* If Exclude is .F., we have to add a record to the PJX file. We can't use
		* Project.Files.Add because that does nothing but return the file object for
		* the DBC. Conversely, we have to remove the record from the PJX if Exclude is
		* .T.
		
		lnSelect = select()
		if This.OriginalExclude <> This.Exclude
			select 0
			try
				use (toProject.Name) again shared
				locate for DEVINFO = This.Key
				do case
		
		* The table is excluded and we found its record in the PJX so delete it.
		
					case This.Exclude and found()
						delete
		
		* The table is excluded and we didn't find its record in the PJX; this
		* shouldn't happen.
		
					case This.Exclude
		
		* The table is included and we didn't find its record in the PJX, so add it.
		
					case not found()
						lcPath = lower(sys(2014, This.Path, toProject.Name))
						lnID   = GetTimestampFromDateTime(datetime())
						insert into (alias()) (NAME, TYPE, ID, DEVINFO, LOCAL, KEY) ;
							values (lcPath, This.Type, lnID, This.Key, .T., ;
							upper(This.ItemName))
		
		* The table is included and we found its record in the PJX; this shouldn't
		* happen.
		
					otherwise
				endcase
				use
				This.OriginalExclude = This.Exclude
				This.ChangesWritten  = .T.
			catch to loException
			endtry
			select (lnSelect)
		endif This.OriginalExclude <> This.Exclude
		
		* If the value of Description, update the database.
		
		if not This.Description == This.OriginalDescription
			try
				open database (This.ParentPath) shared
				dbsetprop(This.ItemName, 'Table', 'Comment', This.Description)
				This.OriginalDescription = This.Description
				This.ChangesWritten      = .T.
			catch to loException
				This.cErrorMessage = loException.Message
				llReturn = .F.
			endtry
		endif not toItem.Description == toItem.OriginalDescription
		select (lnSelect)
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS projectitemtext AS projectitemfile OF "projectexploreritems.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "projectexplorer.h"
	defaulttags = Other
	Name = "projectitemtext"
	treeviewimage = text
	
	PROCEDURE designercaption_access
		return lower(justfname(This.Path))
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		This.Type     = FILETYPE_TEXT
		This.TypeName = DESC_TEXT
		
	ENDPROC

	PROCEDURE newitem
		local llReturn, ;
			loException as Exception
		This.cErrorMessage = ''
		try
			modify file (This.Path) nowait
			llReturn = .T.
		catch to loException
			This.cErrorMessage = loException.Message
		endtry
		return llReturn
		
	ENDPROC

ENDDEFINE
